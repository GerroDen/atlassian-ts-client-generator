/* tslint:disable */
/* eslint-disable */
/**
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorMessage1,
  SecurityWorkspaceIds,
  SecurityWorkspaceResponse,
  SubmitSecurityWorkspacesRequest,
  SubmitVulnerabilitiesRequest,
  SubmitVulnerabilitiesResponse,
  VulnerabilityDetails,
} from '../models/index';

export interface DeleteLinkedWorkspacesRequest {
    authorization: string;
}

export interface DeleteVulnerabilitiesByPropertyRequest {
    authorization: string;
}

export interface DeleteVulnerabilityByIdRequest {
    authorization: string;
    vulnerabilityId: string;
}

export interface GetLinkedWorkspaceByIdRequest {
    authorization: string;
    workspaceId: string;
}

export interface GetLinkedWorkspacesRequest {
    authorization: string;
}

export interface GetVulnerabilityByIdRequest {
    authorization: string;
    vulnerabilityId: string;
}

export interface SubmitVulnerabilitiesOperationRequest {
    authorization: string;
    submitVulnerabilitiesRequest: SubmitVulnerabilitiesRequest;
}

export interface SubmitWorkspacesRequest {
    authorization: string;
    submitSecurityWorkspacesRequest: SubmitSecurityWorkspacesRequest;
}

/**
 * 
 */
export class SecurityInformationApi extends runtime.BaseAPI {

    /**
     * Bulk delete all linked Security Workspaces that match the given request.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'DELETE\' scope for Connect apps.  e.g. DELETE /bulk?workspaceIds=111-222-333,444-555-666 
     * Delete linked Security Workspaces
     */
    async deleteLinkedWorkspacesRaw(requestParameters: DeleteLinkedWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling deleteLinkedWorkspaces().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/rest/security/1.0/linkedWorkspaces/bulk`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Bulk delete all linked Security Workspaces that match the given request.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'DELETE\' scope for Connect apps.  e.g. DELETE /bulk?workspaceIds=111-222-333,444-555-666 
     * Delete linked Security Workspaces
     */
    async deleteLinkedWorkspaces(requestParameters: DeleteLinkedWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteLinkedWorkspacesRaw(requestParameters, initOverrides);
    }

    /**
     * Bulk delete all Vulnerabilities that match the given request.  One or more query params must be supplied to specify Properties to delete by. If more than one Property is provided, data will be deleted that matches ALL of the Properties (e.g. treated as an AND). Read the POST bulk endpoint documentation for more details.  e.g. DELETE /bulkByProperties?accountId=account-123&createdBy=user-456  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'DELETE\' scope for Connect apps. 
     * Delete Vulnerabilities by Property
     */
    async deleteVulnerabilitiesByPropertyRaw(requestParameters: DeleteVulnerabilitiesByPropertyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling deleteVulnerabilitiesByProperty().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/rest/security/1.0/bulkByProperties`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Bulk delete all Vulnerabilities that match the given request.  One or more query params must be supplied to specify Properties to delete by. If more than one Property is provided, data will be deleted that matches ALL of the Properties (e.g. treated as an AND). Read the POST bulk endpoint documentation for more details.  e.g. DELETE /bulkByProperties?accountId=account-123&createdBy=user-456  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'DELETE\' scope for Connect apps. 
     * Delete Vulnerabilities by Property
     */
    async deleteVulnerabilitiesByProperty(requestParameters: DeleteVulnerabilitiesByPropertyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteVulnerabilitiesByPropertyRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the Vulnerability data currently stored for the given ID.  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'DELETE\' scope for Connect apps. 
     * Delete a Vulnerability by ID
     */
    async deleteVulnerabilityByIdRaw(requestParameters: DeleteVulnerabilityByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling deleteVulnerabilityById().'
            );
        }

        if (requestParameters['vulnerabilityId'] == null) {
            throw new runtime.RequiredError(
                'vulnerabilityId',
                'Required parameter "vulnerabilityId" was null or undefined when calling deleteVulnerabilityById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/rest/security/1.0/vulnerability/{vulnerabilityId}`.replace(`{${"vulnerabilityId"}}`, encodeURIComponent(String(requestParameters['vulnerabilityId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the Vulnerability data currently stored for the given ID.  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'DELETE\' scope for Connect apps. 
     * Delete a Vulnerability by ID
     */
    async deleteVulnerabilityById(requestParameters: DeleteVulnerabilityByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteVulnerabilityByIdRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a specific Security Workspace linked to the Jira site for the given workspace ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'READ\' scope for Connect apps. 
     * Get a linked Security Workspace by ID
     */
    async getLinkedWorkspaceByIdRaw(requestParameters: GetLinkedWorkspaceByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SecurityWorkspaceResponse>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling getLinkedWorkspaceById().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling getLinkedWorkspaceById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/rest/security/1.0/linkedWorkspaces/{workspaceId}`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a specific Security Workspace linked to the Jira site for the given workspace ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'READ\' scope for Connect apps. 
     * Get a linked Security Workspace by ID
     */
    async getLinkedWorkspaceById(requestParameters: GetLinkedWorkspaceByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SecurityWorkspaceResponse> {
        const response = await this.getLinkedWorkspaceByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all Security Workspaces linked with the Jira site.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'READ\' scope for Connect apps. 
     * Get linked Security Workspaces
     */
    async getLinkedWorkspacesRaw(requestParameters: GetLinkedWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SecurityWorkspaceIds>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling getLinkedWorkspaces().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/rest/security/1.0/linkedWorkspaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve all Security Workspaces linked with the Jira site.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'READ\' scope for Connect apps. 
     * Get linked Security Workspaces
     */
    async getLinkedWorkspaces(requestParameters: GetLinkedWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SecurityWorkspaceIds> {
        const response = await this.getLinkedWorkspacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the currently stored Vulnerability data for the given ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'READ\' scope for Connect apps. 
     * Get a Vulnerability by ID
     */
    async getVulnerabilityByIdRaw(requestParameters: GetVulnerabilityByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VulnerabilityDetails>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling getVulnerabilityById().'
            );
        }

        if (requestParameters['vulnerabilityId'] == null) {
            throw new runtime.RequiredError(
                'vulnerabilityId',
                'Required parameter "vulnerabilityId" was null or undefined when calling getVulnerabilityById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/rest/security/1.0/vulnerability/{vulnerabilityId}`.replace(`{${"vulnerabilityId"}}`, encodeURIComponent(String(requestParameters['vulnerabilityId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the currently stored Vulnerability data for the given ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'READ\' scope for Connect apps. 
     * Get a Vulnerability by ID
     */
    async getVulnerabilityById(requestParameters: GetVulnerabilityByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VulnerabilityDetails> {
        const response = await this.getVulnerabilityByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update / Insert Vulnerability data.  Vulnerabilities are identified by their ID, any existing Vulnerability data with the same ID will be replaced if it exists and the updateSequenceNumber of the existing data is less than the incoming data.  Submissions are performed asynchronously. Most updates are available within a short period of time but may take some time during peak load and/or maintenance times. The GET vulnerability endpoint can be used to confirm that data has been stored successfully (if needed).  In the case of multiple Vulnerabilities being submitted in one request, each is validated individually prior to submission. Details of Vulnerabilities that failed submission (if any) are available in the response object.  A maximum of 1000 vulnerabilities can be submitted in one request.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'WRITE\' scope for Connect apps. 
     * Submit Vulnerability data
     */
    async submitVulnerabilitiesRaw(requestParameters: SubmitVulnerabilitiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmitVulnerabilitiesResponse>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling submitVulnerabilities().'
            );
        }

        if (requestParameters['submitVulnerabilitiesRequest'] == null) {
            throw new runtime.RequiredError(
                'submitVulnerabilitiesRequest',
                'Required parameter "submitVulnerabilitiesRequest" was null or undefined when calling submitVulnerabilities().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/rest/security/1.0/bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submitVulnerabilitiesRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update / Insert Vulnerability data.  Vulnerabilities are identified by their ID, any existing Vulnerability data with the same ID will be replaced if it exists and the updateSequenceNumber of the existing data is less than the incoming data.  Submissions are performed asynchronously. Most updates are available within a short period of time but may take some time during peak load and/or maintenance times. The GET vulnerability endpoint can be used to confirm that data has been stored successfully (if needed).  In the case of multiple Vulnerabilities being submitted in one request, each is validated individually prior to submission. Details of Vulnerabilities that failed submission (if any) are available in the response object.  A maximum of 1000 vulnerabilities can be submitted in one request.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'WRITE\' scope for Connect apps. 
     * Submit Vulnerability data
     */
    async submitVulnerabilities(requestParameters: SubmitVulnerabilitiesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmitVulnerabilitiesResponse> {
        const response = await this.submitVulnerabilitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert Security Workspace IDs to establish a relationship between them and the Jira site the app is installed on. If a relationship between the workspace ID and Jira already exists then the workspace ID will be ignored and Jira will process the rest of the entries.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'WRITE\' scope for Connect apps. 
     * Submit Security Workspaces to link
     */
    async submitWorkspacesRaw(requestParameters: SubmitWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling submitWorkspaces().'
            );
        }

        if (requestParameters['submitSecurityWorkspacesRequest'] == null) {
            throw new runtime.RequiredError(
                'submitSecurityWorkspacesRequest',
                'Required parameter "submitSecurityWorkspacesRequest" was null or undefined when calling submitWorkspaces().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/rest/security/1.0/linkedWorkspaces/bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submitSecurityWorkspacesRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Insert Security Workspace IDs to establish a relationship between them and the Jira site the app is installed on. If a relationship between the workspace ID and Jira already exists then the workspace ID will be ignored and Jira will process the rest of the entries.  Only Connect apps that define the `jiraSecurityInfoProvider` module can access this resource. This resource requires the \'WRITE\' scope for Connect apps. 
     * Submit Security Workspaces to link
     */
    async submitWorkspaces(requestParameters: SubmitWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.submitWorkspacesRaw(requestParameters, initOverrides);
    }

}
