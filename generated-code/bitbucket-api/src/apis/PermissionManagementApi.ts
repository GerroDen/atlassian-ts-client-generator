/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AdminPasswordUpdate,
  FindUsersInGroup200Response,
  GetAllAccessTokens401Response,
  GetGroups1200Response,
  GetGroups200Response,
  GetGroupsWithAnyPermission200Response,
  GetUsersWithAnyPermission1200Response,
  GetUsersWithoutAnyPermission200Response,
  GroupAndUsers,
  GroupPickerContext,
  RestDetailedGroup,
  RestDetailedUser,
  RestErasedUser,
  RestUserDirectory,
  UserAndGroups,
  UserPickerContext,
  UserRename,
  UserUpdate,
} from '../models/index';

interface AddGroupToUserRequest {
    groupPickerContext?: GroupPickerContext;
}

interface AddUserToGroupRequest {
    userPickerContext?: UserPickerContext;
}

interface AddUserToGroupsRequest {
    userAndGroups?: UserAndGroups;
}

interface AddUsersToGroupRequest {
    groupAndUsers?: GroupAndUsers;
}

interface ClearUserCaptchaChallengeRequest {
    name: string;
}

interface CreateGroupRequest {
    name: string;
}

interface CreateUserRequest {
    emailAddress: string;
    displayName: string;
    name: string;
    password?: string;
    addToDefaultGroup?: boolean;
    notify?: boolean;
}

interface DeleteGroupRequest {
    name: string;
}

interface DeleteUserRequest {
    name: string;
}

interface EraseUserRequest {
    name: string;
}

interface FindGroupsForUserRequest {
    context: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface FindOtherGroupsForUserRequest {
    context: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface FindUsersInGroupRequest {
    context: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface FindUsersNotInGroupRequest {
    context: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetGroupsRequest {
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetGroups1Request {
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetGroupsWithAnyPermissionRequest {
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetGroupsWithAnyPermission2Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetGroupsWithoutAnyPermissionRequest {
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetGroupsWithoutAnyPermission2Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetUserDirectoriesRequest {
    includeInactive?: string;
}

interface GetUsers1Request {
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetUsersWithAnyPermissionRequest {
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetUsersWithAnyPermission2Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetUsersWithoutAnyPermissionRequest {
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetUsersWithoutPermission1Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface RemoveGroupFromUserRequest {
    groupPickerContext?: GroupPickerContext;
}

interface RemoveUserFromGroupRequest {
    userPickerContext?: UserPickerContext;
}

interface RenameUserRequest {
    userRename?: UserRename;
}

interface RevokePermissions1Request {
    projectKey: string;
    repositorySlug: string;
    user?: string;
    group?: string;
}

interface RevokePermissionsForGroupRequest {
    name: string;
}

interface RevokePermissionsForGroup2Request {
    projectKey: string;
    name: string;
    repositorySlug: string;
}

interface RevokePermissionsForUserRequest {
    name: string;
}

interface RevokePermissionsForUser2Request {
    projectKey: string;
    name: string;
    repositorySlug: string;
}

interface SearchPermissions1Request {
    projectKey: string;
    repositorySlug: string;
    permission?: string;
    filterText?: string;
    type?: string;
}

interface SetPermissionForGroupRequest {
    projectKey: string;
    name: Array<string>;
    permission: SetPermissionForGroupPermissionEnum;
    repositorySlug: string;
}

interface SetPermissionForGroupsRequest {
    name: Array<string>;
    permission: SetPermissionForGroupsPermissionEnum;
}

interface SetPermissionForUserRequest {
    projectKey: string;
    name: Array<string>;
    permission: SetPermissionForUserPermissionEnum;
    repositorySlug: string;
}

interface SetPermissionForUsersRequest {
    name: Array<string>;
    permission: SetPermissionForUsersPermissionEnum;
}

interface UpdateUserDetailsRequest {
    userUpdate?: UserUpdate;
}

interface UpdateUserPasswordRequest {
    adminPasswordUpdate?: AdminPasswordUpdate;
}

interface ValidateErasableRequest {
    name: string;
}

/**
 * 
 */
export class PermissionManagementApi extends runtime.BaseAPI {

    /**
     * <strong>Deprecated since 2.10</strong>. Use /rest/users/add-groups instead.  Add a user to a group. This is very similar to <code>groups/add-user</code>, but with the <em>context</em> and <em>itemName</em> attributes of the supplied request entity reversed. On the face of it this may appear redundant, but it facilitates a specific UI component in the application.  In the request entity, the <em>context</em> attribute is the user and the <em>itemName</em> is the group.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Add user to group
     * @deprecated
     */
    async addGroupToUserRaw(requestParameters: AddGroupToUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/users/add-group`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['groupPickerContext'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * <strong>Deprecated since 2.10</strong>. Use /rest/users/add-groups instead.  Add a user to a group. This is very similar to <code>groups/add-user</code>, but with the <em>context</em> and <em>itemName</em> attributes of the supplied request entity reversed. On the face of it this may appear redundant, but it facilitates a specific UI component in the application.  In the request entity, the <em>context</em> attribute is the user and the <em>itemName</em> is the group.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Add user to group
     * @deprecated
     */
    async addGroupToUser(requestParameters: AddGroupToUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addGroupToUserRaw(requestParameters, initOverrides);
    }

    /**
     * <strong>Deprecated since 2.10</strong>. Use /rest/users/add-groups instead.  Add a user to a group.  In the request entity, the <em>context</em> attribute is the group and the <em>itemName</em> is the user.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Add user to group
     * @deprecated
     */
    async addUserToGroupRaw(requestParameters: AddUserToGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/groups/add-user`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['userPickerContext'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * <strong>Deprecated since 2.10</strong>. Use /rest/users/add-groups instead.  Add a user to a group.  In the request entity, the <em>context</em> attribute is the group and the <em>itemName</em> is the user.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Add user to group
     * @deprecated
     */
    async addUserToGroup(requestParameters: AddUserToGroupRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addUserToGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Add a user to one or more groups.    The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Add user to groups
     */
    async addUserToGroupsRaw(requestParameters: AddUserToGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/users/add-groups`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['userAndGroups'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add a user to one or more groups.    The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Add user to groups
     */
    async addUserToGroups(requestParameters: AddUserToGroupsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addUserToGroupsRaw(requestParameters, initOverrides);
    }

    /**
     * Add multiple users to a group.   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Add multiple users to group
     */
    async addUsersToGroupRaw(requestParameters: AddUsersToGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/groups/add-users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['groupAndUsers'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add multiple users to a group.   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Add multiple users to group
     */
    async addUsersToGroup(requestParameters: AddUsersToGroupRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addUsersToGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Clears any CAPTCHA challenge that may constrain the user with the supplied username when they authenticate. Additionally any counter or metric that contributed towards the user being issued the CAPTCHA challenge (for instance too many consecutive failed logins) will also be reset.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource, and may not clear the CAPTCHA of a user with greater permissions than themselves.
     * Clear CAPTCHA for user
     */
    async clearUserCaptchaChallengeRaw(requestParameters: ClearUserCaptchaChallengeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling clearUserCaptchaChallenge().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/users/captcha`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Clears any CAPTCHA challenge that may constrain the user with the supplied username when they authenticate. Additionally any counter or metric that contributed towards the user being issued the CAPTCHA challenge (for instance too many consecutive failed logins) will also be reset.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource, and may not clear the CAPTCHA of a user with greater permissions than themselves.
     * Clear CAPTCHA for user
     */
    async clearUserCaptchaChallenge(requestParameters: ClearUserCaptchaChallengeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.clearUserCaptchaChallengeRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new group.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Create group
     */
    async createGroupRaw(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDetailedGroup>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling createGroup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/groups`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new group.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Create group
     */
    async createGroup(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDetailedGroup> {
        const response = await this.createGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new user from the assembled query parameters.  The default group can be used to control initial permissions for new users, such as granting users the ability to login or providing read access to certain projects or repositories. If the user is not added to the default group, they may not be able to login after their account is created until explicit permissions are configured.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Create user
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['emailAddress'] == null) {
            throw new runtime.RequiredError(
                'emailAddress',
                'Required parameter "emailAddress" was null or undefined when calling createUser().'
            );
        }

        if (requestParameters['displayName'] == null) {
            throw new runtime.RequiredError(
                'displayName',
                'Required parameter "displayName" was null or undefined when calling createUser().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling createUser().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['emailAddress'] != null) {
            queryParameters['emailAddress'] = requestParameters['emailAddress'];
        }

        if (requestParameters['password'] != null) {
            queryParameters['password'] = requestParameters['password'];
        }

        if (requestParameters['addToDefaultGroup'] != null) {
            queryParameters['addToDefaultGroup'] = requestParameters['addToDefaultGroup'];
        }

        if (requestParameters['displayName'] != null) {
            queryParameters['displayName'] = requestParameters['displayName'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['notify'] != null) {
            queryParameters['notify'] = requestParameters['notify'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new user from the assembled query parameters.  The default group can be used to control initial permissions for new users, such as granting users the ability to login or providing read access to certain projects or repositories. If the user is not added to the default group, they may not be able to login after their account is created until explicit permissions are configured.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Create user
     */
    async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createUserRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes the specified group, removing them from the system. This also removes any permissions that may have been granted to the group.  A user may not delete the last group that is granting them administrative permissions, or a group with greater permissions than themselves.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Remove group
     */
    async deleteGroupRaw(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDetailedGroup>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteGroup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/groups`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes the specified group, removing them from the system. This also removes any permissions that may have been granted to the group.  A user may not delete the last group that is granting them administrative permissions, or a group with greater permissions than themselves.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Remove group
     */
    async deleteGroup(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDetailedGroup> {
        const response = await this.deleteGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the specified user, removing them from the system. This also removes any permissions that may have been granted to the user.  A user may not delete themselves, and a user with <strong>ADMIN</strong> permissions may not delete a user with <strong>SYS_ADMIN</strong>permissions.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Remove user
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDetailedUser>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteUser().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/users`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes the specified user, removing them from the system. This also removes any permissions that may have been granted to the user.  A user may not delete themselves, and a user with <strong>ADMIN</strong> permissions may not delete a user with <strong>SYS_ADMIN</strong>permissions.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Remove user
     */
    async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDetailedUser> {
        const response = await this.deleteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Erases personally identifying user data for a deleted user.  References in the application to the original username will be either removed or updated to a new non-identifying username. Refer to the <a href=\"https://confluence.atlassian.com/gdpr/bitbucket-right-to-erasure-949770560.html\">support guide</a> for details about what data is and isn\'t erased.  User erasure can only be performed on a deleted user. If the user has not been deleted first then this endpoint will return a bad request and no erasure will be performed.  Erasing user data is <strong>irreversible</strong> and may lead to a degraded user experience. This method should not be used as part of a standard user deletion and cleanup process.  Plugins can participate in user erasure by defining a <code>&lt;user-erasure-handler&gt;</code> module. If one or more plugin modules fail, an error summary of the failing modules is returned.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Erase user information
     */
    async eraseUserRaw(requestParameters: EraseUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestErasedUser>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling eraseUser().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/users/erasure`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Erases personally identifying user data for a deleted user.  References in the application to the original username will be either removed or updated to a new non-identifying username. Refer to the <a href=\"https://confluence.atlassian.com/gdpr/bitbucket-right-to-erasure-949770560.html\">support guide</a> for details about what data is and isn\'t erased.  User erasure can only be performed on a deleted user. If the user has not been deleted first then this endpoint will return a bad request and no erasure will be performed.  Erasing user data is <strong>irreversible</strong> and may lead to a degraded user experience. This method should not be used as part of a standard user deletion and cleanup process.  Plugins can participate in user erasure by defining a <code>&lt;user-erasure-handler&gt;</code> module. If one or more plugin modules fail, an error summary of the failing modules is returned.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Erase user information
     */
    async eraseUser(requestParameters: EraseUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestErasedUser> {
        const response = await this.eraseUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of users that are <em>not</em> members of a specified group. <p>The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Get groups for user
     */
    async findGroupsForUserRaw(requestParameters: FindGroupsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindUsersInGroup200Response>> {
        if (requestParameters['context'] == null) {
            throw new runtime.RequiredError(
                'context',
                'Required parameter "context" was null or undefined when calling findGroupsForUser().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['context'] != null) {
            queryParameters['context'] = requestParameters['context'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/users/more-members`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a list of users that are <em>not</em> members of a specified group. <p>The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Get groups for user
     */
    async findGroupsForUser(requestParameters: FindGroupsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindUsersInGroup200Response> {
        const response = await this.findGroupsForUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of groups the specified user is <em>not</em> a member of. <p>The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Find other groups for user
     */
    async findOtherGroupsForUserRaw(requestParameters: FindOtherGroupsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroups1200Response>> {
        if (requestParameters['context'] == null) {
            throw new runtime.RequiredError(
                'context',
                'Required parameter "context" was null or undefined when calling findOtherGroupsForUser().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['context'] != null) {
            queryParameters['context'] = requestParameters['context'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/users/more-non-members`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a list of groups the specified user is <em>not</em> a member of. <p>The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Find other groups for user
     */
    async findOtherGroupsForUser(requestParameters: FindOtherGroupsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroups1200Response> {
        const response = await this.findOtherGroupsForUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of users that are members of a specified group. <p>The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Get group members
     */
    async findUsersInGroupRaw(requestParameters: FindUsersInGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindUsersInGroup200Response>> {
        if (requestParameters['context'] == null) {
            throw new runtime.RequiredError(
                'context',
                'Required parameter "context" was null or undefined when calling findUsersInGroup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['context'] != null) {
            queryParameters['context'] = requestParameters['context'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/groups/more-members`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a list of users that are members of a specified group. <p>The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Get group members
     */
    async findUsersInGroup(requestParameters: FindUsersInGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindUsersInGroup200Response> {
        const response = await this.findUsersInGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of users that are <em>not</em> members of a specified group. <p>The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Get members not in group
     */
    async findUsersNotInGroupRaw(requestParameters: FindUsersNotInGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindUsersInGroup200Response>> {
        if (requestParameters['context'] == null) {
            throw new runtime.RequiredError(
                'context',
                'Required parameter "context" was null or undefined when calling findUsersNotInGroup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['context'] != null) {
            queryParameters['context'] = requestParameters['context'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/groups/more-non-members`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a list of users that are <em>not</em> members of a specified group. <p>The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Get members not in group
     */
    async findUsersNotInGroup(requestParameters: FindUsersNotInGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindUsersInGroup200Response> {
        const response = await this.findUsersNotInGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of group names.  The authenticated user must have <strong>LICENSED_USER</strong> permission or higher to call this resource.
     * Get group names
     */
    async getGroupsRaw(requestParameters: GetGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroups200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/groups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of group names.  The authenticated user must have <strong>LICENSED_USER</strong> permission or higher to call this resource.
     * Get group names
     */
    async getGroups(requestParameters: GetGroupsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroups200Response> {
        const response = await this.getGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups.   The authenticated user must have <strong>LICENSED_USER</strong> permission or higher to call this resource.
     * Get groups
     */
    async getGroups1Raw(requestParameters: GetGroups1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroups1200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/groups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups.   The authenticated user must have <strong>LICENSED_USER</strong> permission or higher to call this resource.
     * Get groups
     */
    async getGroups1(requestParameters: GetGroups1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroups1200Response> {
        const response = await this.getGroups1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups that have been granted at least one global permission.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get groups with a global permission
     */
    async getGroupsWithAnyPermissionRaw(requestParameters: GetGroupsWithAnyPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroupsWithAnyPermission200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/permissions/groups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups that have been granted at least one global permission.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get groups with a global permission
     */
    async getGroupsWithAnyPermission(requestParameters: GetGroupsWithAnyPermissionRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroupsWithAnyPermission200Response> {
        const response = await this.getGroupsWithAnyPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups that have been granted at least one permission for the specified repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.
     * Get groups with permission to repository
     */
    async getGroupsWithAnyPermission2Raw(requestParameters: GetGroupsWithAnyPermission2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroupsWithAnyPermission200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getGroupsWithAnyPermission2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getGroupsWithAnyPermission2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups that have been granted at least one permission for the specified repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.
     * Get groups with permission to repository
     */
    async getGroupsWithAnyPermission2(requestParameters: GetGroupsWithAnyPermission2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroupsWithAnyPermission200Response> {
        const response = await this.getGroupsWithAnyPermission2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups that have no granted global permissions.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get groups with no global permission
     */
    async getGroupsWithoutAnyPermissionRaw(requestParameters: GetGroupsWithoutAnyPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroups1200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/permissions/groups/none`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups that have no granted global permissions.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get groups with no global permission
     */
    async getGroupsWithoutAnyPermission(requestParameters: GetGroupsWithoutAnyPermissionRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroups1200Response> {
        const response = await this.getGroupsWithoutAnyPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups that have no granted permissions for the specified repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.
     * Get groups without repository permission
     */
    async getGroupsWithoutAnyPermission2Raw(requestParameters: GetGroupsWithoutAnyPermission2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroups1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getGroupsWithoutAnyPermission2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getGroupsWithoutAnyPermission2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/groups/none`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups that have no granted permissions for the specified repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.
     * Get groups without repository permission
     */
    async getGroupsWithoutAnyPermission2(requestParameters: GetGroupsWithoutAnyPermission2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroups1200Response> {
        const response = await this.getGroupsWithoutAnyPermission2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of active directories.    The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Get directories
     */
    async getUserDirectoriesRaw(requestParameters: GetUserDirectoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserDirectory>> {
        const queryParameters: any = {};

        if (requestParameters['includeInactive'] != null) {
            queryParameters['includeInactive'] = requestParameters['includeInactive'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/user-directories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a list of active directories.    The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Get directories
     */
    async getUserDirectories(requestParameters: GetUserDirectoriesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserDirectory> {
        const response = await this.getUserDirectoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of users.    The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Get users
     */
    async getUsers1Raw(requestParameters: GetUsers1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindUsersInGroup200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of users.    The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this resource.
     * Get users
     */
    async getUsers1(requestParameters: GetUsers1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindUsersInGroup200Response> {
        const response = await this.getUsers1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of users that have been granted at least one global permission.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get users with a global permission
     */
    async getUsersWithAnyPermissionRaw(requestParameters: GetUsersWithAnyPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroupsWithAnyPermission200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/permissions/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of users that have been granted at least one global permission.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get users with a global permission
     */
    async getUsersWithAnyPermission(requestParameters: GetUsersWithAnyPermissionRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroupsWithAnyPermission200Response> {
        const response = await this.getUsersWithAnyPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of users that have been granted at least one permission for the specified repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.
     * Get users with permission to repository
     */
    async getUsersWithAnyPermission2Raw(requestParameters: GetUsersWithAnyPermission2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUsersWithAnyPermission1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getUsersWithAnyPermission2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getUsersWithAnyPermission2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of users that have been granted at least one permission for the specified repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.
     * Get users with permission to repository
     */
    async getUsersWithAnyPermission2(requestParameters: GetUsersWithAnyPermission2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUsersWithAnyPermission1200Response> {
        const response = await this.getUsersWithAnyPermission2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of users that have no granted global permissions.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get users with no global permission
     */
    async getUsersWithoutAnyPermissionRaw(requestParameters: GetUsersWithoutAnyPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUsersWithoutAnyPermission200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/permissions/users/none`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of users that have no granted global permissions.   The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get users with no global permission
     */
    async getUsersWithoutAnyPermission(requestParameters: GetUsersWithoutAnyPermissionRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUsersWithoutAnyPermission200Response> {
        const response = await this.getUsersWithoutAnyPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of <i>licensed</i> users that have no granted permissions for the specified repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.
     * Get users without repository permission
     */
    async getUsersWithoutPermission1Raw(requestParameters: GetUsersWithoutPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUsersWithoutAnyPermission200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getUsersWithoutPermission1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getUsersWithoutPermission1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/users/none`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of <i>licensed</i> users that have no granted permissions for the specified repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.
     * Get users without repository permission
     */
    async getUsersWithoutPermission1(requestParameters: GetUsersWithoutPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUsersWithoutAnyPermission200Response> {
        const response = await this.getUsersWithoutPermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a user from a group. This is very similar to <code>groups/remove-user</code>, but with the <em>context</em> and <em>itemName</em> attributes of the supplied request entity reversed. On the face of it this may appear redundant, but it facilitates a specific UI component in the application.  In the request entity, the <em>context</em> attribute is the user and the <em>itemName</em> is the group.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Remove user from group
     */
    async removeGroupFromUserRaw(requestParameters: RemoveGroupFromUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/users/remove-group`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['groupPickerContext'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a user from a group. This is very similar to <code>groups/remove-user</code>, but with the <em>context</em> and <em>itemName</em> attributes of the supplied request entity reversed. On the face of it this may appear redundant, but it facilitates a specific UI component in the application.  In the request entity, the <em>context</em> attribute is the user and the <em>itemName</em> is the group.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Remove user from group
     */
    async removeGroupFromUser(requestParameters: RemoveGroupFromUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeGroupFromUserRaw(requestParameters, initOverrides);
    }

    /**
     * <strong>Deprecated since 2.10</strong>. Use /rest/users/remove-groups instead.  Remove a user from a group.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.  In the request entity, the <em>context</em> attribute is the group and the <em>itemName</em> is the user.
     * Remove user from group
     * @deprecated
     */
    async removeUserFromGroupRaw(requestParameters: RemoveUserFromGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/groups/remove-user`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['userPickerContext'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * <strong>Deprecated since 2.10</strong>. Use /rest/users/remove-groups instead.  Remove a user from a group.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.  In the request entity, the <em>context</em> attribute is the group and the <em>itemName</em> is the user.
     * Remove user from group
     * @deprecated
     */
    async removeUserFromGroup(requestParameters: RemoveUserFromGroupRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeUserFromGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Rename a user.   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Rename user
     */
    async renameUserRaw(requestParameters: RenameUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDetailedUser>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/users/rename`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['userRename'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Rename a user.   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Rename user
     */
    async renameUser(requestParameters: RenameUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDetailedUser> {
        const response = await this.renameUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revoke all permissions for the specified repository for the given groups and users.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified repository or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permission if their own permission would be revoked as a result, nor may they revoke their own permission unless they have a global permission that already implies that permission.
     * Revoke all repository permissions for users and groups
     */
    async revokePermissions1Raw(requestParameters: RevokePermissions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokePermissions1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling revokePermissions1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        if (requestParameters['group'] != null) {
            queryParameters['group'] = requestParameters['group'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all permissions for the specified repository for the given groups and users.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified repository or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permission if their own permission would be revoked as a result, nor may they revoke their own permission unless they have a global permission that already implies that permission.
     * Revoke all repository permissions for users and groups
     */
    async revokePermissions1(requestParameters: RevokePermissions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissions1Raw(requestParameters, initOverrides);
    }

    /**
     * Revoke all global permissions for a group.    The authenticated user must have:   - <strong>ADMIN</strong> permission or higher; and - greater or equal permissions than the current permission level of the group (a user may not demote the     permission level of a group with higher permissions than them)   to call this resource. In addition, a user may not revoke a group\'s permissions if their own permission level would be reduced as a result.
     * Revoke all global permissions for group
     */
    async revokePermissionsForGroupRaw(requestParameters: RevokePermissionsForGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling revokePermissionsForGroup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/permissions/groups`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all global permissions for a group.    The authenticated user must have:   - <strong>ADMIN</strong> permission or higher; and - greater or equal permissions than the current permission level of the group (a user may not demote the     permission level of a group with higher permissions than them)   to call this resource. In addition, a user may not revoke a group\'s permissions if their own permission level would be reduced as a result.
     * Revoke all global permissions for group
     */
    async revokePermissionsForGroup(requestParameters: RevokePermissionsForGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsForGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Revoke all permissions for the specified repository for a group.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.  In addition, a user may not revoke a group\'s permissions if it will reduce their own permission level.
     * Revoke group repository permission
     */
    async revokePermissionsForGroup2Raw(requestParameters: RevokePermissionsForGroup2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokePermissionsForGroup2().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling revokePermissionsForGroup2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling revokePermissionsForGroup2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all permissions for the specified repository for a group.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.  In addition, a user may not revoke a group\'s permissions if it will reduce their own permission level.
     * Revoke group repository permission
     */
    async revokePermissionsForGroup2(requestParameters: RevokePermissionsForGroup2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsForGroup2Raw(requestParameters, initOverrides);
    }

    /**
     * Revoke all global permissions for a user.   The authenticated user must have:   - <strong>ADMIN</strong> permission or higher; and - greater or equal permissions than the current permission level of the user (a user may not demote the     permission level of a user with higher permissions than them)   to call this resource. In addition, a user may not demote their own permission level.
     * Revoke all global permissions for user
     */
    async revokePermissionsForUserRaw(requestParameters: RevokePermissionsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling revokePermissionsForUser().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/permissions/users`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all global permissions for a user.   The authenticated user must have:   - <strong>ADMIN</strong> permission or higher; and - greater or equal permissions than the current permission level of the user (a user may not demote the     permission level of a user with higher permissions than them)   to call this resource. In addition, a user may not demote their own permission level.
     * Revoke all global permissions for user
     */
    async revokePermissionsForUser(requestParameters: RevokePermissionsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsForUserRaw(requestParameters, initOverrides);
    }

    /**
     * Revoke all permissions for the specified repository for a user.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.  In addition, a user may not revoke their own repository permissions if they do not have a higher project or global permission.
     * Revoke user repository permission
     */
    async revokePermissionsForUser2Raw(requestParameters: RevokePermissionsForUser2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokePermissionsForUser2().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling revokePermissionsForUser2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling revokePermissionsForUser2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all permissions for the specified repository for a user.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource.  In addition, a user may not revoke their own repository permissions if they do not have a higher project or global permission.
     * Revoke user repository permission
     */
    async revokePermissionsForUser2(requestParameters: RevokePermissionsForUser2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsForUser2Raw(requestParameters, initOverrides);
    }

    /**
     * Search direct and implied permissions of users and groups. This endpoint returns a superset of the results returned by the /users and /groups endpoints because it allows filtering by project and global permissions too.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project/global permission to call this resource.
     * Search repository permissions
     */
    async searchPermissions1Raw(requestParameters: SearchPermissions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling searchPermissions1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling searchPermissions1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['filterText'] != null) {
            queryParameters['filterText'] = requestParameters['filterText'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/search`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Search direct and implied permissions of users and groups. This endpoint returns a superset of the results returned by the /users and /groups endpoints because it allows filtering by project and global permissions too.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project/global permission to call this resource.
     * Search repository permissions
     */
    async searchPermissions1(requestParameters: SearchPermissions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.searchPermissions1Raw(requestParameters, initOverrides);
    }

    /**
     * Promote or demote a group\'s permission level for the specified repository. Available repository permissions are:  - REPO_READ - REPO_WRITE - REPO_ADMIN   See the <a href=\"https://confluence.atlassian.com/display/BitbucketServer/Using+repository+permissions\">Bitbucket Data Center documentation</a> for a detailed explanation of what each permission entails.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource. In addition, a user may not demote a group\'s permission level if their own permission level would be reduced as a result.
     * Update group repository permission
     */
    async setPermissionForGroupRaw(requestParameters: SetPermissionForGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setPermissionForGroup().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling setPermissionForGroup().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling setPermissionForGroup().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setPermissionForGroup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote or demote a group\'s permission level for the specified repository. Available repository permissions are:  - REPO_READ - REPO_WRITE - REPO_ADMIN   See the <a href=\"https://confluence.atlassian.com/display/BitbucketServer/Using+repository+permissions\">Bitbucket Data Center documentation</a> for a detailed explanation of what each permission entails.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource. In addition, a user may not demote a group\'s permission level if their own permission level would be reduced as a result.
     * Update group repository permission
     */
    async setPermissionForGroup(requestParameters: SetPermissionForGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPermissionForGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Promote or demote a group\'s global permission level. Available global permissions are:   - LICENSED_USER - PROJECT_CREATE - ADMIN - SYS_ADMIN  See the <a href=\"https://confluence.atlassian.com/display/BitbucketServer/Global+permissions\">Bitbucket Data Center documentation</a> for a detailed explanation of what each permission entails.   The authenticated user must have:   - <strong>ADMIN</strong> permission or higher; and - the permission they are attempting to grant or higher; and - greater or equal permissions than the current permission level of the group (a user may not demote the     permission level of a group with higher permissions than them)   to call this resource. In addition, a user may not demote a group\'s permission level if their own permission level would be reduced as a result.
     * Update global permission for group
     */
    async setPermissionForGroupsRaw(requestParameters: SetPermissionForGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling setPermissionForGroups().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling setPermissionForGroups().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/permissions/groups`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote or demote a group\'s global permission level. Available global permissions are:   - LICENSED_USER - PROJECT_CREATE - ADMIN - SYS_ADMIN  See the <a href=\"https://confluence.atlassian.com/display/BitbucketServer/Global+permissions\">Bitbucket Data Center documentation</a> for a detailed explanation of what each permission entails.   The authenticated user must have:   - <strong>ADMIN</strong> permission or higher; and - the permission they are attempting to grant or higher; and - greater or equal permissions than the current permission level of the group (a user may not demote the     permission level of a group with higher permissions than them)   to call this resource. In addition, a user may not demote a group\'s permission level if their own permission level would be reduced as a result.
     * Update global permission for group
     */
    async setPermissionForGroups(requestParameters: SetPermissionForGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPermissionForGroupsRaw(requestParameters, initOverrides);
    }

    /**
     * Promote or demote a user\'s permission level for the specified repository. Available repository permissions are:  - REPO_READ</li>- REPO_WRITE</li>- REPO_ADMIN</li></ul>See the <a href=\"https://confluence.atlassian.com/display/BitbucketServer/Using+repository+permissions\">Bitbucket Data Center documentation</a> for a detailed explanation of what each permission entails.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource. In addition, a user may not reduce their own permission level unless they have a project or global permission that already implies that permission.
     * Update user repository permission
     */
    async setPermissionForUserRaw(requestParameters: SetPermissionForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setPermissionForUser().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling setPermissionForUser().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling setPermissionForUser().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setPermissionForUser().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote or demote a user\'s permission level for the specified repository. Available repository permissions are:  - REPO_READ</li>- REPO_WRITE</li>- REPO_ADMIN</li></ul>See the <a href=\"https://confluence.atlassian.com/display/BitbucketServer/Using+repository+permissions\">Bitbucket Data Center documentation</a> for a detailed explanation of what each permission entails.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository or a higher project or global permission to call this resource. In addition, a user may not reduce their own permission level unless they have a project or global permission that already implies that permission.
     * Update user repository permission
     */
    async setPermissionForUser(requestParameters: SetPermissionForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPermissionForUserRaw(requestParameters, initOverrides);
    }

    /**
     * Promote or demote the global permission level of a user. Available global permissions are:   - LICENSED_USER - PROJECT_CREATE - ADMIN - SYS_ADMIN   See the <a href=\"https://confluence.atlassian.com/display/BitbucketServer/Global+permissions\">Bitbucket Data Center documentation</a> for a detailed explanation of what each permission entails.   The authenticated user must have:   - <strong>ADMIN</strong> permission or higher; and - the permission they are attempting to grant; and - greater or equal permissions than the current permission level of the user (a user may not demote the     permission level of a user with higher permissions than them)   to call this resource. In addition, a user may not demote their own permission level.
     * Update global permission for user
     */
    async setPermissionForUsersRaw(requestParameters: SetPermissionForUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling setPermissionForUsers().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling setPermissionForUsers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/permissions/users`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote or demote the global permission level of a user. Available global permissions are:   - LICENSED_USER - PROJECT_CREATE - ADMIN - SYS_ADMIN   See the <a href=\"https://confluence.atlassian.com/display/BitbucketServer/Global+permissions\">Bitbucket Data Center documentation</a> for a detailed explanation of what each permission entails.   The authenticated user must have:   - <strong>ADMIN</strong> permission or higher; and - the permission they are attempting to grant; and - greater or equal permissions than the current permission level of the user (a user may not demote the     permission level of a user with higher permissions than them)   to call this resource. In addition, a user may not demote their own permission level.
     * Update global permission for user
     */
    async setPermissionForUsers(requestParameters: SetPermissionForUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPermissionForUsersRaw(requestParameters, initOverrides);
    }

    /**
     * Update a user\'s details.   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Update user details
     */
    async updateUserDetailsRaw(requestParameters: UpdateUserDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDetailedUser>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/users`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['userUpdate'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update a user\'s details.   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Update user details
     */
    async updateUserDetails(requestParameters: UpdateUserDetailsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDetailedUser> {
        const response = await this.updateUserDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a user\'s password.   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource, and may not update the password of a user with greater permissions than themselves.
     * Set password for user
     */
    async updateUserPasswordRaw(requestParameters: UpdateUserPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/users/credentials`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['adminPasswordUpdate'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update a user\'s password.   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource, and may not update the password of a user with greater permissions than themselves.
     * Set password for user
     */
    async updateUserPassword(requestParameters: UpdateUserPasswordRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateUserPasswordRaw(requestParameters, initOverrides);
    }

    /**
     * Validate if a user can be erased.  A username is only valid for erasure if it exists as the username of a deleted user. This endpoint will return an appropriate error response if the supplied username is invalid for erasure.  This endpoint does <strong>not</strong> perform the actual user erasure, and will not modify the application in any way.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Check user removal
     */
    async validateErasableRaw(requestParameters: ValidateErasableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling validateErasable().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/users/erasure`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Validate if a user can be erased.  A username is only valid for erasure if it exists as the username of a deleted user. This endpoint will return an appropriate error response if the supplied username is invalid for erasure.  This endpoint does <strong>not</strong> perform the actual user erasure, and will not modify the application in any way.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Check user removal
     */
    async validateErasable(requestParameters: ValidateErasableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.validateErasableRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const SetPermissionForGroupPermissionEnum = {
    Read: 'REPO_READ',
    Write: 'REPO_WRITE',
    Admin: 'REPO_ADMIN'
} as const;
export type SetPermissionForGroupPermissionEnum = typeof SetPermissionForGroupPermissionEnum[keyof typeof SetPermissionForGroupPermissionEnum];
/**
 * @export
 */
export const SetPermissionForGroupsPermissionEnum = {
    LicensedUser: 'LICENSED_USER',
    ProjectCreate: 'PROJECT_CREATE',
    Admin: 'ADMIN',
    SysAdmin: 'SYS_ADMIN'
} as const;
export type SetPermissionForGroupsPermissionEnum = typeof SetPermissionForGroupsPermissionEnum[keyof typeof SetPermissionForGroupsPermissionEnum];
/**
 * @export
 */
export const SetPermissionForUserPermissionEnum = {
    Read: 'REPO_READ',
    Write: 'REPO_WRITE',
    Admin: 'REPO_ADMIN'
} as const;
export type SetPermissionForUserPermissionEnum = typeof SetPermissionForUserPermissionEnum[keyof typeof SetPermissionForUserPermissionEnum];
/**
 * @export
 */
export const SetPermissionForUsersPermissionEnum = {
    LicensedUser: 'LICENSED_USER',
    ProjectCreate: 'PROJECT_CREATE',
    Admin: 'ADMIN',
    SysAdmin: 'SYS_ADMIN'
} as const;
export type SetPermissionForUsersPermissionEnum = typeof SetPermissionForUsersPermissionEnum[keyof typeof SetPermissionForUsersPermissionEnum];
