/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  EnrichedRepository,
  GetAllAccessTokens401Response,
  GetAllReposForProject200Response,
  ListMirrors200Response,
  ListRequests200Response,
  RestAnalyticsSettings,
  RestApplicationUserWithPermissions,
  RestAuthenticationRequest,
  RestMirrorServer,
  RestMirrorUpgradeRequest,
  RestMirroredRepositoryDescriptor,
  RestMirroringRequest,
  RestProject,
  RestRepositoryMirrorEvent,
} from '../models/index';

interface AcceptRequest {
    mirroringRequestId: string;
}

interface AuthenticateRequest {
    restAuthenticationRequest?: RestAuthenticationRequest;
}

interface DeleteMirroringRequestRequest {
    mirroringRequestId: string;
}

interface GetAllContentHashesRequest {
    includeDefaultBranch?: GetAllContentHashesIncludeDefaultBranchEnum;
}

interface GetAllReposForProjectRequest {
    projectId: string;
    includeDefaultBranch?: GetAllReposForProjectIncludeDefaultBranchEnum;
    start?: number;
    limit?: number;
}

interface GetContentHashByIdRequest {
    repoId: string;
    includeDefaultBranch?: boolean;
}

interface GetMirrorRequest {
    mirrorId: string;
}

interface GetMirroringRequestRequest {
    mirroringRequestId: string;
}

interface GetProjectByIdRequest {
    projectId: string;
}

interface GetRepositoryMirrorsRequest {
    repoId: string;
    preAuthorized?: boolean;
}

interface ListMirrorsRequest {
    start?: number;
    limit?: number;
}

interface ListRequestsRequest {
    state?: ListRequestsStateEnum;
    start?: number;
    limit?: number;
}

interface PublishEventRequest {
    mirrorId: string;
    restRepositoryMirrorEvent?: RestRepositoryMirrorEvent;
}

interface RegisterRequest {
    restMirroringRequest?: Omit<RestMirroringRequest, 'id'>;
}

interface RejectRequest {
    mirroringRequestId: string;
}

interface RemoveRequest {
    mirrorId: string;
}

interface SetPreferredMirrorIdRequest {
    body?: string;
}

interface UpgradeRequest {
    mirrorId: string;
    restMirrorUpgradeRequest?: RestMirrorUpgradeRequest;
}

/**
 * 
 */
export class MirroringUpstreamApi extends runtime.BaseAPI {

    /**
     * Accepts a mirroring request
     * Accept a mirroring request
     */
    async acceptRaw(requestParameters: AcceptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirrorServer>> {
        if (requestParameters['mirroringRequestId'] == null) {
            throw new runtime.RequiredError(
                'mirroringRequestId',
                'Required parameter "mirroringRequestId" was null or undefined when calling accept().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/requests/{mirroringRequestId}/accept`.replace(`{${"mirroringRequestId"}}`, encodeURIComponent(String(requestParameters['mirroringRequestId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Accepts a mirroring request
     * Accept a mirroring request
     */
    async accept(requestParameters: AcceptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirrorServer> {
        const response = await this.acceptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the analytics settings from the mirroring upstream
     * Get analytics settings from upstream
     */
    async analyticsSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAnalyticsSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/analyticsSettings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the analytics settings from the mirroring upstream
     * Get analytics settings from upstream
     */
    async analyticsSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAnalyticsSettings> {
        const response = await this.analyticsSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Authenticates on behalf of a user. Used by mirrors to check the credentials supplied to them by users. If successful a user and their effective permissions are returned as follows -  * For SSH credentials - all the effective user permissions are returned. * For all other credentials - the highest global permission is returned along with highest repository permission if repository ID is also provided in the request.  Currently only username/password, bearer token and SSH credentials are supported.
     * Authenticate on behalf of a user
     */
    async authenticateRaw(requestParameters: AuthenticateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestApplicationUserWithPermissions>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mirroring/latest/authenticate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAuthenticationRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Authenticates on behalf of a user. Used by mirrors to check the credentials supplied to them by users. If successful a user and their effective permissions are returned as follows -  * For SSH credentials - all the effective user permissions are returned. * For all other credentials - the highest global permission is returned along with highest repository permission if repository ID is also provided in the request.  Currently only username/password, bearer token and SSH credentials are supported.
     * Authenticate on behalf of a user
     */
    async authenticate(requestParameters: AuthenticateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestApplicationUserWithPermissions> {
        const response = await this.authenticateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a mirroring request
     * Delete a mirroring request
     */
    async deleteMirroringRequestRaw(requestParameters: DeleteMirroringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['mirroringRequestId'] == null) {
            throw new runtime.RequiredError(
                'mirroringRequestId',
                'Required parameter "mirroringRequestId" was null or undefined when calling deleteMirroringRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/requests/{mirroringRequestId}`.replace(`{${"mirroringRequestId"}}`, encodeURIComponent(String(requestParameters['mirroringRequestId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a mirroring request
     * Delete a mirroring request
     */
    async deleteMirroringRequest(requestParameters: DeleteMirroringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMirroringRequestRaw(requestParameters, initOverrides);
    }

    /**
     * Removes the current user\'s preferred mirror
     * Remove preferred mirror
     */
    async deletePreferredMirrorIdRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/account/settings/preferred-mirror`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes the current user\'s preferred mirror
     * Remove preferred mirror
     */
    async deletePreferredMirrorId(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePreferredMirrorIdRaw(initOverrides);
    }

    /**
     * Returns a page of repositories enriched with a content hash and default branch
     * Get content hashes for repositories
     */
    async getAllContentHashesRaw(requestParameters: GetAllContentHashesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnrichedRepository>> {
        const queryParameters: any = {};

        if (requestParameters['includeDefaultBranch'] != null) {
            queryParameters['includeDefaultBranch'] = requestParameters['includeDefaultBranch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/repos`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a page of repositories enriched with a content hash and default branch
     * Get content hashes for repositories
     */
    async getAllContentHashes(requestParameters: GetAllContentHashesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnrichedRepository> {
        const response = await this.getAllContentHashesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a page of repositories for a given project, enriched with a content hash
     * Get hashes for repositories in project
     */
    async getAllReposForProjectRaw(requestParameters: GetAllReposForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllReposForProject200Response>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getAllReposForProject().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['includeDefaultBranch'] != null) {
            queryParameters['includeDefaultBranch'] = requestParameters['includeDefaultBranch'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/projects/{projectId}/repos`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a page of repositories for a given project, enriched with a content hash
     * Get hashes for repositories in project
     */
    async getAllReposForProject(requestParameters: GetAllReposForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllReposForProject200Response> {
        const response = await this.getAllReposForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a repository enriched with a content hash and default branch
     * Get content hash for a repository
     */
    async getContentHashByIdRaw(requestParameters: GetContentHashByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnrichedRepository>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling getContentHashById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['includeDefaultBranch'] != null) {
            queryParameters['includeDefaultBranch'] = requestParameters['includeDefaultBranch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/repos/{repoId}`.replace(`{${"repoId"}}`, encodeURIComponent(String(requestParameters['repoId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a repository enriched with a content hash and default branch
     * Get content hash for a repository
     */
    async getContentHashById(requestParameters: GetContentHashByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnrichedRepository> {
        const response = await this.getContentHashByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the mirror specified by a mirror ID
     * Get mirror by ID
     */
    async getMirrorRaw(requestParameters: GetMirrorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirrorServer>> {
        if (requestParameters['mirrorId'] == null) {
            throw new runtime.RequiredError(
                'mirrorId',
                'Required parameter "mirrorId" was null or undefined when calling getMirror().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/mirrorServers/{mirrorId}`.replace(`{${"mirrorId"}}`, encodeURIComponent(String(requestParameters['mirrorId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the mirror specified by a mirror ID
     * Get mirror by ID
     */
    async getMirror(requestParameters: GetMirrorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirrorServer> {
        const response = await this.getMirrorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a mirroring request
     * Get a mirroring request
     */
    async getMirroringRequestRaw(requestParameters: GetMirroringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirroringRequest>> {
        if (requestParameters['mirroringRequestId'] == null) {
            throw new runtime.RequiredError(
                'mirroringRequestId',
                'Required parameter "mirroringRequestId" was null or undefined when calling getMirroringRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/requests/{mirroringRequestId}`.replace(`{${"mirroringRequestId"}}`, encodeURIComponent(String(requestParameters['mirroringRequestId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a mirroring request
     * Get a mirroring request
     */
    async getMirroringRequest(requestParameters: GetMirroringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirroringRequest> {
        const response = await this.getMirroringRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the current user\'s preferred mirror server
     * Get preferred mirror
     */
    async getPreferredMirrorIdRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirrorServer>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/account/settings/preferred-mirror`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the current user\'s preferred mirror server
     * Get preferred mirror
     */
    async getPreferredMirrorId(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirrorServer> {
        const response = await this.getPreferredMirrorIdRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the requested project using its primary key ID.<br> Since 6.7
     * Get project
     */
    async getProjectByIdRaw(requestParameters: GetProjectByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getProjectById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/projects/{projectId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the requested project using its primary key ID.<br> Since 6.7
     * Get project
     */
    async getProjectById(requestParameters: GetProjectByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.getProjectByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a page of mirrors for a repository. This resource will return <strong>all mirrors</strong> along with authorized links to the mirror\'s repository REST resource. To determine if a repository is available on the mirror, the returned URL needs to be called.
     * Get mirrors for repository
     */
    async getRepositoryMirrorsRaw(requestParameters: GetRepositoryMirrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirroredRepositoryDescriptor>> {
        if (requestParameters['repoId'] == null) {
            throw new runtime.RequiredError(
                'repoId',
                'Required parameter "repoId" was null or undefined when calling getRepositoryMirrors().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['preAuthorized'] != null) {
            queryParameters['preAuthorized'] = requestParameters['preAuthorized'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/repos/{repoId}/mirrors`.replace(`{${"repoId"}}`, encodeURIComponent(String(requestParameters['repoId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a page of mirrors for a repository. This resource will return <strong>all mirrors</strong> along with authorized links to the mirror\'s repository REST resource. To determine if a repository is available on the mirror, the returned URL needs to be called.
     * Get mirrors for repository
     */
    async getRepositoryMirrors(requestParameters: GetRepositoryMirrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirroredRepositoryDescriptor> {
        const response = await this.getRepositoryMirrorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of mirrors
     * Get all mirrors
     */
    async listMirrorsRaw(requestParameters: ListMirrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListMirrors200Response>> {
        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/mirrorServers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a list of mirrors
     * Get all mirrors
     */
    async listMirrors(requestParameters: ListMirrorsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListMirrors200Response> {
        const response = await this.listMirrorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a mirroring request
     * Get mirroring requests
     */
    async listRequestsRaw(requestParameters: ListRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRequests200Response>> {
        const queryParameters: any = {};

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/requests`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a mirroring request
     * Get mirroring requests
     */
    async listRequests(requestParameters: ListRequestsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRequests200Response> {
        const response = await this.listRequestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Publishes a RepositoryMirrorEvent on the event queue.
     * Publish RepositoryMirrorEvent
     */
    async publishEventRaw(requestParameters: PublishEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['mirrorId'] == null) {
            throw new runtime.RequiredError(
                'mirrorId',
                'Required parameter "mirrorId" was null or undefined when calling publishEvent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mirroring/latest/mirrorServers/{mirrorId}/events`.replace(`{${"mirrorId"}}`, encodeURIComponent(String(requestParameters['mirrorId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepositoryMirrorEvent'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Publishes a RepositoryMirrorEvent on the event queue.
     * Publish RepositoryMirrorEvent
     */
    async publishEvent(requestParameters: PublishEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.publishEventRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new mirroring request
     * Create a mirroring request
     */
    async registerRaw(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirroringRequest>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mirroring/latest/requests`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restMirroringRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new mirroring request
     * Create a mirroring request
     */
    async register(requestParameters: RegisterRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirroringRequest> {
        const response = await this.registerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Rejects a mirroring request
     * Reject a mirroring request
     */
    async rejectRaw(requestParameters: RejectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirrorServer>> {
        if (requestParameters['mirroringRequestId'] == null) {
            throw new runtime.RequiredError(
                'mirroringRequestId',
                'Required parameter "mirroringRequestId" was null or undefined when calling reject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/requests/{mirroringRequestId}/reject`.replace(`{${"mirroringRequestId"}}`, encodeURIComponent(String(requestParameters['mirroringRequestId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Rejects a mirroring request
     * Reject a mirroring request
     */
    async reject(requestParameters: RejectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirrorServer> {
        const response = await this.rejectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes a mirror, disabling all access and notifications for the mirror server in question
     * Delete mirror by ID
     */
    async removeRaw(requestParameters: RemoveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['mirrorId'] == null) {
            throw new runtime.RequiredError(
                'mirrorId',
                'Required parameter "mirrorId" was null or undefined when calling remove().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/mirrorServers/{mirrorId}`.replace(`{${"mirrorId"}}`, encodeURIComponent(String(requestParameters['mirrorId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes a mirror, disabling all access and notifications for the mirror server in question
     * Delete mirror by ID
     */
    async remove(requestParameters: RemoveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeRaw(requestParameters, initOverrides);
    }

    /**
     * Sets the mirror specified by a mirror ID as the current user\'s preferred mirror
     * Set preferred mirror
     */
    async setPreferredMirrorIdRaw(requestParameters: SetPreferredMirrorIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mirroring/latest/account/settings/preferred-mirror`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Sets the mirror specified by a mirror ID as the current user\'s preferred mirror
     * Set preferred mirror
     */
    async setPreferredMirrorId(requestParameters: SetPreferredMirrorIdRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPreferredMirrorIdRaw(requestParameters, initOverrides);
    }

    /**
     * Upgrades the mirror server in question with the provided details.This endpoint can only be called by the mirror instance or system administrators<br>Since 5.8
     * Upgrade mirror server
     */
    async upgradeRaw(requestParameters: UpgradeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirrorServer>> {
        if (requestParameters['mirrorId'] == null) {
            throw new runtime.RequiredError(
                'mirrorId',
                'Required parameter "mirrorId" was null or undefined when calling upgrade().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mirroring/latest/mirrorServers/{mirrorId}`.replace(`{${"mirrorId"}}`, encodeURIComponent(String(requestParameters['mirrorId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restMirrorUpgradeRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Upgrades the mirror server in question with the provided details.This endpoint can only be called by the mirror instance or system administrators<br>Since 5.8
     * Upgrade mirror server
     */
    async upgrade(requestParameters: UpgradeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirrorServer> {
        const response = await this.upgradeRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAllContentHashesIncludeDefaultBranchEnum = {
    True: 'true',
    False: 'false'
} as const;
export type GetAllContentHashesIncludeDefaultBranchEnum = typeof GetAllContentHashesIncludeDefaultBranchEnum[keyof typeof GetAllContentHashesIncludeDefaultBranchEnum];
/**
 * @export
 */
export const GetAllReposForProjectIncludeDefaultBranchEnum = {
    True: 'true',
    False: 'false'
} as const;
export type GetAllReposForProjectIncludeDefaultBranchEnum = typeof GetAllReposForProjectIncludeDefaultBranchEnum[keyof typeof GetAllReposForProjectIncludeDefaultBranchEnum];
/**
 * @export
 */
export const ListRequestsStateEnum = {
    Pending: 'PENDING',
    Accepted: 'ACCEPTED',
    Rejected: 'REJECTED'
} as const;
export type ListRequestsStateEnum = typeof ListRequestsStateEnum[keyof typeof ListRequestsStateEnum];
