/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddSshKeyRequest,
  AuthenticationEntity,
  AuthenticationResponse,
  BasicAuthConfigEntity,
  CaptchaDataEntity,
  ConversationDTO,
  CredentialsCheckFailedDTO,
  ElevationMethodRestDTO,
  ErrorEntity,
  GetAllAccessTokens200Response,
  GetAllAccessTokens401Response,
  GetForRepository1200Response,
  GetIdps200Response,
  GetLoginOptions200Response,
  GetSshKeys200Response,
  IdpConfigEntity,
  JitUserEntity,
  NextLoginStepDTO,
  RestAccessToken,
  RestAccessTokenRequest,
  RestRawAccessToken,
  RestSshAccessKey,
  RestSshKey,
  RestSshSettings,
  RevokeManyRequest,
  SsoConfigEntity,
  SsoManagementStatusDTO,
  StatusDTO,
  TotpCodeVerificationDTO,
  TotpElevationRestDTO,
  TotpRecoveryCodeAuthenticationDTO,
  TotpRecoveryCodeDTO,
  TotpUserEnrollmentDTO,
} from '../models/index';

interface AddForProjectRequest {
    projectKey: string;
    restSshAccessKey?: RestSshAccessKey;
}

interface AddForRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
    restSshAccessKey?: RestSshAccessKey;
}

interface AddIdpRequest {
    idpConfigEntity?: IdpConfigEntity;
}

interface AddSshKeyOperationRequest {
    user?: Omit<RestSshKey, 'createdDate'|'fingerprint'|'id'|'lastAuthenticated'|'warning'>;
    addSshKeyRequest?: Omit<AddSshKeyRequest, 'createdDate'|'fingerprint'|'id'|'lastAuthenticated'|'warning'>;
}

interface AuthenticateRequest {
    authenticationEntity?: AuthenticationEntity;
}

interface AuthenticateWithRecoveryCodeRequest {
    totpRecoveryCodeAuthenticationDTO?: TotpRecoveryCodeAuthenticationDTO;
}

interface CompleteAuthenticationChangeRequest {
    totpCodeVerificationDTO?: TotpCodeVerificationDTO;
}

interface CompleteEnforcedEnrollmentRequest {
    totpCodeVerificationDTO?: TotpCodeVerificationDTO;
}

interface CompleteVoluntaryEnrollmentRequest {
    totpCodeVerificationDTO?: TotpCodeVerificationDTO;
}

interface CreateAccessTokenRequest {
    projectKey: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface CreateAccessToken1Request {
    projectKey: string;
    repositorySlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface CreateAccessToken2Request {
    userSlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface DeleteByIdRequest {
    projectKey: string;
    tokenId: string;
}

interface DeleteById1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
}

interface DeleteById2Request {
    tokenId: string;
    userSlug: string;
}

interface DeleteSshKeyRequest {
    keyId: string;
}

interface DeleteSshKeysRequest {
    userName?: string;
    user?: string;
}

interface ElevatePermissionsWithPasswordRequest {
    actionType?: ElevatePermissionsWithPasswordActionTypeEnum;
    totpElevationRestDTO?: TotpElevationRestDTO;
}

interface ElevatePermissionsWithRecoveryCodeRequest {
    actionType?: ElevatePermissionsWithRecoveryCodeActionTypeEnum;
    totpRecoveryCodeDTO?: TotpRecoveryCodeDTO;
}

interface ElevatePermissionsWithTotpRequest {
    actionType?: ElevatePermissionsWithTotpActionTypeEnum;
    totpElevationRestDTO?: TotpElevationRestDTO;
}

interface GetAllAccessTokensRequest {
    projectKey: string;
    start?: number;
    limit?: number;
}

interface GetAllAccessTokens1Request {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetAllAccessTokens2Request {
    userSlug: string;
    start?: number;
    limit?: number;
}

interface GetByIdRequest {
    projectKey: string;
    tokenId: string;
}

interface GetById1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
}

interface GetById2Request {
    tokenId: string;
    userSlug: string;
}

interface GetElevatedPermissionStatusRequest {
    actionType?: GetElevatedPermissionStatusActionTypeEnum;
}

interface GetForProjectRequest {
    projectKey: string;
    keyId: string;
}

interface GetForProjectsRequest {
    keyId: number;
}

interface GetForRepositoriesRequest {
    keyId: string;
    withRestrictions?: string;
}

interface GetForRepositoryRequest {
    projectKey: string;
    keyId: string;
    repositorySlug: string;
}

interface GetForRepository1Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    effective?: string;
    minimumPermission?: string;
    permission?: string;
    start?: number;
    limit?: number;
}

interface GetIdpRequest {
    id: string;
}

interface GetIdpsRequest {
    start?: number;
    limit?: number;
}

interface GetLoginOptionsRequest {
    start?: number;
    limit?: number;
}

interface GetSshKeyRequest {
    keyId: string;
}

interface GetSshKeysRequest {
    userName?: string;
    user?: string;
    start?: number;
    limit?: number;
}

interface GetSshKeysForProjectRequest {
    projectKey: string;
    filter?: string;
    permission?: string;
    start?: number;
    limit?: number;
}

interface PutRequest {
    basicAuthConfigEntity?: BasicAuthConfigEntity;
}

interface RemoveIdpRequest {
    id: string;
}

interface RevokeForProjectRequest {
    projectKey: string;
    keyId: string;
}

interface RevokeForRepositoryRequest {
    projectKey: string;
    keyId: string;
    repositorySlug: string;
}

interface RevokeManyOperationRequest {
    keyId: string;
    revokeManyRequest?: RevokeManyRequest;
}

interface StartEnforcedEnrollmentRequest {
    conversationDTO?: ConversationDTO;
}

interface UnenrollUserRequest {
    userName: string;
    totpElevationRestDTO?: TotpElevationRestDTO;
}

interface UpdateAccessTokenRequest {
    projectKey: string;
    tokenId: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface UpdateAccessToken1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface UpdateAccessToken2Request {
    tokenId: string;
    userSlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface UpdateConfigRequest {
    ssoConfigEntity?: SsoConfigEntity;
}

interface UpdateIdpRequest {
    id: string;
    idpConfigEntity?: IdpConfigEntity;
}

interface UpdatePermissionRequest {
    projectKey: string;
    keyId: string;
    permission: string;
}

interface UpdatePermission1Request {
    projectKey: string;
    keyId: string;
    permission: string;
    repositorySlug: string;
}

interface VerifyCodeRequest {
    totpCodeVerificationDTO?: TotpCodeVerificationDTO;
}

/**
 * 
 */
export class AuthenticationApi extends runtime.BaseAPI {

    /**
     * Register a new SSH key and grants access to the project identified in the URL.
     * Add project SSH key
     */
    async addForProjectRaw(requestParameters: AddForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSshAccessKey'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Register a new SSH key and grants access to the project identified in the URL.
     * Add project SSH key
     */
    async addForProject(requestParameters: AddForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.addForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new SSH key and grants access to the repository identified in the URL.
     * Add repository SSH key
     */
    async addForRepositoryRaw(requestParameters: AddForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling addForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSshAccessKey'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Register a new SSH key and grants access to the repository identified in the URL.
     * Add repository SSH key
     */
    async addForRepository(requestParameters: AddForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.addForRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new IdP configuration.
     * Create IdP configuration
     */
    async addIdpRaw(requestParameters: AddIdpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IdpConfigEntity>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/authconfig/latest/idps`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['idpConfigEntity'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new IdP configuration.
     * Create IdP configuration
     */
    async addIdp(requestParameters: AddIdpRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IdpConfigEntity> {
        const response = await this.addIdpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new SSH key to a supplied user.
     * Add SSH key for user
     */
    async addSshKeyRaw(requestParameters: AddSshKeyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshKey>> {
        const queryParameters: any = {};

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['addSshKeyRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new SSH key to a supplied user.
     * Add SSH key for user
     */
    async addSshKey(requestParameters: AddSshKeyOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshKey> {
        const response = await this.addSshKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Authenticates as the given user. This endpoint <strong>may</strong>:  - Ask for two-step verification if the user has enrolled; or - Enforce enrollment in two-step verification if two-step verification enforcement is configured for the instance and the user is not yet enrolled.
     * Authenticate with 2SV
     */
    async authenticateRaw(requestParameters: AuthenticateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/authenticate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['authenticationEntity'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Authenticates as the given user. This endpoint <strong>may</strong>:  - Ask for two-step verification if the user has enrolled; or - Enforce enrollment in two-step verification if two-step verification enforcement is configured for the instance and the user is not yet enrolled.
     * Authenticate with 2SV
     */
    async authenticate(requestParameters: AuthenticateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationResponse> {
        const response = await this.authenticateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Authenticate as the given user using a recovery code.
     * Authenticate using recovery code
     */
    async authenticateWithRecoveryCodeRaw(requestParameters: AuthenticateWithRecoveryCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/authenticate/recovery-code`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpRecoveryCodeAuthenticationDTO'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Authenticate as the given user using a recovery code.
     * Authenticate using recovery code
     */
    async authenticateWithRecoveryCode(requestParameters: AuthenticateWithRecoveryCodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationResponse> {
        const response = await this.authenticateWithRecoveryCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Complete update of the authentication app used for two-step verification by verifying the provided TOTP code.
     * Complete authentication app update for 2SV
     */
    async completeAuthenticationChangeRaw(requestParameters: CompleteAuthenticationChangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TotpUserEnrollmentDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/totp/complete-enrollment-update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpCodeVerificationDTO'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Complete update of the authentication app used for two-step verification by verifying the provided TOTP code.
     * Complete authentication app update for 2SV
     */
    async completeAuthenticationChange(requestParameters: CompleteAuthenticationChangeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TotpUserEnrollmentDTO> {
        const response = await this.completeAuthenticationChangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Complete enforced enrollment in two-step verification by verifying the provided TOTP code and creating a new session for the given user.
     * Complete enforced enrollment in 2SV
     */
    async completeEnforcedEnrollmentRaw(requestParameters: CompleteEnforcedEnrollmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TotpRecoveryCodeDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/totp/complete-enforced-enrollment`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpCodeVerificationDTO'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Complete enforced enrollment in two-step verification by verifying the provided TOTP code and creating a new session for the given user.
     * Complete enforced enrollment in 2SV
     */
    async completeEnforcedEnrollment(requestParameters: CompleteEnforcedEnrollmentRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TotpRecoveryCodeDTO> {
        const response = await this.completeEnforcedEnrollmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Complete voluntary enrollment in two-step verification by verifying the provided TOTP code and creating a new session for the given user.
     * Complete voluntary enrollment in 2SV
     */
    async completeVoluntaryEnrollmentRaw(requestParameters: CompleteVoluntaryEnrollmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TotpUserEnrollmentDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/totp/complete-voluntary-enrollment`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpCodeVerificationDTO'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Complete voluntary enrollment in two-step verification by verifying the provided TOTP code and creating a new session for the given user.
     * Complete voluntary enrollment in 2SV
     */
    async completeVoluntaryEnrollment(requestParameters: CompleteVoluntaryEnrollmentRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TotpUserEnrollmentDTO> {
        const response = await this.completeVoluntaryEnrollmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the project according to the given request.
     * Create project HTTP token
     */
    async createAccessTokenRaw(requestParameters: CreateAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createAccessToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the project according to the given request.
     * Create project HTTP token
     */
    async createAccessToken(requestParameters: CreateAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.createAccessTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the repository according to the given request.
     * Create repository HTTP token
     */
    async createAccessToken1Raw(requestParameters: CreateAccessToken1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createAccessToken1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createAccessToken1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the repository according to the given request.
     * Create repository HTTP token
     */
    async createAccessToken1(requestParameters: CreateAccessToken1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.createAccessToken1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the user according to the given request.
     * Create personal HTTP token
     */
    async createAccessToken2Raw(requestParameters: CreateAccessToken2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling createAccessToken2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the user according to the given request.
     * Create personal HTTP token
     */
    async createAccessToken2(requestParameters: CreateAccessToken2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.createAccessToken2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteByIdRaw(requestParameters: DeleteByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteById().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById(requestParameters: DeleteByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteByIdRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById1Raw(requestParameters: DeleteById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteById1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteById1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById1(requestParameters: DeleteById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteById1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById2Raw(requestParameters: DeleteById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling deleteById2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById2(requestParameters: DeleteById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteById2Raw(requestParameters, initOverrides);
    }

    /**
     * Delete an SSH key.  The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Remove SSH key
     */
    async deleteSshKeyRaw(requestParameters: DeleteSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling deleteSshKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an SSH key.  The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Remove SSH key
     */
    async deleteSshKey(requestParameters: DeleteSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSshKeyRaw(requestParameters, initOverrides);
    }

    /**
     * Delete all SSH keys for a supplied user.
     * Delete all user SSH key
     */
    async deleteSshKeysRaw(requestParameters: DeleteSshKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['userName'] != null) {
            queryParameters['userName'] = requestParameters['userName'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete all SSH keys for a supplied user.
     * Delete all user SSH key
     */
    async deleteSshKeys(requestParameters: DeleteSshKeysRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSshKeysRaw(requestParameters, initOverrides);
    }

    /**
     * Elevate permissions by providing the password for the currently authenticated user. This will create an elevated session.
     * Create elevated session with password
     */
    async elevatePermissionsWithPasswordRaw(requestParameters: ElevatePermissionsWithPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['actionType'] != null) {
            queryParameters['actionType'] = requestParameters['actionType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/elevate-permissions/password`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpElevationRestDTO'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Elevate permissions by providing the password for the currently authenticated user. This will create an elevated session.
     * Create elevated session with password
     */
    async elevatePermissionsWithPassword(requestParameters: ElevatePermissionsWithPasswordRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.elevatePermissionsWithPasswordRaw(requestParameters, initOverrides);
    }

    /**
     * Elevate permissions by providing a recovery code for the currently authenticated user. This will create an elevated session.
     * Create elevated session with recovery code
     */
    async elevatePermissionsWithRecoveryCodeRaw(requestParameters: ElevatePermissionsWithRecoveryCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TotpRecoveryCodeDTO>> {
        const queryParameters: any = {};

        if (requestParameters['actionType'] != null) {
            queryParameters['actionType'] = requestParameters['actionType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/elevate-permissions/recovery-code`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpRecoveryCodeDTO'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Elevate permissions by providing a recovery code for the currently authenticated user. This will create an elevated session.
     * Create elevated session with recovery code
     */
    async elevatePermissionsWithRecoveryCode(requestParameters: ElevatePermissionsWithRecoveryCodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TotpRecoveryCodeDTO> {
        const response = await this.elevatePermissionsWithRecoveryCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Elevate permissions by providing a TOTP code for the currently authenticated user. This will create an elevated session.
     * Create elevated session with TOTP
     */
    async elevatePermissionsWithTotpRaw(requestParameters: ElevatePermissionsWithTotpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['actionType'] != null) {
            queryParameters['actionType'] = requestParameters['actionType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/elevate-permissions/totp`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpElevationRestDTO'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Elevate permissions by providing a TOTP code for the currently authenticated user. This will create an elevated session.
     * Create elevated session with TOTP
     */
    async elevatePermissionsWithTotp(requestParameters: ElevatePermissionsWithTotpRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.elevatePermissionsWithTotpRaw(requestParameters, initOverrides);
    }

    /**
     * Get the current configuration for blocking basic authentication requests.
     * Get basic auth configuration
     */
    async getRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BasicAuthConfigEntity>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/basicauth/latest/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the current configuration for blocking basic authentication requests.
     * Get basic auth configuration
     */
    async get(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BasicAuthConfigEntity> {
        const response = await this.getRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get all access tokens associated with the given project.
     * Get project HTTP tokens
     */
    async getAllAccessTokensRaw(requestParameters: GetAllAccessTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllAccessTokens200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAllAccessTokens().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given project.
     * Get project HTTP tokens
     */
    async getAllAccessTokens(requestParameters: GetAllAccessTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllAccessTokens200Response> {
        const response = await this.getAllAccessTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all access tokens associated with the given repository.
     * Get repository HTTP tokens
     */
    async getAllAccessTokens1Raw(requestParameters: GetAllAccessTokens1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllAccessTokens200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAllAccessTokens1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAllAccessTokens1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given repository.
     * Get repository HTTP tokens
     */
    async getAllAccessTokens1(requestParameters: GetAllAccessTokens1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllAccessTokens200Response> {
        const response = await this.getAllAccessTokens1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all access tokens associated with the given user.
     * Get personal HTTP tokens
     */
    async getAllAccessTokens2Raw(requestParameters: GetAllAccessTokens2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllAccessTokens200Response>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling getAllAccessTokens2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given user.
     * Get personal HTTP tokens
     */
    async getAllAccessTokens2(requestParameters: GetAllAccessTokens2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllAccessTokens200Response> {
        const response = await this.getAllAccessTokens2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getByIdRaw(requestParameters: GetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getById().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById(requestParameters: GetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById1Raw(requestParameters: GetById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getById1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getById1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById1(requestParameters: GetById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getById1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById2Raw(requestParameters: GetById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling getById2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById2(requestParameters: GetById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getById2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides data for a CAPTCHA challenge.
     * Get CAPTCHA challenge
     */
    async getCaptchaDataRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CaptchaDataEntity>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/tsv/latest/authenticate/captcha`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provides data for a CAPTCHA challenge.
     * Get CAPTCHA challenge
     */
    async getCaptchaData(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CaptchaDataEntity> {
        const response = await this.getCaptchaDataRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the SSO configuration.
     * Get SSO configuration
     */
    async getConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SsoConfigEntity>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/authconfig/latest/sso`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the SSO configuration.
     * Get SSO configuration
     */
    async getConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SsoConfigEntity> {
        const response = await this.getConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * Checks the state of an elevated session for the currently authenticated user.
     * Get elevated session status
     */
    async getElevatedPermissionStatusRaw(requestParameters: GetElevatedPermissionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['actionType'] != null) {
            queryParameters['actionType'] = requestParameters['actionType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/tsv/latest/elevate-permissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Checks the state of an elevated session for the currently authenticated user.
     * Get elevated session status
     */
    async getElevatedPermissionStatus(requestParameters: GetElevatedPermissionStatusRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getElevatedPermissionStatusRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the project identified in the URL.
     * Get project SSH key
     */
    async getForProjectRaw(requestParameters: GetForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForProject().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the project identified in the URL.
     * Get project SSH key
     */
    async getForProject(requestParameters: GetForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.getForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all project-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin any of the projects the key provides access to, none are returned.
     * Get project SSH keys
     */
    async getForProjectsRaw(requestParameters: GetForProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForProjects().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}/projects`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves all project-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin any of the projects the key provides access to, none are returned.
     * Get project SSH keys
     */
    async getForProjects(requestParameters: GetForProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getForProjectsRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves all repository-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin of any of the projects the key provides access to, none are returned.
     * Get repository SSH key
     */
    async getForRepositoriesRaw(requestParameters: GetForRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForRepositories().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['withRestrictions'] != null) {
            queryParameters['withRestrictions'] = requestParameters['withRestrictions'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}/repos`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves all repository-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin of any of the projects the key provides access to, none are returned.
     * Get repository SSH key
     */
    async getForRepositories(requestParameters: GetForRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getForRepositoriesRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the repository identified in the URL.
     * Get repository SSH key
     */
    async getForRepositoryRaw(requestParameters: GetForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForRepository().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the repository identified in the URL.
     * Get repository SSH key
     */
    async getForRepository(requestParameters: GetForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.getForRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the access keys for the repository identified in the URL.
     * Get repository SSH keys
     */
    async getForRepository1Raw(requestParameters: GetForRepository1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetForRepository1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForRepository1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getForRepository1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['effective'] != null) {
            queryParameters['effective'] = requestParameters['effective'];
        }

        if (requestParameters['minimumPermission'] != null) {
            queryParameters['minimumPermission'] = requestParameters['minimumPermission'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access keys for the repository identified in the URL.
     * Get repository SSH keys
     */
    async getForRepository1(requestParameters: GetForRepository1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetForRepository1200Response> {
        const response = await this.getForRepository1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the configuration for the IdP that matches the given ID.
     * Get IdP configuration
     */
    async getIdpRaw(requestParameters: GetIdpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IdpConfigEntity>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getIdp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/authconfig/latest/idps/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the configuration for the IdP that matches the given ID.
     * Get IdP configuration
     */
    async getIdp(requestParameters: GetIdpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IdpConfigEntity> {
        const response = await this.getIdpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a page of configured IdPs.   This endpoint makes no guarantees to ordering besides the ordering being consistent.
     * Get all configured IdPs
     */
    async getIdpsRaw(requestParameters: GetIdpsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetIdps200Response>> {
        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/authconfig/latest/idps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a page of configured IdPs.   This endpoint makes no guarantees to ordering besides the ordering being consistent.
     * Get all configured IdPs
     */
    async getIdps(requestParameters: GetIdpsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetIdps200Response> {
        const response = await this.getIdpsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the users created by JIT (Just-in-time) provisioning.  Just-in-time user provisioning (JIT provisioning) allows users to be created and updated automatically when they log in through SAML SSO or OpenID Connect (OIDC) SSO.
     * Get all JIT provisioned users
     */
    async getJitProvisionedUsersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JitUserEntity>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/authconfig/latest/jit-users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a list of all the users created by JIT (Just-in-time) provisioning.  Just-in-time user provisioning (JIT provisioning) allows users to be created and updated automatically when they log in through SAML SSO or OpenID Connect (OIDC) SSO.
     * Get all JIT provisioned users
     */
    async getJitProvisionedUsers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JitUserEntity> {
        const response = await this.getJitProvisionedUsersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of available login options, which contains details about the metadata required for the login page.  Only enabled login options will be returned. Login options can either be the native login form or the configured IdPs.
     * Get available login options
     */
    async getLoginOptionsRaw(requestParameters: GetLoginOptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLoginOptions200Response>> {
        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/authconfig/latest/login-options`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a list of available login options, which contains details about the metadata required for the login page.  Only enabled login options will be returned. Login options can either be the native login form or the configured IdPs.
     * Get available login options
     */
    async getLoginOptions(requestParameters: GetLoginOptionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLoginOptions200Response> {
        const response = await this.getLoginOptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve an SSH key by keyId  The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get SSH key for user by keyId
     */
    async getSshKeyRaw(requestParameters: GetSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshKey>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getSshKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve an SSH key by keyId  The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get SSH key for user by keyId
     */
    async getSshKey(requestParameters: GetSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshKey> {
        const response = await this.getSshKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of SSH keys.
     * Get SSH keys for user
     */
    async getSshKeysRaw(requestParameters: GetSshKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSshKeys200Response>> {
        const queryParameters: any = {};

        if (requestParameters['userName'] != null) {
            queryParameters['userName'] = requestParameters['userName'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of SSH keys.
     * Get SSH keys for user
     */
    async getSshKeys(requestParameters: GetSshKeysRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSshKeys200Response> {
        const response = await this.getSshKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the access keys for the project identified in the URL.
     * Get SSH key
     */
    async getSshKeysForProjectRaw(requestParameters: GetSshKeysForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetForRepository1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getSshKeysForProject().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access keys for the project identified in the URL.
     * Get SSH key
     */
    async getSshKeysForProject(requestParameters: GetSshKeysForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetForRepository1200Response> {
        const response = await this.getSshKeysForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the status of the SSO management for the currently authenticated user.
     * Get SSO management status
     */
    async getSsoManagementStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SsoManagementStatusDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/tsv/latest/sso-management-status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the status of the SSO management for the currently authenticated user.
     * Get SSO management status
     */
    async getSsoManagementStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SsoManagementStatusDTO> {
        const response = await this.getSsoManagementStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the status of two-step verification for the currently authenticated user.
     * Get two-step verification status
     */
    async getStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StatusDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/tsv/latest/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the status of two-step verification for the currently authenticated user.
     * Get two-step verification status
     */
    async getStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StatusDTO> {
        const response = await this.getStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Store a new configuration for blocking basic authentication requests.
     * Update basic auth configuration
     */
    async putRaw(requestParameters: PutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/basicauth/latest/config`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['basicAuthConfigEntity'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Store a new configuration for blocking basic authentication requests.
     * Update basic auth configuration
     */
    async put(requestParameters: PutRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putRaw(requestParameters, initOverrides);
    }

    /**
     * Removes the configuration for the IdP that matches the given ID.
     * Delete IdP configuration
     */
    async removeIdpRaw(requestParameters: RemoveIdpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IdpConfigEntity>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling removeIdp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/authconfig/latest/idps/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes the configuration for the IdP that matches the given ID.
     * Delete IdP configuration
     */
    async removeIdp(requestParameters: RemoveIdpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IdpConfigEntity> {
        const response = await this.removeIdpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove an existing access key for the project identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the project identified in the URL will be revoked.
     * Revoke project SSH key
     */
    async revokeForProjectRaw(requestParameters: RevokeForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokeForProject().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the project identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the project identified in the URL will be revoked.
     * Revoke project SSH key
     */
    async revokeForProject(requestParameters: RevokeForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeForProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Remove an existing access key for the repository identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the repository identified in the URL will be revoked.
     * Revoke repository SSH key
     */
    async revokeForRepositoryRaw(requestParameters: RevokeForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokeForRepository().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling revokeForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the repository identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the repository identified in the URL will be revoked.
     * Revoke repository SSH key
     */
    async revokeForRepository(requestParameters: RevokeForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeForRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     * Remove an existing access key for the projects and repositories in the submitted entity. If the same SSH key is used as an access key for multiple projects or repositories not supplied, only the access to the projects or repositories identified will be revoked.
     * Revoke project SSH key
     */
    async revokeManyRaw(requestParameters: RevokeManyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeMany().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['revokeManyRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the projects and repositories in the submitted entity. If the same SSH key is used as an access key for multiple projects or repositories not supplied, only the access to the projects or repositories identified will be revoked.
     * Revoke project SSH key
     */
    async revokeMany(requestParameters: RevokeManyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeManyRaw(requestParameters, initOverrides);
    }

    /**
     * Rotates the recovery code for the currently authentication user.
     * Rotate recovery code
     */
    async rotateRecoverCodeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TotpRecoveryCodeDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/tsv/latest/totp/recovery-code/rotate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Rotates the recovery code for the currently authentication user.
     * Rotate recovery code
     */
    async rotateRecoverCode(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TotpRecoveryCodeDTO> {
        const response = await this.rotateRecoverCodeRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the SSH settings from the upstream.
     * Get SSH settings
     */
    async sshSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the SSH settings from the upstream.
     * Get SSH settings
     */
    async sshSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshSettings> {
        const response = await this.sshSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Start or resume enforced enrollment in two-step verification by returning the conversation details.  There are two ways to enroll in two-step verification: voluntary and enforced. Enrollment is a two-step process. First, the user starts the enrollment process via <code>/start-voluntary-enrollment</code> or <code>/start-enforced-enrollment</code>. Second and final step is to complete the enrollment via <code>/complete-voluntary-enrollment</code> or <code>/complete-enforced-enrollment</code>. In the case of enforced enrollment, the conversation is started at the time of login via <code>/authenticate</code>.
     * Start enforced enrollment in 2SV
     */
    async startEnforcedEnrollmentRaw(requestParameters: StartEnforcedEnrollmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TotpUserEnrollmentDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/totp/start-enforced-enrollment`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['conversationDTO'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Start or resume enforced enrollment in two-step verification by returning the conversation details.  There are two ways to enroll in two-step verification: voluntary and enforced. Enrollment is a two-step process. First, the user starts the enrollment process via <code>/start-voluntary-enrollment</code> or <code>/start-enforced-enrollment</code>. Second and final step is to complete the enrollment via <code>/complete-voluntary-enrollment</code> or <code>/complete-enforced-enrollment</code>. In the case of enforced enrollment, the conversation is started at the time of login via <code>/authenticate</code>.
     * Start enforced enrollment in 2SV
     */
    async startEnforcedEnrollment(requestParameters: StartEnforcedEnrollmentRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TotpUserEnrollmentDTO> {
        const response = await this.startEnforcedEnrollmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start the process of changing the authentication app used for two-step verification by creating a conversation.
     * Start authentication app update for 2SV
     */
    async startEnrollmentUpdateRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TotpUserEnrollmentDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/tsv/latest/totp/start-enrollment-update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Start the process of changing the authentication app used for two-step verification by creating a conversation.
     * Start authentication app update for 2SV
     */
    async startEnrollmentUpdate(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TotpUserEnrollmentDTO> {
        const response = await this.startEnrollmentUpdateRaw(initOverrides);
        return await response.value();
    }

    /**
     * Start voluntary enrollment in two-step verification by creating a conversation.  There are two ways to enroll in two-step verification: voluntary and enforced. Enrollment is a two-step process. First, the user starts the enrollment process via <code>/start-voluntary-enrollment</code> or <code>/start-enforced-enrollment</code>. Second and final step is to complete the enrollment via <code>/complete-voluntary-enrollment</code> or <code>/complete-enforced-enrollment</code>. In the case of enforced enrollment, the conversation is started at the time of login via <code>/authenticate</code>.
     * Start voluntary enrollment in 2SV
     */
    async startVoluntaryEnrollmentRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TotpUserEnrollmentDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/tsv/latest/totp/start-voluntary-enrollment`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Start voluntary enrollment in two-step verification by creating a conversation.  There are two ways to enroll in two-step verification: voluntary and enforced. Enrollment is a two-step process. First, the user starts the enrollment process via <code>/start-voluntary-enrollment</code> or <code>/start-enforced-enrollment</code>. Second and final step is to complete the enrollment via <code>/complete-voluntary-enrollment</code> or <code>/complete-enforced-enrollment</code>. In the case of enforced enrollment, the conversation is started at the time of login via <code>/authenticate</code>.
     * Start voluntary enrollment in 2SV
     */
    async startVoluntaryEnrollment(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TotpUserEnrollmentDTO> {
        const response = await this.startVoluntaryEnrollmentRaw(initOverrides);
        return await response.value();
    }

    /**
     * Unenroll the currently authenticated user from two-step verification.
     * Uneroll current user from two-step verification
     */
    async unenrollRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/tsv/latest/totp/unenroll`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unenroll the currently authenticated user from two-step verification.
     * Uneroll current user from two-step verification
     */
    async unenroll(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unenrollRaw(initOverrides);
    }

    /**
     * Unenroll a user from two-step verification specified by the given username.
     * Unenroll specific user from two-step verification
     */
    async unenrollUserRaw(requestParameters: UnenrollUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['userName'] == null) {
            throw new runtime.RequiredError(
                'userName',
                'Required parameter "userName" was null or undefined when calling unenrollUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/totp/unenroll/user/{userName}`.replace(`{${"userName"}}`, encodeURIComponent(String(requestParameters['userName']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpElevationRestDTO'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unenroll a user from two-step verification specified by the given username.
     * Unenroll specific user from two-step verification
     */
    async unenrollUser(requestParameters: UnenrollUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unenrollUserRaw(requestParameters, initOverrides);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessTokenRaw(requestParameters: UpdateAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateAccessToken().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling updateAccessToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken(requestParameters: UpdateAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.updateAccessTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken1Raw(requestParameters: UpdateAccessToken1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateAccessToken1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling updateAccessToken1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateAccessToken1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken1(requestParameters: UpdateAccessToken1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.updateAccessToken1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken2Raw(requestParameters: UpdateAccessToken2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling updateAccessToken2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling updateAccessToken2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken2(requestParameters: UpdateAccessToken2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.updateAccessToken2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the SSO configuration.
     * Update SSO configuration
     */
    async updateConfigRaw(requestParameters: UpdateConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SsoConfigEntity>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/authconfig/latest/sso`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['ssoConfigEntity'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the SSO configuration.
     * Update SSO configuration
     */
    async updateConfig(requestParameters: UpdateConfigRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SsoConfigEntity> {
        const response = await this.updateConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the configuration for the IdP that matches the given ID.   Only the provided properties will be applied to the IdP configuration.
     * Update IdP configuration
     */
    async updateIdpRaw(requestParameters: UpdateIdpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IdpConfigEntity>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateIdp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/authconfig/latest/idps/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['idpConfigEntity'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the configuration for the IdP that matches the given ID.   Only the provided properties will be applied to the IdP configuration.
     * Update IdP configuration
     */
    async updateIdp(requestParameters: UpdateIdpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IdpConfigEntity> {
        const response = await this.updateIdpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the permission granted to the specified SSH key to the project identified in the URL.
     * Update project SSH key permission
     */
    async updatePermissionRaw(requestParameters: UpdatePermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePermission().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling updatePermission().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling updatePermission().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}/permission/{permission}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the permission granted to the specified SSH key to the project identified in the URL.
     * Update project SSH key permission
     */
    async updatePermission(requestParameters: UpdatePermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.updatePermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the permission granted to the specified SSH key to the repository identified in the URL.
     * Update repository SSH key permission
     */
    async updatePermission1Raw(requestParameters: UpdatePermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePermission1().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling updatePermission1().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling updatePermission1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updatePermission1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}/permission/{permission}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the permission granted to the specified SSH key to the repository identified in the URL.
     * Update repository SSH key permission
     */
    async updatePermission1(requestParameters: UpdatePermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.updatePermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Authenticate as the given user using a TOTP code.
     * Authenticate using TOTP code
     */
    async verifyCodeRaw(requestParameters: VerifyCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/tsv/latest/authenticate/totp-code`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['totpCodeVerificationDTO'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Authenticate as the given user using a TOTP code.
     * Authenticate using TOTP code
     */
    async verifyCode(requestParameters: VerifyCodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.verifyCodeRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ElevatePermissionsWithPasswordActionTypeEnum = {
    UnlockUser2svSettings: 'unlock-user-2sv-settings'
} as const;
export type ElevatePermissionsWithPasswordActionTypeEnum = typeof ElevatePermissionsWithPasswordActionTypeEnum[keyof typeof ElevatePermissionsWithPasswordActionTypeEnum];
/**
 * @export
 */
export const ElevatePermissionsWithRecoveryCodeActionTypeEnum = {
    UnlockUser2svSettings: 'unlock-user-2sv-settings'
} as const;
export type ElevatePermissionsWithRecoveryCodeActionTypeEnum = typeof ElevatePermissionsWithRecoveryCodeActionTypeEnum[keyof typeof ElevatePermissionsWithRecoveryCodeActionTypeEnum];
/**
 * @export
 */
export const ElevatePermissionsWithTotpActionTypeEnum = {
    UnlockUser2svSettings: 'unlock-user-2sv-settings'
} as const;
export type ElevatePermissionsWithTotpActionTypeEnum = typeof ElevatePermissionsWithTotpActionTypeEnum[keyof typeof ElevatePermissionsWithTotpActionTypeEnum];
/**
 * @export
 */
export const GetElevatedPermissionStatusActionTypeEnum = {
    UnlockUser2svSettings: 'unlock-user-2sv-settings'
} as const;
export type GetElevatedPermissionStatusActionTypeEnum = typeof GetElevatedPermissionStatusActionTypeEnum[keyof typeof GetElevatedPermissionStatusActionTypeEnum];
