/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Server
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 8.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddSshKeyRequest,
  GetAll200Response,
  GetAll401Response,
  GetForProject1200Response,
  GetSshKeys200Response,
  RestAccessToken,
  RestAccessTokenRequest,
  RestRawAccessToken,
  RestSshAccessKey,
  RestSshKey,
  RestSshSettings,
  RevokeManyRequest,
} from '../models/index';

interface AddForProjectRequest {
    projectKey: string;
    restSshAccessKey?: RestSshAccessKey;
}

interface AddForRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
    restSshAccessKey?: RestSshAccessKey;
}

interface AddSshKeyOperationRequest {
    userName?: Omit<RestSshKey, 'createdDate'|'lastAuthenticated'|'id'>;
    user?: string;
    addSshKeyRequest?: Omit<AddSshKeyRequest, 'createdDate'|'id'|'lastAuthenticated'>;
}

interface Create1Request {
    projectKey: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface Create2Request {
    projectKey: string;
    repositorySlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface Create3Request {
    userSlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface DeleteByIdRequest {
    projectKey: string;
    tokenId: string;
}

interface DeleteById1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
}

interface DeleteById2Request {
    tokenId: string;
    userSlug: string;
}

interface DeleteSshKeyRequest {
    keyId: string;
}

interface DeleteSshKeysRequest {
    userName?: string;
    user?: string;
}

interface GetAllRequest {
    projectKey: string;
    start?: number;
    limit?: number;
}

interface GetAll1Request {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetAll2Request {
    userSlug: string;
    start?: number;
    limit?: number;
}

interface GetByIdRequest {
    projectKey: string;
    tokenId: string;
}

interface GetById1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
}

interface GetById2Request {
    tokenId: string;
    userSlug: string;
}

interface GetForProjectRequest {
    projectKey: string;
    keyId: string;
}

interface GetForProject1Request {
    projectKey: string;
    filter?: string;
    permission?: string;
    start?: number;
    limit?: number;
}

interface GetForProjectsRequest {
    keyId: number;
}

interface GetForRepositoriesRequest {
    keyId: string;
    withRestrictions?: string;
}

interface GetForRepositoryRequest {
    projectKey: string;
    keyId: string;
    repositorySlug: string;
}

interface GetForRepository1Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    effective?: string;
    minimumPermission?: string;
    permission?: string;
    start?: number;
    limit?: number;
}

interface GetSshKeyRequest {
    keyId: string;
}

interface GetSshKeysRequest {
    userName?: string;
    user?: string;
    start?: number;
    limit?: number;
}

interface RevokeForProjectRequest {
    projectKey: string;
    keyId: string;
}

interface RevokeForRepositoryRequest {
    projectKey: string;
    keyId: string;
    repositorySlug: string;
}

interface RevokeManyOperationRequest {
    keyId: string;
    revokeManyRequest?: RevokeManyRequest;
}

interface UpdateRequest {
    projectKey: string;
    tokenId: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface Update1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface Update2Request {
    tokenId: string;
    userSlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface UpdatePermissionRequest {
    projectKey: string;
    keyId: string;
    permission: string;
    repositorySlug: string;
}

interface UpdatePermission1Request {
    projectKey: string;
    keyId: string;
    permission: string;
}

/**
 * 
 */
export class AuthenticationApi extends runtime.BaseAPI {

    /**
     * Register a new SSH key and grants access to the project identified in the URL.
     * Add project SSH key
     */
    async addForProjectRaw(requestParameters: AddForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSshAccessKey'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Register a new SSH key and grants access to the project identified in the URL.
     * Add project SSH key
     */
    async addForProject(requestParameters: AddForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.addForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new SSH key and grants access to the repository identified in the URL.
     * Add repository SSH key
     */
    async addForRepositoryRaw(requestParameters: AddForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling addForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSshAccessKey'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Register a new SSH key and grants access to the repository identified in the URL.
     * Add repository SSH key
     */
    async addForRepository(requestParameters: AddForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.addForRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new SSH key to a supplied user.
     * Add SSH key for user
     */
    async addSshKeyRaw(requestParameters: AddSshKeyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshKey>> {
        const queryParameters: any = {};

        if (requestParameters['userName'] != null) {
            queryParameters['userName'] = requestParameters['userName'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['addSshKeyRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new SSH key to a supplied user.
     * Add SSH key for user
     */
    async addSshKey(requestParameters: AddSshKeyOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshKey> {
        const response = await this.addSshKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the project according to the given request.
     * Create project HTTP token
     */
    async create1Raw(requestParameters: Create1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling create1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the project according to the given request.
     * Create project HTTP token
     */
    async create1(requestParameters: Create1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.create1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the repository according to the given request.
     * Create repository HTTP token
     */
    async create2Raw(requestParameters: Create2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling create2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling create2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the repository according to the given request.
     * Create repository HTTP token
     */
    async create2(requestParameters: Create2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.create2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the user according to the given request.
     * Create personal HTTP token
     */
    async create3Raw(requestParameters: Create3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling create3().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the user according to the given request.
     * Create personal HTTP token
     */
    async create3(requestParameters: Create3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.create3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteByIdRaw(requestParameters: DeleteByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteById().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById(requestParameters: DeleteByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteByIdRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById1Raw(requestParameters: DeleteById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteById1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteById1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById1(requestParameters: DeleteById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteById1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById2Raw(requestParameters: DeleteById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling deleteById2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById2(requestParameters: DeleteById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteById2Raw(requestParameters, initOverrides);
    }

    /**
     * Delete an SSH key.
     * Remove SSH key
     */
    async deleteSshKeyRaw(requestParameters: DeleteSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling deleteSshKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an SSH key.
     * Remove SSH key
     */
    async deleteSshKey(requestParameters: DeleteSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSshKeyRaw(requestParameters, initOverrides);
    }

    /**
     * Delete all SSH keys for a supplied user.
     * Delete all user SSH key
     */
    async deleteSshKeysRaw(requestParameters: DeleteSshKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['userName'] != null) {
            queryParameters['userName'] = requestParameters['userName'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete all SSH keys for a supplied user.
     * Delete all user SSH key
     */
    async deleteSshKeys(requestParameters: DeleteSshKeysRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSshKeysRaw(requestParameters, initOverrides);
    }

    /**
     * Get all access tokens associated with the given project.
     * Get project HTTP tokens
     */
    async getAllRaw(requestParameters: GetAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAll200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAll().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given project.
     * Get project HTTP tokens
     */
    async getAll(requestParameters: GetAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAll200Response> {
        const response = await this.getAllRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all access tokens associated with the given repository.
     * Get repository HTTP tokens
     */
    async getAll1Raw(requestParameters: GetAll1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAll200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAll1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAll1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given repository.
     * Get repository HTTP tokens
     */
    async getAll1(requestParameters: GetAll1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAll200Response> {
        const response = await this.getAll1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all access tokens associated with the given user.
     * Get personal HTTP tokens
     */
    async getAll2Raw(requestParameters: GetAll2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAll200Response>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling getAll2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given user.
     * Get personal HTTP tokens
     */
    async getAll2(requestParameters: GetAll2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAll200Response> {
        const response = await this.getAll2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getByIdRaw(requestParameters: GetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getById().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById(requestParameters: GetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById1Raw(requestParameters: GetById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getById1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getById1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById1(requestParameters: GetById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getById1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById2Raw(requestParameters: GetById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling getById2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById2(requestParameters: GetById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getById2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the project identified in the URL.
     * Get project SSH key
     */
    async getForProjectRaw(requestParameters: GetForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForProject().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the project identified in the URL.
     * Get project SSH key
     */
    async getForProject(requestParameters: GetForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.getForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the access keys for the project identified in the URL.
     * Get SSH key
     */
    async getForProject1Raw(requestParameters: GetForProject1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetForProject1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForProject1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access keys for the project identified in the URL.
     * Get SSH key
     */
    async getForProject1(requestParameters: GetForProject1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetForProject1200Response> {
        const response = await this.getForProject1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all project-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin any of the projects the key provides access to, none are returned.
     * Get project SSH keys
     */
    async getForProjectsRaw(requestParameters: GetForProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForProjects().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}/projects`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves all project-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin any of the projects the key provides access to, none are returned.
     * Get project SSH keys
     */
    async getForProjects(requestParameters: GetForProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getForProjectsRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves all repository-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin of any of the projects the key provides access to, none are returned.
     * Get repository SSH key
     */
    async getForRepositoriesRaw(requestParameters: GetForRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForRepositories().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['withRestrictions'] != null) {
            queryParameters['withRestrictions'] = requestParameters['withRestrictions'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}/repos`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves all repository-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin of any of the projects the key provides access to, none are returned.
     * Get repository SSH key
     */
    async getForRepositories(requestParameters: GetForRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getForRepositoriesRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the repository identified in the URL.
     * Get repository SSH key
     */
    async getForRepositoryRaw(requestParameters: GetForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForRepository().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the repository identified in the URL.
     * Get repository SSH key
     */
    async getForRepository(requestParameters: GetForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.getForRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the access keys for the repository identified in the URL.
     * Get repository SSH keys
     */
    async getForRepository1Raw(requestParameters: GetForRepository1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetForProject1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForRepository1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getForRepository1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['effective'] != null) {
            queryParameters['effective'] = requestParameters['effective'];
        }

        if (requestParameters['minimumPermission'] != null) {
            queryParameters['minimumPermission'] = requestParameters['minimumPermission'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access keys for the repository identified in the URL.
     * Get repository SSH keys
     */
    async getForRepository1(requestParameters: GetForRepository1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetForProject1200Response> {
        const response = await this.getForRepository1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve an SSH key by keyId
     * Get SSH key for user by keyId
     */
    async getSshKeyRaw(requestParameters: GetSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshKey>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getSshKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve an SSH key by keyId
     * Get SSH key for user by keyId
     */
    async getSshKey(requestParameters: GetSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshKey> {
        const response = await this.getSshKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of SSH keys.
     * Get SSH keys for user
     */
    async getSshKeysRaw(requestParameters: GetSshKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSshKeys200Response>> {
        const queryParameters: any = {};

        if (requestParameters['userName'] != null) {
            queryParameters['userName'] = requestParameters['userName'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of SSH keys.
     * Get SSH keys for user
     */
    async getSshKeys(requestParameters: GetSshKeysRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSshKeys200Response> {
        const response = await this.getSshKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove an existing access key for the project identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the project identified in the URL will be revoked.
     * Revoke project SSH key
     */
    async revokeForProjectRaw(requestParameters: RevokeForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokeForProject().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the project identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the project identified in the URL will be revoked.
     * Revoke project SSH key
     */
    async revokeForProject(requestParameters: RevokeForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeForProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Remove an existing access key for the repository identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the repository identified in the URL will be revoked.
     * Revoke repository SSH key
     */
    async revokeForRepositoryRaw(requestParameters: RevokeForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokeForRepository().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling revokeForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the repository identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the repository identified in the URL will be revoked.
     * Revoke repository SSH key
     */
    async revokeForRepository(requestParameters: RevokeForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeForRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     * Remove an existing access key for the projects and repositories in the submitted entity. If the same SSH key is used as an access key for multiple projects or repositories not supplied, only the access to the projects or repositories identified will be revoked.
     * Revoke project SSH key
     */
    async revokeManyRaw(requestParameters: RevokeManyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeMany().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['revokeManyRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the projects and repositories in the submitted entity. If the same SSH key is used as an access key for multiple projects or repositories not supplied, only the access to the projects or repositories identified will be revoked.
     * Revoke project SSH key
     */
    async revokeMany(requestParameters: RevokeManyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeManyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async sshSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     */
    async sshSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshSettings> {
        const response = await this.sshSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateRaw(requestParameters: UpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling update().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling update().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async update(requestParameters: UpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.updateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async update1Raw(requestParameters: Update1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling update1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling update1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling update1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async update1(requestParameters: Update1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.update1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async update2Raw(requestParameters: Update2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling update2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling update2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async update2(requestParameters: Update2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.update2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the permission granted to the specified SSH key to the repository identified in the URL.
     * Update repository SSH key permission
     */
    async updatePermissionRaw(requestParameters: UpdatePermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePermission().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling updatePermission().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling updatePermission().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updatePermission().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}/permission/{permission}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the permission granted to the specified SSH key to the repository identified in the URL.
     * Update repository SSH key permission
     */
    async updatePermission(requestParameters: UpdatePermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.updatePermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the permission granted to the specified SSH key to the project identified in the URL.
     * Update project SSH key permission
     */
    async updatePermission1Raw(requestParameters: UpdatePermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePermission1().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling updatePermission1().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling updatePermission1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}/permission/{permission}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the permission granted to the specified SSH key to the project identified in the URL.
     * Update project SSH key permission
     */
    async updatePermission1(requestParameters: UpdatePermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.updatePermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

}
