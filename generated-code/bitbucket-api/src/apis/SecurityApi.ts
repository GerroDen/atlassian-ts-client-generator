/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetAllAccessTokens401Response,
  GetKeysForUser200Response,
  GetRepositoriesRecentlyAccessed200Response,
  RestGpgKey,
  RestRepositorySelector,
  RestSecretScanningAllowlistRule,
  RestSecretScanningAllowlistRuleSetRequest,
  RestSecretScanningRule,
  RestSecretScanningRuleSetRequest,
  RestSystemSigningConfiguration,
  RestX509Certificate,
  Search2200Response,
  Search3200Response,
  UpdateSystemSigningConfigurationRequest,
} from '../models/index';

interface AddKeyRequest {
    user?: string;
    restGpgKey?: Omit<RestGpgKey, 'emailAddress'|'expiryDate'|'fingerprint'|'id'|'subKeys'>;
}

interface BulkAddExemptRepositoriesRequest {
    restRepositorySelector?: Array<RestRepositorySelector>;
}

interface BulkAddExemptRepositories1Request {
    restRepositorySelector?: Array<RestRepositorySelector>;
}

interface CreateAllowlistRuleRequest {
    projectKey: string;
    restSecretScanningAllowlistRuleSetRequest: RestSecretScanningAllowlistRuleSetRequest;
}

interface CreateAllowlistRule1Request {
    projectKey: string;
    repositorySlug: string;
    restSecretScanningAllowlistRuleSetRequest: RestSecretScanningAllowlistRuleSetRequest;
}

interface CreateCertificateRequest {
    certificate?: Blob;
}

interface CreateRuleRequest {
    projectKey: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface CreateRule1Request {
    projectKey: string;
    repositorySlug: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface CreateRule2Request {
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface DeleteAllowlistRuleRequest {
    projectKey: string;
    id: string;
}

interface DeleteAllowlistRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface DeleteCertificateRequest {
    id: string;
}

interface DeleteForUserRequest {
    user?: string;
}

interface DeleteKeyRequest {
    fingerprintOrId: string;
}

interface DeleteRuleRequest {
    projectKey: string;
    id: string;
}

interface DeleteRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface DeleteRule2Request {
    id: string;
}

interface EditAllowlistRuleRequest {
    projectKey: string;
    id: string;
    restSecretScanningAllowlistRuleSetRequest: RestSecretScanningAllowlistRuleSetRequest;
}

interface EditAllowlistRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
    restSecretScanningAllowlistRuleSetRequest: RestSecretScanningAllowlistRuleSetRequest;
}

interface EditRuleRequest {
    projectKey: string;
    id: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface EditRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface EditRule2Request {
    id: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface FindExemptReposByProjectRequest {
    order?: FindExemptReposByProjectOrderEnum;
    start?: number;
    limit?: number;
}

interface FindExemptReposByScopeRequest {
    order?: FindExemptReposByScopeOrderEnum;
    start?: number;
    limit?: number;
}

interface GetAllowlistRuleRequest {
    projectKey: string;
    id: string;
}

interface GetAllowlistRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface GetKeysForUserRequest {
    user?: string;
    start?: number;
    limit?: number;
}

interface GetRuleRequest {
    projectKey: string;
    id: string;
}

interface GetRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface GetRule2Request {
    id: string;
}

interface Search1Request {
    projectKey: string;
    filter?: string;
    order?: Search1OrderEnum;
    start?: number;
    limit?: number;
}

interface Search2Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    order?: Search2OrderEnum;
    start?: number;
    limit?: number;
}

interface Search3Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    order?: Search3OrderEnum;
    start?: number;
    limit?: number;
}

interface Search4Request {
    filter?: string;
    order?: Search4OrderEnum;
    start?: number;
    limit?: number;
}

interface SearchAllowlistRuleRequest {
    projectKey: string;
    filter?: string;
    order?: SearchAllowlistRuleOrderEnum;
    start?: number;
    limit?: number;
}

interface UpdateCertificateRevocationListEntriesRequest {
    id: string;
}

interface UpdateSystemSigningConfigurationOperationRequest {
    updateSystemSigningConfigurationRequest?: UpdateSystemSigningConfigurationRequest;
}

/**
 * 
 */
export class SecurityApi extends runtime.BaseAPI {

    /**
     * Exempt a repository from being scanned for secrets   <strong>Deprecated since 8.6</strong>. Exemptions are now managed by scope.  Use POST /rest/api/1.0/secret-scanning/exempt for global scope  Use POST /rest/api/1.0/projects/{projectKey}/secret-scanning/exempt for the project scope
     * Exempt a repo from secret scanning
     * @deprecated
     */
    async addExemptRepoRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/exempt`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Exempt a repository from being scanned for secrets   <strong>Deprecated since 8.6</strong>. Exemptions are now managed by scope.  Use POST /rest/api/1.0/secret-scanning/exempt for global scope  Use POST /rest/api/1.0/projects/{projectKey}/secret-scanning/exempt for the project scope
     * Exempt a repo from secret scanning
     * @deprecated
     */
    async addExemptRepo(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addExemptRepoRaw(initOverrides);
    }

    /**
     * Add a GPG key to the authenticated user\'s account. Optionally, users with ADMIN and higher permissions may choose to specify the <code>user</code> parameter to add a GPG key for another user.  Only authenticated users may call this endpoint.
     * Create a GPG key
     */
    async addKeyRaw(requestParameters: AddKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestGpgKey>> {
        const queryParameters: any = {};

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/gpg/latest/keys`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restGpgKey'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a GPG key to the authenticated user\'s account. Optionally, users with ADMIN and higher permissions may choose to specify the <code>user</code> parameter to add a GPG key for another user.  Only authenticated users may call this endpoint.
     * Create a GPG key
     */
    async addKey(requestParameters: AddKeyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestGpgKey> {
        const response = await this.addKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk exempt a  list of repositories from being scanned for secrets. User must be have global **ADMIN** permissions.
     * Bulk exempt repos from secret scanning
     */
    async bulkAddExemptRepositoriesRaw(requestParameters: BulkAddExemptRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/secret-scanning/exempt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepositorySelector'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Bulk exempt a  list of repositories from being scanned for secrets. User must be have global **ADMIN** permissions.
     * Bulk exempt repos from secret scanning
     */
    async bulkAddExemptRepositories(requestParameters: BulkAddExemptRepositoriesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bulkAddExemptRepositoriesRaw(requestParameters, initOverrides);
    }

    /**
     * Bulk exempt a  list of repositories from being scanned for secrets. User must be have **PROJECT ADMIN** permissions.
     * Bulk exempt repos from secret scanning
     */
    async bulkAddExemptRepositories1Raw(requestParameters: BulkAddExemptRepositories1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/exempt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepositorySelector'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Bulk exempt a  list of repositories from being scanned for secrets. User must be have **PROJECT ADMIN** permissions.
     * Bulk exempt repos from secret scanning
     */
    async bulkAddExemptRepositories1(requestParameters: BulkAddExemptRepositories1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bulkAddExemptRepositories1Raw(requestParameters, initOverrides);
    }

    /**
     * Create a new project level secret scanning allowlist rule. Project allowlist rules are used when scanning all non exempt repositories in the provided project.  Project **Admin** is required
     * Create project secret scanning allowlist rule
     */
    async createAllowlistRuleRaw(requestParameters: CreateAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createAllowlistRule().'
            );
        }

        if (requestParameters['restSecretScanningAllowlistRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningAllowlistRuleSetRequest',
                'Required parameter "restSecretScanningAllowlistRuleSetRequest" was null or undefined when calling createAllowlistRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningAllowlistRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new project level secret scanning allowlist rule. Project allowlist rules are used when scanning all non exempt repositories in the provided project.  Project **Admin** is required
     * Create project secret scanning allowlist rule
     */
    async createAllowlistRule(requestParameters: CreateAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.createAllowlistRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new repository secret scanning allowlist rule. Repository allowlist rules are used when scanning the given repository.  Repository **Admin** is required
     * Create repository secret scanning allowlist rule
     */
    async createAllowlistRule1Raw(requestParameters: CreateAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createAllowlistRule1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createAllowlistRule1().'
            );
        }

        if (requestParameters['restSecretScanningAllowlistRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningAllowlistRuleSetRequest',
                'Required parameter "restSecretScanningAllowlistRuleSetRequest" was null or undefined when calling createAllowlistRule1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningAllowlistRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new repository secret scanning allowlist rule. Repository allowlist rules are used when scanning the given repository.  Repository **Admin** is required
     * Create repository secret scanning allowlist rule
     */
    async createAllowlistRule1(requestParameters: CreateAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.createAllowlistRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an X.509 certificate. This will add the given X.509 certificate to the system. Existing entries will not be overridden if an X.509 certificate already exists. Once added, an X.509 certificate cannot be updated.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Create an X.509 certificate
     */
    async createCertificateRaw(requestParameters: CreateCertificateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestX509Certificate>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['certificate'] != null) {
            formParams.append('certificate', requestParameters['certificate'] as any);
        }

        const response = await this.request({
            path: `/api/latest/signing/x509-certificates`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an X.509 certificate. This will add the given X.509 certificate to the system. Existing entries will not be overridden if an X.509 certificate already exists. Once added, an X.509 certificate cannot be updated.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Create an X.509 certificate
     */
    async createCertificate(requestParameters: CreateCertificateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestX509Certificate> {
        const response = await this.createCertificateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new project level secret scanning rule. Project rules are used when scanning all non exempt repositories in the provided project.  Project **Admin** is required
     * Create project secret scanning rule
     */
    async createRuleRaw(requestParameters: CreateRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createRule().'
            );
        }

        if (requestParameters['restSecretScanningRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningRuleSetRequest',
                'Required parameter "restSecretScanningRuleSetRequest" was null or undefined when calling createRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new project level secret scanning rule. Project rules are used when scanning all non exempt repositories in the provided project.  Project **Admin** is required
     * Create project secret scanning rule
     */
    async createRule(requestParameters: CreateRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.createRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new repository secret scanning rule. Repository rules are used when scanning the given repository.  Repository **Admin** is required
     * Create repository secret scanning rule
     */
    async createRule1Raw(requestParameters: CreateRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createRule1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createRule1().'
            );
        }

        if (requestParameters['restSecretScanningRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningRuleSetRequest',
                'Required parameter "restSecretScanningRuleSetRequest" was null or undefined when calling createRule1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new repository secret scanning rule. Repository rules are used when scanning the given repository.  Repository **Admin** is required
     * Create repository secret scanning rule
     */
    async createRule1(requestParameters: CreateRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.createRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new global secret scanning rule. Global rules are used when scanning all non exempt repositories.
     * Create global secret scanning rule
     */
    async createRule2Raw(requestParameters: CreateRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['restSecretScanningRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningRuleSetRequest',
                'Required parameter "restSecretScanningRuleSetRequest" was null or undefined when calling createRule2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new global secret scanning rule. Global rules are used when scanning all non exempt repositories.
     * Create global secret scanning rule
     */
    async createRule2(requestParameters: CreateRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.createRule2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a project secret scanning allowlist rule with the provided ID.  Project **Admin** is required
     * Delete a project secret scanning allowlist rule
     */
    async deleteAllowlistRuleRaw(requestParameters: DeleteAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteAllowlistRule().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteAllowlistRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a project secret scanning allowlist rule with the provided ID.  Project **Admin** is required
     * Delete a project secret scanning allowlist rule
     */
    async deleteAllowlistRule(requestParameters: DeleteAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAllowlistRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a repository secret scanning allowlist rule with the provided ID.  Repository **Admin** is required
     * Delete a repository secret scanning allowlist rule
     */
    async deleteAllowlistRule1Raw(requestParameters: DeleteAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteAllowlistRule1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteAllowlistRule1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteAllowlistRule1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a repository secret scanning allowlist rule with the provided ID.  Repository **Admin** is required
     * Delete a repository secret scanning allowlist rule
     */
    async deleteAllowlistRule1(requestParameters: DeleteAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAllowlistRule1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete an X.509 certificate specified by the given ID.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Delete an X.509 certificate
     */
    async deleteCertificateRaw(requestParameters: DeleteCertificateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestX509Certificate>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteCertificate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/signing/x509-certificates/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Delete an X.509 certificate specified by the given ID.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Delete an X.509 certificate
     */
    async deleteCertificate(requestParameters: DeleteCertificateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestX509Certificate> {
        const response = await this.deleteCertificateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a repository from being exempt from secret scanning
     * Delete an exempt repository
     */
    async deleteExemptRepoRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/exempt`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a repository from being exempt from secret scanning
     * Delete an exempt repository
     */
    async deleteExemptRepo(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteExemptRepoRaw(initOverrides);
    }

    /**
     * Delete all GPG keys for a supplied user.
     * Delete all GPG keys for user
     */
    async deleteForUserRaw(requestParameters: DeleteForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gpg/latest/keys`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete all GPG keys for a supplied user.
     * Delete all GPG keys for user
     */
    async deleteForUser(requestParameters: DeleteForUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteForUserRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the inactive AES encryption key(s). Post rotation, inactive AES key(s) can be cleaned up.
     * Delete inactive AES key(s)
     */
    async deleteInactiveKeysRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/secrets/1.0/keys/inactive`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the inactive AES encryption key(s). Post rotation, inactive AES key(s) can be cleaned up.
     * Delete inactive AES key(s)
     */
    async deleteInactiveKeys(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteInactiveKeysRaw(initOverrides);
    }

    /**
     * Delete the GPG key with the specified ID or Key Fingerprint.
     * Delete a GPG key
     */
    async deleteKeyRaw(requestParameters: DeleteKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['fingerprintOrId'] == null) {
            throw new runtime.RequiredError(
                'fingerprintOrId',
                'Required parameter "fingerprintOrId" was null or undefined when calling deleteKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gpg/latest/keys/{fingerprintOrId}`.replace(`{${"fingerprintOrId"}}`, encodeURIComponent(String(requestParameters['fingerprintOrId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the GPG key with the specified ID or Key Fingerprint.
     * Delete a GPG key
     */
    async deleteKey(requestParameters: DeleteKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteKeyRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a project secret scanning rule with the provided ID.  Project **Admin** is required
     * Delete a project secret scanning rule
     */
    async deleteRuleRaw(requestParameters: DeleteRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteRule().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a project secret scanning rule with the provided ID.  Project **Admin** is required
     * Delete a project secret scanning rule
     */
    async deleteRule(requestParameters: DeleteRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a repository secret scanning rule with the provided ID.  Repository **Admin** is required
     * Delete a repository secret scanning rule
     */
    async deleteRule1Raw(requestParameters: DeleteRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteRule1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteRule1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteRule1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a repository secret scanning rule with the provided ID.  Repository **Admin** is required
     * Delete a repository secret scanning rule
     */
    async deleteRule1(requestParameters: DeleteRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRule1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete a global secret scanning rule with the provided ID
     * Delete a global secret scanning rule
     */
    async deleteRule2Raw(requestParameters: DeleteRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteRule2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a global secret scanning rule with the provided ID
     * Delete a global secret scanning rule
     */
    async deleteRule2(requestParameters: DeleteRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRule2Raw(requestParameters, initOverrides);
    }

    /**
     * Edit a project secret scanning allowlist rule.  Project **Admin** is required
     * Edit an existing project secret scanning allowlist rule
     */
    async editAllowlistRuleRaw(requestParameters: EditAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling editAllowlistRule().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling editAllowlistRule().'
            );
        }

        if (requestParameters['restSecretScanningAllowlistRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningAllowlistRuleSetRequest',
                'Required parameter "restSecretScanningAllowlistRuleSetRequest" was null or undefined when calling editAllowlistRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningAllowlistRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit a project secret scanning allowlist rule.  Project **Admin** is required
     * Edit an existing project secret scanning allowlist rule
     */
    async editAllowlistRule(requestParameters: EditAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.editAllowlistRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit a repository secret scanning allowlist rule.  Repository **Admin** is required
     * Edit an existing repository secret scanning allowlist rule
     */
    async editAllowlistRule1Raw(requestParameters: EditAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling editAllowlistRule1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling editAllowlistRule1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling editAllowlistRule1().'
            );
        }

        if (requestParameters['restSecretScanningAllowlistRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningAllowlistRuleSetRequest',
                'Required parameter "restSecretScanningAllowlistRuleSetRequest" was null or undefined when calling editAllowlistRule1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningAllowlistRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit a repository secret scanning allowlist rule.  Repository **Admin** is required
     * Edit an existing repository secret scanning allowlist rule
     */
    async editAllowlistRule1(requestParameters: EditAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.editAllowlistRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit a project secret scanning rule.  Project **Admin** is required
     * Edit an existing project secret scanning rule
     */
    async editRuleRaw(requestParameters: EditRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling editRule().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling editRule().'
            );
        }

        if (requestParameters['restSecretScanningRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningRuleSetRequest',
                'Required parameter "restSecretScanningRuleSetRequest" was null or undefined when calling editRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit a project secret scanning rule.  Project **Admin** is required
     * Edit an existing project secret scanning rule
     */
    async editRule(requestParameters: EditRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.editRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit a repository secret scanning rule.  Repository **Admin** is required
     * Edit an existing repository secret scanning rule
     */
    async editRule1Raw(requestParameters: EditRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling editRule1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling editRule1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling editRule1().'
            );
        }

        if (requestParameters['restSecretScanningRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningRuleSetRequest',
                'Required parameter "restSecretScanningRuleSetRequest" was null or undefined when calling editRule1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit a repository secret scanning rule.  Repository **Admin** is required
     * Edit an existing repository secret scanning rule
     */
    async editRule1(requestParameters: EditRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.editRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit an existing global secret scanning rule
     * Edit a global secret scanning rule.
     */
    async editRule2Raw(requestParameters: EditRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling editRule2().'
            );
        }

        if (requestParameters['restSecretScanningRuleSetRequest'] == null) {
            throw new runtime.RequiredError(
                'restSecretScanningRuleSetRequest',
                'Required parameter "restSecretScanningRuleSetRequest" was null or undefined when calling editRule2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSecretScanningRuleSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit an existing global secret scanning rule
     * Edit a global secret scanning rule.
     */
    async editRule2(requestParameters: EditRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.editRule2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find repositories exempt from secret scanning in a project
     * Find repos exempt from secret scanning for a project
     */
    async findExemptReposByProjectRaw(requestParameters: FindExemptReposByProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        const queryParameters: any = {};

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/exempt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find repositories exempt from secret scanning in a project
     * Find repos exempt from secret scanning for a project
     */
    async findExemptReposByProject(requestParameters: FindExemptReposByProjectRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.findExemptReposByProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find all repositories exempt from secret scanning
     * Find all repos exempt from secret scan
     */
    async findExemptReposByScopeRaw(requestParameters: FindExemptReposByScopeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        const queryParameters: any = {};

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/secret-scanning/exempt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find all repositories exempt from secret scanning
     * Find all repos exempt from secret scan
     */
    async findExemptReposByScope(requestParameters: FindExemptReposByScopeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.findExemptReposByScopeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all X.509 certificates that have been added to the system.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Get all X.509 certificates
     */
    async getAllCertificatesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestX509Certificate>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/signing/x509-certificates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all X.509 certificates that have been added to the system.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Get all X.509 certificates
     */
    async getAllCertificates(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestX509Certificate> {
        const response = await this.getAllCertificatesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a project secret scanning allowlist rule by ID.  Project **Admin** is required
     * Get a project secret scanning allowlist rule
     */
    async getAllowlistRuleRaw(requestParameters: GetAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAllowlistRule().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getAllowlistRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a project secret scanning allowlist rule by ID.  Project **Admin** is required
     * Get a project secret scanning allowlist rule
     */
    async getAllowlistRule(requestParameters: GetAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.getAllowlistRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a repository secret scanning allowlist rule by ID.  Repository **Admin** is required
     * Get a repository secret scanning allowlist rule
     */
    async getAllowlistRule1Raw(requestParameters: GetAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAllowlistRule1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getAllowlistRule1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAllowlistRule1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a repository secret scanning allowlist rule by ID.  Repository **Admin** is required
     * Get a repository secret scanning allowlist rule
     */
    async getAllowlistRule1(requestParameters: GetAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.getAllowlistRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of inactive AES encryption key(s). An AES key becomes inactive after it has been rotated.
     * Retrieve inactive AES key(s)
     */
    async getInactiveKeysRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/secrets/1.0/keys/inactive`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves a list of inactive AES encryption key(s). An AES key becomes inactive after it has been rotated.
     * Retrieve inactive AES key(s)
     */
    async getInactiveKeys(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getInactiveKeysRaw(initOverrides);
    }

    /**
     * Find all the keys for the currently authenticated user. Optionally, users with ADMIN and higher permissions may choose to specify the <code>user</code> parameter to retrieve GPG keys for another user.  Only authenticated users may call this endpoint.
     * Get all GPG keys
     */
    async getKeysForUserRaw(requestParameters: GetKeysForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetKeysForUser200Response>> {
        const queryParameters: any = {};

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gpg/latest/keys`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find all the keys for the currently authenticated user. Optionally, users with ADMIN and higher permissions may choose to specify the <code>user</code> parameter to retrieve GPG keys for another user.  Only authenticated users may call this endpoint.
     * Get all GPG keys
     */
    async getKeysForUser(requestParameters: GetKeysForUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetKeysForUser200Response> {
        const response = await this.getKeysForUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a project secret scanning rule by ID.  Project **Admin** is required
     * Get a project secret scanning rule
     */
    async getRuleRaw(requestParameters: GetRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRule().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a project secret scanning rule by ID.  Project **Admin** is required
     * Get a project secret scanning rule
     */
    async getRule(requestParameters: GetRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.getRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a repository secret scanning rule by ID.  Repository **Admin** is required
     * Get a repository secret scanning rule
     */
    async getRule1Raw(requestParameters: GetRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRule1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRule1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getRule1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a repository secret scanning rule by ID.  Repository **Admin** is required
     * Get a repository secret scanning rule
     */
    async getRule1(requestParameters: GetRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.getRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a global secret scanning rule by ID.
     * Get a global secret scanning rule
     */
    async getRule2Raw(requestParameters: GetRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRule2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a global secret scanning rule by ID.
     * Get a global secret scanning rule
     */
    async getRule2(requestParameters: GetRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.getRule2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the configuration details for system signing Git objects.
     * Get system signing configuration
     */
    async getSystemSigningConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSystemSigningConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/system-signing/configuration`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the configuration details for system signing Git objects.
     * Get system signing configuration
     */
    async getSystemSigningConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSystemSigningConfiguration> {
        const response = await this.getSystemSigningConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Check whether a repository is exempt from secret scanning
     * Get whether a repository is exempt
     */
    async isRepoExemptRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/exempt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Check whether a repository is exempt from secret scanning
     * Get whether a repository is exempt
     */
    async isRepoExempt(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.isRepoExemptRaw(initOverrides);
    }

    /**
     * Rotate the current AES encryption key. Existing secrets will be re-encrypted with the new key.
     * Rotate the current AES key
     */
    async rotateKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/secrets/1.0/keys/rotate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Rotate the current AES encryption key. Existing secrets will be re-encrypted with the new key.
     * Rotate the current AES key
     */
    async rotateKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rotateKeyRaw(initOverrides);
    }

    /**
     * Find project secret scanning rules by filtering.  Project **Admin** is required
     * Find project secret scanning rules
     */
    async search1Raw(requestParameters: Search1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search3200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling search1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find project secret scanning rules by filtering.  Project **Admin** is required
     * Find project secret scanning rules
     */
    async search1(requestParameters: Search1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search3200Response> {
        const response = await this.search1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find repository secret scanning allowlist rules by filtering.  Repository **Admin** is required
     * Find repository secret scanning allowlist rules
     */
    async search2Raw(requestParameters: Search2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search2200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling search2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling search2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find repository secret scanning allowlist rules by filtering.  Repository **Admin** is required
     * Find repository secret scanning allowlist rules
     */
    async search2(requestParameters: Search2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search2200Response> {
        const response = await this.search2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find repository secret scanning rules by filtering.  Repository **Admin** is required
     * Find repository secret scanning rules
     */
    async search3Raw(requestParameters: Search3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search3200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling search3().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling search3().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find repository secret scanning rules by filtering.  Repository **Admin** is required
     * Find repository secret scanning rules
     */
    async search3(requestParameters: Search3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search3200Response> {
        const response = await this.search3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find global secret scanning rules by filtering.
     * Find global secret scanning rules
     */
    async search4Raw(requestParameters: Search4Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search3200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find global secret scanning rules by filtering.
     * Find global secret scanning rules
     */
    async search4(requestParameters: Search4Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search3200Response> {
        const response = await this.search4Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find project secret scanning allowlist rules by filtering.  Project **Admin** is required
     * Find project secret scanning allowlist rules
     */
    async searchAllowlistRuleRaw(requestParameters: SearchAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search2200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling searchAllowlistRule().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find project secret scanning allowlist rules by filtering.  Project **Admin** is required
     * Find project secret scanning allowlist rules
     */
    async searchAllowlistRule(requestParameters: SearchAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search2200Response> {
        const response = await this.searchAllowlistRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the certificate revocation list (CRL) entries for an issuer X.509 certificate in the system, identified by <code>id</code>. This will add any new revoked X.509 certificates that were issued by the given issuer X.509 certificate.  This endpoint will schedule a request to asynchronously perform the task. Please allow time for the task to complete as it will vary depending on how many CRLs there are to retrieve and process.  Note: CRL updates are scheduled to run every 24 hours. You may wish to trigger a refresh manually using this endpoint, otherwise, entries will be updated daily.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Update X.509 CRL entries
     */
    async updateCertificateRevocationListEntriesRaw(requestParameters: UpdateCertificateRevocationListEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateCertificateRevocationListEntries().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/signing/x509-certificates/crl/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the certificate revocation list (CRL) entries for an issuer X.509 certificate in the system, identified by <code>id</code>. This will add any new revoked X.509 certificates that were issued by the given issuer X.509 certificate.  This endpoint will schedule a request to asynchronously perform the task. Please allow time for the task to complete as it will vary depending on how many CRLs there are to retrieve and process.  Note: CRL updates are scheduled to run every 24 hours. You may wish to trigger a refresh manually using this endpoint, otherwise, entries will be updated daily.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Update X.509 CRL entries
     */
    async updateCertificateRevocationListEntries(requestParameters: UpdateCertificateRevocationListEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateCertificateRevocationListEntriesRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the configuration for system signing Git objects.
     * Update system signing configuration
     */
    async updateSystemSigningConfigurationRaw(requestParameters: UpdateSystemSigningConfigurationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSystemSigningConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/system-signing/configuration`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['updateSystemSigningConfigurationRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the configuration for system signing Git objects.
     * Update system signing configuration
     */
    async updateSystemSigningConfiguration(requestParameters: UpdateSystemSigningConfigurationOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSystemSigningConfiguration> {
        const response = await this.updateSystemSigningConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const FindExemptReposByProjectOrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type FindExemptReposByProjectOrderEnum = typeof FindExemptReposByProjectOrderEnum[keyof typeof FindExemptReposByProjectOrderEnum];
/**
 * @export
 */
export const FindExemptReposByScopeOrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type FindExemptReposByScopeOrderEnum = typeof FindExemptReposByScopeOrderEnum[keyof typeof FindExemptReposByScopeOrderEnum];
/**
 * @export
 */
export const Search1OrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type Search1OrderEnum = typeof Search1OrderEnum[keyof typeof Search1OrderEnum];
/**
 * @export
 */
export const Search2OrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type Search2OrderEnum = typeof Search2OrderEnum[keyof typeof Search2OrderEnum];
/**
 * @export
 */
export const Search3OrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type Search3OrderEnum = typeof Search3OrderEnum[keyof typeof Search3OrderEnum];
/**
 * @export
 */
export const Search4OrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type Search4OrderEnum = typeof Search4OrderEnum[keyof typeof Search4OrderEnum];
/**
 * @export
 */
export const SearchAllowlistRuleOrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type SearchAllowlistRuleOrderEnum = typeof SearchAllowlistRuleOrderEnum[keyof typeof SearchAllowlistRuleOrderEnum];
