/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetAllAccessTokens401Response,
  GetPageOfRequiredBuildsMergeChecks200Response,
  GetReports200Response,
  RestBuildStats,
  RestBuildStatus,
  RestBuildStatusSetRequest,
  RestBulkAddInsightAnnotationRequest,
  RestDeployment,
  RestDeploymentSetRequest,
  RestInsightAnnotationsResponse,
  RestInsightReport,
  RestRequiredBuildCondition,
  RestRequiredBuildConditionSetRequest,
  RestSetInsightReportRequest,
  RestSingleAddInsightAnnotationRequest,
} from '../models/index';

interface DeleteRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    key: string;
}

interface AddRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    restBuildStatusSetRequest?: RestBuildStatusSetRequest;
}

interface AddAnnotationsRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    key: string;
    restBulkAddInsightAnnotationRequest?: RestBulkAddInsightAnnotationRequest;
}

interface CreateOrUpdateDeploymentRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    restDeploymentSetRequest?: RestDeploymentSetRequest;
}

interface CreateRequiredBuildsMergeCheckRequest {
    projectKey: string;
    repositorySlug: string;
    restRequiredBuildConditionSetRequest?: RestRequiredBuildConditionSetRequest;
}

interface Delete1Request {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    deploymentSequenceNumber?: string;
    key?: string;
    environmentKey?: string;
}

interface DeleteACodeInsightsReportRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    key: string;
}

interface DeleteAnnotationsRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    key: string;
    externalId?: string;
}

interface DeleteRequiredBuildsMergeCheckRequest {
    projectKey: string;
    id: number;
    repositorySlug: string;
}

interface GetRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    key: string;
}

interface Get1Request {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    deploymentSequenceNumber?: string;
    key?: string;
    environmentKey?: string;
}

interface GetACodeInsightsReportRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    key: string;
}

interface GetAnnotationsRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    key: string;
}

interface GetAnnotations1Request {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    severity?: string;
    path?: string;
    externalId?: string;
    type?: string;
    key?: string;
}

interface GetBuildStatusStatsRequest {
    commitId: string;
    includeUnique?: boolean;
}

interface GetMultipleBuildStatusStatsRequest {
    requestBody?: Array<string>;
}

interface GetPageOfRequiredBuildsMergeChecksRequest {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetReportsRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface SetACodeInsightsReportRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    key: string;
    restSetInsightReportRequest?: RestSetInsightReportRequest;
}

interface SetAnnotationRequest {
    projectKey: string;
    externalId: string;
    commitId: string;
    repositorySlug: string;
    key: string;
    restSingleAddInsightAnnotationRequest?: RestSingleAddInsightAnnotationRequest;
}

interface UpdateRequiredBuildsMergeCheckRequest {
    projectKey: string;
    id: number;
    repositorySlug: string;
    restRequiredBuildConditionSetRequest?: RestRequiredBuildConditionSetRequest;
}

/**
 * 
 */
export class BuildsAndDeploymentsApi extends runtime.BaseAPI {

    /**
     * Delete a specific build status.   The authenticated user must have **REPO_ADMIN** permission for the provided repository.
     * Delete a specific build status
     */
    async _deleteRaw(requestParameters: DeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling _delete().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling _delete().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling _delete().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling _delete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['key'] != null) {
            queryParameters['key'] = requestParameters['key'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/builds`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specific build status.   The authenticated user must have **REPO_ADMIN** permission for the provided repository.
     * Delete a specific build status
     */
    async _delete(requestParameters: DeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this._deleteRaw(requestParameters, initOverrides);
    }

    /**
     * Store a build status.   The authenticated user must have **REPO_READ** permission for the repository that this build status is for. The request can also be made with anonymous 2-legged OAuth.
     * Store a build status
     */
    async addRaw(requestParameters: AddRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling add().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling add().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling add().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/builds`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restBuildStatusSetRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Store a build status.   The authenticated user must have **REPO_READ** permission for the repository that this build status is for. The request can also be made with anonymous 2-legged OAuth.
     * Store a build status
     */
    async add(requestParameters: AddRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addRaw(requestParameters, initOverrides);
    }

    /**
     * Add annotations to the given report. The request should be a JSON object mapping the string \"annotations\" to an array of maps containing the annotation data, as described below. See also the example request.  A few things to note:- Annotations are an extension of a report, so a report must first exist in order to post annotations.   Annotations are posted separately from the report, and can be posted in bulk using this endpoint. - Only the annotations that are on lines changed in the unified diff will be displayed. This means it is  likely not all annotations posted will be displayed on the pull request  It also means that if the user is viewing a side-by-side diff,  commit diff or iterative review diff they will not be able to view the annotations. - A report cannot have more than 1000 annotations by default, however this property is congurable at an  instance level. If the request would result in more than the maximum number of annotations being stored  then the entire request is rejected and no new annotations are stored.  - There is no de-duplication of annotations on Bitbucket so be sure that reruns of builds will first  delete the report and annotations before creating them.  # Annotation parameters  |Parameter|Description|Required?|Restrictions|Type| |--- |--- |--- |--- |--- | |path|The path of the file on which this annotation should be placed. This is the path of the filerelative to the git repository. If no path is provided, then it will appear in the overview modalon all pull requests where the tip of the branch is the given commit, regardless of which files weremodified.|No||String| |line|The line number that the annotation should belong to. If no line number is provided, then it willdefault to 0 and in a pull request it will appear at the top of the file specified by the path field.|No|Non-negative integer|Integer| |message|The message to display to users|Yes|The maximum length accepted is 2000 characters, however the user interface may truncate this valuefor display purposes. We recommend that the message is short and succinct, with further detailsavailable to the user if needed on the page linked to by the the annotation link.|String| |severity|The severity of the annotation|Yes|One of: LOW, MEDIUM, HIGH|String| |link|An http or https URL representing the location of the annotation in the external tool|No||String| |type|The type of annotation posted|No|One of: VULNERABILITY, CODE_SMELL, BUG|String| |externalId|If the caller requires a link to get or modify this annotation, then an ID must be provided. It isnot used or required by Bitbucket, but only by the annotation creator for updating or deleting thisspecific annotation.|No|A string value shorter than 450 characters|String|
     * Add Code Insights annotations
     */
    async addAnnotationsRaw(requestParameters: AddAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addAnnotations().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling addAnnotations().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling addAnnotations().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling addAnnotations().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}/annotations`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restBulkAddInsightAnnotationRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add annotations to the given report. The request should be a JSON object mapping the string \"annotations\" to an array of maps containing the annotation data, as described below. See also the example request.  A few things to note:- Annotations are an extension of a report, so a report must first exist in order to post annotations.   Annotations are posted separately from the report, and can be posted in bulk using this endpoint. - Only the annotations that are on lines changed in the unified diff will be displayed. This means it is  likely not all annotations posted will be displayed on the pull request  It also means that if the user is viewing a side-by-side diff,  commit diff or iterative review diff they will not be able to view the annotations. - A report cannot have more than 1000 annotations by default, however this property is congurable at an  instance level. If the request would result in more than the maximum number of annotations being stored  then the entire request is rejected and no new annotations are stored.  - There is no de-duplication of annotations on Bitbucket so be sure that reruns of builds will first  delete the report and annotations before creating them.  # Annotation parameters  |Parameter|Description|Required?|Restrictions|Type| |--- |--- |--- |--- |--- | |path|The path of the file on which this annotation should be placed. This is the path of the filerelative to the git repository. If no path is provided, then it will appear in the overview modalon all pull requests where the tip of the branch is the given commit, regardless of which files weremodified.|No||String| |line|The line number that the annotation should belong to. If no line number is provided, then it willdefault to 0 and in a pull request it will appear at the top of the file specified by the path field.|No|Non-negative integer|Integer| |message|The message to display to users|Yes|The maximum length accepted is 2000 characters, however the user interface may truncate this valuefor display purposes. We recommend that the message is short and succinct, with further detailsavailable to the user if needed on the page linked to by the the annotation link.|String| |severity|The severity of the annotation|Yes|One of: LOW, MEDIUM, HIGH|String| |link|An http or https URL representing the location of the annotation in the external tool|No||String| |type|The type of annotation posted|No|One of: VULNERABILITY, CODE_SMELL, BUG|String| |externalId|If the caller requires a link to get or modify this annotation, then an ID must be provided. It isnot used or required by Bitbucket, but only by the annotation creator for updating or deleting thisspecific annotation.|No|A string value shorter than 450 characters|String|
     * Add Code Insights annotations
     */
    async addAnnotations(requestParameters: AddAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addAnnotationsRaw(requestParameters, initOverrides);
    }

    /**
     * Create or update a deployment.    The authenticated user must have REPO_READ permission for the repository.
     * Create or update a deployment
     */
    async createOrUpdateDeploymentRaw(requestParameters: CreateOrUpdateDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeployment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createOrUpdateDeployment().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling createOrUpdateDeployment().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createOrUpdateDeployment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/deployments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restDeploymentSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create or update a deployment.    The authenticated user must have REPO_READ permission for the repository.
     * Create or update a deployment
     */
    async createOrUpdateDeployment(requestParameters: CreateOrUpdateDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeployment> {
        const response = await this.createOrUpdateDeploymentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a required build merge check for the given repository.  The authenticated user must have **REPO_ADMIN** permission for the target repository to register a required build merge check.  The contents of the required build merge check request are:  These fields are **required**:  - **buildParentKeys**: A non-empty list of build parent keys that require green builds for this merge check to pass - **refMatcher.id**: The value to match refs against in the target branch - **refMatcher.type.id**: The type of ref matcher, one of: \"ANY_REF\", \"BRANCH\", \"PATTERN\", \"MODEL_CATEGORY\" or \"MODEL_BRANCH\"   These fields are optional:  - **exemptRefMatcher.id** The value to exempt refs in the source branch from this check - **exemptRefMatcher.type.id**: The type of exempt ref matcher, one of: \"ANY_REF\", \"BRANCH\", \"PATTERN\", \"MODEL_CATEGORY\" or \"MODEL_BRANCH\"   
     * Create a required builds merge check
     */
    async createRequiredBuildsMergeCheckRaw(requestParameters: CreateRequiredBuildsMergeCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRequiredBuildCondition>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createRequiredBuildsMergeCheck().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createRequiredBuildsMergeCheck().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/required-builds/latest/projects/{projectKey}/repos/{repositorySlug}/condition`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRequiredBuildConditionSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a required build merge check for the given repository.  The authenticated user must have **REPO_ADMIN** permission for the target repository to register a required build merge check.  The contents of the required build merge check request are:  These fields are **required**:  - **buildParentKeys**: A non-empty list of build parent keys that require green builds for this merge check to pass - **refMatcher.id**: The value to match refs against in the target branch - **refMatcher.type.id**: The type of ref matcher, one of: \"ANY_REF\", \"BRANCH\", \"PATTERN\", \"MODEL_CATEGORY\" or \"MODEL_BRANCH\"   These fields are optional:  - **exemptRefMatcher.id** The value to exempt refs in the source branch from this check - **exemptRefMatcher.type.id**: The type of exempt ref matcher, one of: \"ANY_REF\", \"BRANCH\", \"PATTERN\", \"MODEL_CATEGORY\" or \"MODEL_BRANCH\"   
     * Create a required builds merge check
     */
    async createRequiredBuildsMergeCheck(requestParameters: CreateRequiredBuildsMergeCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRequiredBuildCondition> {
        const response = await this.createRequiredBuildsMergeCheckRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the deployment matching the specified Repository, key, environmentKey and deploymentSequenceNumber.   The user must have REPO_ADMIN.
     * Delete a deployment
     */
    async delete1Raw(requestParameters: Delete1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling delete1().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling delete1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling delete1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['deploymentSequenceNumber'] != null) {
            queryParameters['deploymentSequenceNumber'] = requestParameters['deploymentSequenceNumber'];
        }

        if (requestParameters['key'] != null) {
            queryParameters['key'] = requestParameters['key'];
        }

        if (requestParameters['environmentKey'] != null) {
            queryParameters['environmentKey'] = requestParameters['environmentKey'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/deployments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the deployment matching the specified Repository, key, environmentKey and deploymentSequenceNumber.   The user must have REPO_ADMIN.
     * Delete a deployment
     */
    async delete1(requestParameters: Delete1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete a report for the given commit. Also deletes any annotations associated with this report.
     * Delete a Code Insights report
     */
    async deleteACodeInsightsReportRaw(requestParameters: DeleteACodeInsightsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteACodeInsightsReport().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling deleteACodeInsightsReport().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteACodeInsightsReport().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling deleteACodeInsightsReport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a report for the given commit. Also deletes any annotations associated with this report.
     * Delete a Code Insights report
     */
    async deleteACodeInsightsReport(requestParameters: DeleteACodeInsightsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteACodeInsightsReportRaw(requestParameters, initOverrides);
    }

    /**
     * Delete annotations for a given report that match the given external IDs, or all annotations if no external IDs are provided.
     * Delete Code Insights annotations
     */
    async deleteAnnotationsRaw(requestParameters: DeleteAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteAnnotations().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling deleteAnnotations().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteAnnotations().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling deleteAnnotations().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['externalId'] != null) {
            queryParameters['externalId'] = requestParameters['externalId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}/annotations`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete annotations for a given report that match the given external IDs, or all annotations if no external IDs are provided.
     * Delete Code Insights annotations
     */
    async deleteAnnotations(requestParameters: DeleteAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAnnotationsRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a required build existing merge check, given it\'s ID.  The authenticated user must have **REPO_ADMIN** permission for the target repository to delete a required build merge check.
     * Delete a required builds merge check
     */
    async deleteRequiredBuildsMergeCheckRaw(requestParameters: DeleteRequiredBuildsMergeCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteRequiredBuildsMergeCheck().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteRequiredBuildsMergeCheck().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteRequiredBuildsMergeCheck().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/required-builds/latest/projects/{projectKey}/repos/{repositorySlug}/condition/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a required build existing merge check, given it\'s ID.  The authenticated user must have **REPO_ADMIN** permission for the target repository to delete a required build merge check.
     * Delete a required builds merge check
     */
    async deleteRequiredBuildsMergeCheck(requestParameters: DeleteRequiredBuildsMergeCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRequiredBuildsMergeCheckRaw(requestParameters, initOverrides);
    }

    /**
     * Get a specific build status.   The authenticated user must have **REPO_READ** permission for the provided repository.The request can also be made with anonymous 2-legged OAuth.<br>Since 7.14
     * Get a specific build status
     */
    async getRaw(requestParameters: GetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBuildStatus>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling get().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling get().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling get().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling get().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['key'] != null) {
            queryParameters['key'] = requestParameters['key'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/builds`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a specific build status.   The authenticated user must have **REPO_READ** permission for the provided repository.The request can also be made with anonymous 2-legged OAuth.<br>Since 7.14
     * Get a specific build status
     */
    async get(requestParameters: GetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBuildStatus> {
        const response = await this.getRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the deployment matching the specified Repository, key, environmentKey and deploymentSequenceNumber.   The user must have REPO_READ.
     * Get a deployment
     */
    async get1Raw(requestParameters: Get1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeployment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling get1().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling get1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling get1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['deploymentSequenceNumber'] != null) {
            queryParameters['deploymentSequenceNumber'] = requestParameters['deploymentSequenceNumber'];
        }

        if (requestParameters['key'] != null) {
            queryParameters['key'] = requestParameters['key'];
        }

        if (requestParameters['environmentKey'] != null) {
            queryParameters['environmentKey'] = requestParameters['environmentKey'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/deployments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the deployment matching the specified Repository, key, environmentKey and deploymentSequenceNumber.   The user must have REPO_READ.
     * Get a deployment
     */
    async get1(requestParameters: Get1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeployment> {
        const response = await this.get1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the specified report.
     * Get a Code Insights report
     */
    async getACodeInsightsReportRaw(requestParameters: GetACodeInsightsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestInsightReport>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getACodeInsightsReport().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getACodeInsightsReport().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getACodeInsightsReport().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling getACodeInsightsReport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the specified report.
     * Get a Code Insights report
     */
    async getACodeInsightsReport(requestParameters: GetACodeInsightsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestInsightReport> {
        const response = await this.getACodeInsightsReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the specified report\'s annotations.
     * Get Code Insights annotations for a report
     */
    async getAnnotationsRaw(requestParameters: GetAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestInsightAnnotationsResponse>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAnnotations().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getAnnotations().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAnnotations().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling getAnnotations().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}/annotations`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the specified report\'s annotations.
     * Get Code Insights annotations for a report
     */
    async getAnnotations(requestParameters: GetAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestInsightAnnotationsResponse> {
        const response = await this.getAnnotationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get annotations for the given commit ID, filtered by any query parameters given.
     * Get Code Insights annotations for a commit
     */
    async getAnnotations1Raw(requestParameters: GetAnnotations1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestInsightAnnotationsResponse>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAnnotations1().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getAnnotations1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAnnotations1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['severity'] != null) {
            queryParameters['severity'] = requestParameters['severity'];
        }

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['externalId'] != null) {
            queryParameters['externalId'] = requestParameters['externalId'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['key'] != null) {
            queryParameters['key'] = requestParameters['key'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/annotations`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get annotations for the given commit ID, filtered by any query parameters given.
     * Get Code Insights annotations for a commit
     */
    async getAnnotations1(requestParameters: GetAnnotations1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestInsightAnnotationsResponse> {
        const response = await this.getAnnotations1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets statistics regarding the builds associated with a commit
     * Get build status statistics for commit
     */
    async getBuildStatusStatsRaw(requestParameters: GetBuildStatusStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBuildStats>> {
        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getBuildStatusStats().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['includeUnique'] != null) {
            queryParameters['includeUnique'] = requestParameters['includeUnique'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/build-status/latest/commits/stats/{commitId}`.replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets statistics regarding the builds associated with a commit
     * Get build status statistics for commit
     */
    async getBuildStatusStats(requestParameters: GetBuildStatusStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBuildStats> {
        const response = await this.getBuildStatusStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Produces a list of the build statistics for multiple commits. Commits <em>without any builds associated with them</em> will not be returned.<br> For example if the commit <code>e00cf62997a027bbf785614a93e2e55bb331d268</code> does not have any build statuses associated with it, it will not be present in the response.
     * Get build status statistics for multiple commits
     */
    async getMultipleBuildStatusStatsRaw(requestParameters: GetMultipleBuildStatusStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/build-status/latest/commits/stats`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Produces a list of the build statistics for multiple commits. Commits <em>without any builds associated with them</em> will not be returned.<br> For example if the commit <code>e00cf62997a027bbf785614a93e2e55bb331d268</code> does not have any build statuses associated with it, it will not be present in the response.
     * Get build status statistics for multiple commits
     */
    async getMultipleBuildStatusStats(requestParameters: GetMultipleBuildStatusStatsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getMultipleBuildStatusStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a page of required build merge checks that have been configured for this repository.  The authenticated user must have **REPO_READ** permission for the target repository to request a page of required build merge checks.
     * Get required builds merge checks
     */
    async getPageOfRequiredBuildsMergeChecksRaw(requestParameters: GetPageOfRequiredBuildsMergeChecksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPageOfRequiredBuildsMergeChecks200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPageOfRequiredBuildsMergeChecks().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getPageOfRequiredBuildsMergeChecks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/required-builds/latest/projects/{projectKey}/repos/{repositorySlug}/conditions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a page of required build merge checks that have been configured for this repository.  The authenticated user must have **REPO_READ** permission for the target repository to request a page of required build merge checks.
     * Get required builds merge checks
     */
    async getPageOfRequiredBuildsMergeChecks(requestParameters: GetPageOfRequiredBuildsMergeChecksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPageOfRequiredBuildsMergeChecks200Response> {
        const response = await this.getPageOfRequiredBuildsMergeChecksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all reports for the given commit.
     * Get all Code Insights reports for a commit
     */
    async getReportsRaw(requestParameters: GetReportsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetReports200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getReports().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getReports().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getReports().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve all reports for the given commit.
     * Get all Code Insights reports for a commit
     */
    async getReports(requestParameters: GetReportsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetReports200Response> {
        const response = await this.getReportsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new insight report, or replace the existing one if a report already exists for the given repository, commit, and report key. A request to replace an existing report will be rejected if the authenticated user was not the creator of the specified report.  The report key should be a unique string chosen by the reporter and should be unique enough not to potentially clash with report keys from other reporters. We recommend using reverse DNS namespacing or a similar standard to ensure that collision is avoided.<h1>Report parameters</h1><table summary=\"Report parameters\">    <tr>        <th>Parameter</th>        <th>Description</th>        <th>Required?</th>        <th>Restrictions</th>        <th>Type</th>    </tr>    <tr>        <td>title</td>        <td>A short string representing the name of the report</td>        <td>Yes</td>        <td>Max length: 450 characters (but we recommend that it is shorter so that the display is nicer)</td>        <td>String</td>    </tr>    <tr>        <td>details</td>        <td>             A string to describe the purpose of the report. This string may contain             escaped newlines and if it does it will display the content accordingly.        </td>        <td>No</td>        <td>Max length: 2000 characters</td>        <td>String</td>    </tr>    <tr>        <td>result</td>        <td>Indicates whether the report is in a passed or failed state</td>        <td>No</td>        <td>One of: PASS, FAIL</td>        <td>String</td>    </tr>    <tr>        <td>data</td>        <td>An array of data fields (described below) to display information on the report</td>        <td>No</td>        <td>Maximum 6 data fields</td>        <td>Array</td>    </tr>    <tr>        <td>reporter</td>        <td>A string to describe the tool or company who created the report</td>        <td>No</td>        <td>Max length: 450 characters</td>        <td>String</td>    </tr>    <tr>        <td>link</td>        <td>A URL linking to the results of the report in an external tool.</td>        <td>No</td>        <td>Must be a valid http or https URL</td>        <td>String</td>    </tr>    <tr>        <td>logoUrl</td>        <td>A URL to the report logo. If none is provided, the default insights logo will be used.</td>        <td>No</td>        <td>Must be a valid http or https URL</td>        <td>String</td>    </tr></table><h1>Data parameters</h1>The data field on the report is an array with at most 6 data fields (JSON maps) containing information that is to be displayed on the report (see the request example).<table summary=\"Data parameters\">    <tr>        <th>Parameter</th>        <th>Description</th>        <th>Type</th>    </tr>    <tr>        <td>title</td>        <td>A string describing what this data field represents</td>        <td>String</td>    </tr>    <tr>        <td>type</td>        <td>             The type of data contained in the value field. If not provided,             then the value will be detected as a boolean, number or string.             One of: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT        </td>        <td>String</td>    </tr>    <tr>        <td>value</td>        <td>            A value based on the type provided. Either a raw value             (string, number or boolean) or a map. See below.        </td>    </tr></table><table summary=\"Types\">    <tr>        <th>Type Field</th>        <th>Value Field Type</th>        <th>Value Field Display</th>    </tr>    <tr>        <td>None/Omitted</td>        <td>Number, String or Boolean (not an array or object)</td>        <td>Plain text</td>    </tr>    <tr>        <td>BOOLEAN</td>        <td>Boolean</td>        <td>The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'.</td>    </tr>    <tr>        <td>DATE</td>        <td>Number</td>        <td>             The value will be read as a JSON number in the form of a Unix timestamp              (milliseconds) and will be displayed as a relative date if the date is less             than one week ago, otherwise it will be displayed as an absolute date.        </td>    </tr>    <tr>        <td>DURATION</td>        <td>Number</td>        <td>             The value will be read as a JSON number in milliseconds and             will be displayed in a human readable duration format.        </td>    </tr>    <tr>        <td>LINK</td>        <td>Object: {\"linktext\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}</td>        <td>             The value will be read as a JSON object containing the fields \"linktext\"             and \"href\" and will be displayed as a clickable link on the report.        </td>    </tr>    <tr>        <td>NUMBER</td>        <td>Number</td>        <td>             The value will be read as a JSON number and large numbers will             be displayed in a human readable format (e.g. 14.3k).        </td>    </tr>    <tr>        <td>PERCENTAGE</td>        <td>Number (between 0 and 100)</td>        <td>             The value will be read as a JSON number between 0 and 100              and will be displayed with a percentage sign.        </td>    </tr>    <tr>        <td>TEXT</td>        <td>String</td>        <td>The value will be read as a JSON string and will be displayed as-is</td>    </tr></table>
     * Create a Code Insights report
     */
    async setACodeInsightsReportRaw(requestParameters: SetACodeInsightsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestInsightReport>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setACodeInsightsReport().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling setACodeInsightsReport().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setACodeInsightsReport().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling setACodeInsightsReport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSetInsightReportRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new insight report, or replace the existing one if a report already exists for the given repository, commit, and report key. A request to replace an existing report will be rejected if the authenticated user was not the creator of the specified report.  The report key should be a unique string chosen by the reporter and should be unique enough not to potentially clash with report keys from other reporters. We recommend using reverse DNS namespacing or a similar standard to ensure that collision is avoided.<h1>Report parameters</h1><table summary=\"Report parameters\">    <tr>        <th>Parameter</th>        <th>Description</th>        <th>Required?</th>        <th>Restrictions</th>        <th>Type</th>    </tr>    <tr>        <td>title</td>        <td>A short string representing the name of the report</td>        <td>Yes</td>        <td>Max length: 450 characters (but we recommend that it is shorter so that the display is nicer)</td>        <td>String</td>    </tr>    <tr>        <td>details</td>        <td>             A string to describe the purpose of the report. This string may contain             escaped newlines and if it does it will display the content accordingly.        </td>        <td>No</td>        <td>Max length: 2000 characters</td>        <td>String</td>    </tr>    <tr>        <td>result</td>        <td>Indicates whether the report is in a passed or failed state</td>        <td>No</td>        <td>One of: PASS, FAIL</td>        <td>String</td>    </tr>    <tr>        <td>data</td>        <td>An array of data fields (described below) to display information on the report</td>        <td>No</td>        <td>Maximum 6 data fields</td>        <td>Array</td>    </tr>    <tr>        <td>reporter</td>        <td>A string to describe the tool or company who created the report</td>        <td>No</td>        <td>Max length: 450 characters</td>        <td>String</td>    </tr>    <tr>        <td>link</td>        <td>A URL linking to the results of the report in an external tool.</td>        <td>No</td>        <td>Must be a valid http or https URL</td>        <td>String</td>    </tr>    <tr>        <td>logoUrl</td>        <td>A URL to the report logo. If none is provided, the default insights logo will be used.</td>        <td>No</td>        <td>Must be a valid http or https URL</td>        <td>String</td>    </tr></table><h1>Data parameters</h1>The data field on the report is an array with at most 6 data fields (JSON maps) containing information that is to be displayed on the report (see the request example).<table summary=\"Data parameters\">    <tr>        <th>Parameter</th>        <th>Description</th>        <th>Type</th>    </tr>    <tr>        <td>title</td>        <td>A string describing what this data field represents</td>        <td>String</td>    </tr>    <tr>        <td>type</td>        <td>             The type of data contained in the value field. If not provided,             then the value will be detected as a boolean, number or string.             One of: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT        </td>        <td>String</td>    </tr>    <tr>        <td>value</td>        <td>            A value based on the type provided. Either a raw value             (string, number or boolean) or a map. See below.        </td>    </tr></table><table summary=\"Types\">    <tr>        <th>Type Field</th>        <th>Value Field Type</th>        <th>Value Field Display</th>    </tr>    <tr>        <td>None/Omitted</td>        <td>Number, String or Boolean (not an array or object)</td>        <td>Plain text</td>    </tr>    <tr>        <td>BOOLEAN</td>        <td>Boolean</td>        <td>The value will be read as a JSON boolean and displayed as \'Yes\' or \'No\'.</td>    </tr>    <tr>        <td>DATE</td>        <td>Number</td>        <td>             The value will be read as a JSON number in the form of a Unix timestamp              (milliseconds) and will be displayed as a relative date if the date is less             than one week ago, otherwise it will be displayed as an absolute date.        </td>    </tr>    <tr>        <td>DURATION</td>        <td>Number</td>        <td>             The value will be read as a JSON number in milliseconds and             will be displayed in a human readable duration format.        </td>    </tr>    <tr>        <td>LINK</td>        <td>Object: {\"linktext\": \"Link text here\", \"href\": \"https://link.to.annotation/in/external/tool\"}</td>        <td>             The value will be read as a JSON object containing the fields \"linktext\"             and \"href\" and will be displayed as a clickable link on the report.        </td>    </tr>    <tr>        <td>NUMBER</td>        <td>Number</td>        <td>             The value will be read as a JSON number and large numbers will             be displayed in a human readable format (e.g. 14.3k).        </td>    </tr>    <tr>        <td>PERCENTAGE</td>        <td>Number (between 0 and 100)</td>        <td>             The value will be read as a JSON number between 0 and 100              and will be displayed with a percentage sign.        </td>    </tr>    <tr>        <td>TEXT</td>        <td>String</td>        <td>The value will be read as a JSON string and will be displayed as-is</td>    </tr></table>
     * Create a Code Insights report
     */
    async setACodeInsightsReport(requestParameters: SetACodeInsightsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestInsightReport> {
        const response = await this.setACodeInsightsReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an annotation with the given external ID, or replace it if it already exists. A request to replace an existing annotation will be rejected if the authenticated user was not the creator of the specified report.
     * Create or replace a Code Insights annotation
     */
    async setAnnotationRaw(requestParameters: SetAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setAnnotation().'
            );
        }

        if (requestParameters['externalId'] == null) {
            throw new runtime.RequiredError(
                'externalId',
                'Required parameter "externalId" was null or undefined when calling setAnnotation().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling setAnnotation().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setAnnotation().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling setAnnotation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/insights/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/reports/{key}/annotations/{externalId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"externalId"}}`, encodeURIComponent(String(requestParameters['externalId']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSingleAddInsightAnnotationRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create an annotation with the given external ID, or replace it if it already exists. A request to replace an existing annotation will be rejected if the authenticated user was not the creator of the specified report.
     * Create or replace a Code Insights annotation
     */
    async setAnnotation(requestParameters: SetAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setAnnotationRaw(requestParameters, initOverrides);
    }

    /**
     * Update the required builds merge check for the given ID.  The authenticated user must have **REPO_ADMIN** permission for the target repository to update a required build merge check.  The contents of the required build merge check request are:  These fields are **required**:  - **buildParentKeys**: A non-empty list of build parent keys that require green builds for this merge check to pass - **refMatcher.id**: The value to match refs against in the target branch - **refMatcher.type.id**: The type of ref matcher, one of: \"ANY_REF\", \"BRANCH\", \"PATTERN\", \"MODEL_CATEGORY\" or \"MODEL_BRANCH\"   These fields are optional:  - **exemptRefMatcher.id** The value to exempt refs in the source branch from this check - **exemptRefMatcher.type.id**: The type of exempt ref matcher, one of: \"ANY_REF\", \"BRANCH\", \"PATTERN\", \"MODEL_CATEGORY\" or \"MODEL_BRANCH\"   
     * Update a required builds merge check
     */
    async updateRequiredBuildsMergeCheckRaw(requestParameters: UpdateRequiredBuildsMergeCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRequiredBuildCondition>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateRequiredBuildsMergeCheck().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateRequiredBuildsMergeCheck().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateRequiredBuildsMergeCheck().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/required-builds/latest/projects/{projectKey}/repos/{repositorySlug}/condition/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRequiredBuildConditionSetRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the required builds merge check for the given ID.  The authenticated user must have **REPO_ADMIN** permission for the target repository to update a required build merge check.  The contents of the required build merge check request are:  These fields are **required**:  - **buildParentKeys**: A non-empty list of build parent keys that require green builds for this merge check to pass - **refMatcher.id**: The value to match refs against in the target branch - **refMatcher.type.id**: The type of ref matcher, one of: \"ANY_REF\", \"BRANCH\", \"PATTERN\", \"MODEL_CATEGORY\" or \"MODEL_BRANCH\"   These fields are optional:  - **exemptRefMatcher.id** The value to exempt refs in the source branch from this check - **exemptRefMatcher.type.id**: The type of exempt ref matcher, one of: \"ANY_REF\", \"BRANCH\", \"PATTERN\", \"MODEL_CATEGORY\" or \"MODEL_BRANCH\"   
     * Update a required builds merge check
     */
    async updateRequiredBuildsMergeCheck(requestParameters: UpdateRequiredBuildsMergeCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRequiredBuildCondition> {
        const response = await this.updateRequiredBuildsMergeCheckRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
