/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetActivities200Response,
  GetAllAccessTokens401Response,
  GetComments200Response,
  GetCommits200Response,
  GetPullRequests1200Response,
  GetReviewerGroups1200Response,
  GetUsersWithoutAnyPermission200Response,
  ListParticipants200Response,
  RestApplicationUser,
  RestApplySuggestionRequest,
  RestAutoMergeProcessingResult,
  RestAutoMergeRequest,
  RestChange,
  RestComment,
  RestCommit,
  RestCommitMessageSuggestion,
  RestDefaultReviewersRequest,
  RestDiff,
  RestErrors,
  RestPullRequest,
  RestPullRequestAssignParticipantRoleRequest,
  RestPullRequestAssignStatusRequest,
  RestPullRequestCondition,
  RestPullRequestDeclineRequest,
  RestPullRequestDeleteRequest,
  RestPullRequestFinishReviewRequest,
  RestPullRequestMergeConfig,
  RestPullRequestMergeRequest,
  RestPullRequestMergeability,
  RestPullRequestParticipant,
  RestPullRequestRebaseRequest,
  RestPullRequestRebaseResult,
  RestPullRequestRebaseability,
  RestPullRequestReopenRequest,
  RestPullRequestSettings,
  RestReviewerGroup,
  RestUserReaction,
  UpdatePullRequestCondition1Request,
} from '../models/index';

interface ApplySuggestionRequest {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    repositorySlug: string;
    restApplySuggestionRequest?: RestApplySuggestionRequest;
}

interface ApproveRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface AssignParticipantRoleRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    restPullRequestAssignParticipantRoleRequest: RestPullRequestAssignParticipantRoleRequest;
}

interface CanMergeRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface CanRebaseRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface CancelAutoMergeRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface CreateRequest {
    projectKey: string;
    repositorySlug: string;
    restPullRequest?: RestPullRequest;
}

interface Create1Request {
    projectKey: string;
    restReviewerGroup?: RestReviewerGroup;
}

interface Create2Request {
    projectKey: string;
    repositorySlug: string;
    restReviewerGroup?: RestReviewerGroup;
}

interface CreateComment1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    restComment?: Omit<RestComment, 'anchored'|'comments'|'createdDate'|'html'|'pending'|'reply'|'resolvedDate'|'threadResolvedDate'|'updatedDate'>;
}

interface CreateComment2Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    restComment?: Omit<RestComment, 'anchored'|'comments'|'createdDate'|'html'|'pending'|'reply'|'resolvedDate'|'threadResolvedDate'|'updatedDate'>;
}

interface CreatePullRequestConditionRequest {
    projectKey: string;
    restDefaultReviewersRequest?: RestDefaultReviewersRequest;
}

interface CreatePullRequestCondition1Request {
    projectKey: string;
    repositorySlug: string;
    restDefaultReviewersRequest?: RestDefaultReviewersRequest;
}

interface DeclineRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    version?: string;
    restPullRequestDeclineRequest?: RestPullRequestDeclineRequest;
}

interface Delete3Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    restPullRequestDeleteRequest?: RestPullRequestDeleteRequest;
}

interface Delete6Request {
    projectKey: string;
    id: string;
}

interface Delete7Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface DeleteComment1Request {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    repositorySlug: string;
    version?: string;
}

interface DeleteComment2Request {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    repositorySlug: string;
    version?: string;
}

interface DeletePullRequestConditionRequest {
    projectKey: string;
    id: string;
}

interface DeletePullRequestCondition1Request {
    projectKey: string;
    id: number;
    repositorySlug: string;
}

interface DiscardReviewRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface FinishReviewRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    version?: string;
    restPullRequestFinishReviewRequest?: RestPullRequestFinishReviewRequest;
}

interface Get3Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface GetActivitiesRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    fromType?: string;
    fromId?: string;
    start?: number;
    limit?: number;
}

interface GetAutoMergeRequestRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface GetComment1Request {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface GetComment2Request {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface GetComments1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    count?: string;
    state?: Array<string>;
    states?: string;
    start?: number;
    limit?: number;
}

interface GetComments2Request {
    path: string;
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    fromHash?: string;
    anchorState?: string;
    diffType?: Array<string>;
    toHash?: string;
    state?: Array<string>;
    diffTypes?: string;
    states?: string;
    start?: number;
    limit?: number;
}

interface GetCommitMessageSuggestionRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface GetCommits1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    avatarScheme?: string;
    withCounts?: string;
    avatarSize?: string;
    start?: number;
    limit?: number;
}

interface GetDiffStatsSummary2Request {
    path: string;
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    sinceId?: string;
    srcPath?: string;
    untilId?: string;
    whitespace?: string;
}

interface GetMergeBase1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface GetMergeConfigRequest {
    scmId: string;
}

interface GetPageRequest {
    projectKey: string;
    repositorySlug: string;
    withAttributes?: string;
    at?: string;
    withProperties?: string;
    draft?: string;
    filterText?: string;
    state?: string;
    order?: string;
    direction?: string;
    start?: number;
    limit?: number;
}

interface GetPullRequestConditionsRequest {
    projectKey: string;
}

interface GetPullRequestConditions1Request {
    projectKey: string;
    repositorySlug: string;
}

interface GetPullRequestsRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetReviewRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetReviewerGroupRequest {
    projectKey: string;
    id: string;
}

interface GetReviewerGroup1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface GetReviewerGroupsRequest {
    projectKey: string;
    start?: number;
    limit?: number;
}

interface GetReviewerGroups1Request {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetReviewersRequest {
    projectKey: string;
    repositorySlug: string;
    targetRepoId?: string;
    sourceRepoId?: string;
    sourceRefId?: string;
    targetRefId?: string;
}

interface GetUsersRequest {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface ListParticipantsRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface MergeRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    version?: string;
    restPullRequestMergeRequest?: RestPullRequestMergeRequest;
}

interface React1Request {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    emoticon: string;
    repositorySlug: string;
}

interface RebaseRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    restPullRequestRebaseRequest?: RestPullRequestRebaseRequest;
}

interface ReopenRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    version?: string;
    restPullRequestReopenRequest?: RestPullRequestReopenRequest;
}

interface SearchRequest {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    role?: string;
    direction?: string;
    start?: number;
    limit?: number;
}

interface SetMergeConfigRequest {
    scmId: string;
    restPullRequestSettings?: RestPullRequestSettings;
}

interface StreamChanges1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    sinceId?: string;
    changeScope?: string;
    untilId?: string;
    withComments?: string;
    start?: number;
    limit?: number;
}

interface StreamDiff2Request {
    path: string;
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    avatarScheme?: string;
    contextLines?: string;
    sinceId?: string;
    srcPath?: string;
    diffType?: string;
    untilId?: string;
    whitespace?: string;
    withComments?: string;
    avatarSize?: string;
}

interface StreamPatch1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface StreamRawDiff2Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    contextLines?: string;
    whitespace?: string;
}

interface TryAutoMergeRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface UnReact1Request {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    emoticon: string;
    repositorySlug: string;
}

interface UnassignParticipantRoleRequest {
    projectKey: string;
    userSlug: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface UnassignParticipantRole1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    username?: string;
}

interface Unwatch1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface UpdateRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
    restPullRequest?: RestPullRequest;
}

interface Update1Request {
    projectKey: string;
    id: string;
    restReviewerGroup?: RestReviewerGroup;
}

interface Update2Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
    restReviewerGroup?: RestReviewerGroup;
}

interface UpdateComment1Request {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    repositorySlug: string;
    restComment?: Omit<RestComment, 'anchored'|'comments'|'createdDate'|'html'|'pending'|'reply'|'resolvedDate'|'threadResolvedDate'|'updatedDate'>;
}

interface UpdateComment2Request {
    projectKey: string;
    commentId: string;
    pullRequestId: string;
    repositorySlug: string;
    restComment?: Omit<RestComment, 'anchored'|'comments'|'createdDate'|'html'|'pending'|'reply'|'resolvedDate'|'threadResolvedDate'|'updatedDate'>;
}

interface UpdatePullRequestConditionRequest {
    projectKey: string;
    id: string;
    restDefaultReviewersRequest?: RestDefaultReviewersRequest;
}

interface UpdatePullRequestCondition1OperationRequest {
    projectKey: string;
    id: string;
    repositorySlug: string;
    updatePullRequestCondition1Request?: UpdatePullRequestCondition1Request;
}

interface UpdateStatusRequest {
    projectKey: string;
    userSlug: string;
    pullRequestId: string;
    repositorySlug: string;
    restPullRequestAssignStatusRequest: RestPullRequestAssignStatusRequest;
    version?: string;
}

interface Watch1Request {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

interface WithdrawApprovalRequest {
    projectKey: string;
    pullRequestId: string;
    repositorySlug: string;
}

/**
 * 
 */
export class PullRequestsApi extends runtime.BaseAPI {

    /**
     * Apply a suggestion contained within a comment.
     * Apply pull request suggestion
     */
    async applySuggestionRaw(requestParameters: ApplySuggestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling applySuggestion().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling applySuggestion().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling applySuggestion().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling applySuggestion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}/apply-suggestion`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restApplySuggestionRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Apply a suggestion contained within a comment.
     * Apply pull request suggestion
     */
    async applySuggestion(requestParameters: ApplySuggestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.applySuggestionRaw(requestParameters, initOverrides);
    }

    /**
     * Approve a pull request as the current user. Implicitly adds the user as a participant if they are not already.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.   <strong>Deprecated since 4.2</strong>. Use /rest/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants/{userSlug} instead
     * Approve pull request
     * @deprecated
     */
    async approveRaw(requestParameters: ApproveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestParticipant>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling approve().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling approve().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling approve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/approve`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Approve a pull request as the current user. Implicitly adds the user as a participant if they are not already.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.   <strong>Deprecated since 4.2</strong>. Use /rest/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants/{userSlug} instead
     * Approve pull request
     * @deprecated
     */
    async approve(requestParameters: ApproveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestParticipant> {
        const response = await this.approveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assigns a participant to an explicit role in pull request. Currently only the REVIEWER role may be assigned.   If the user is not yet a participant in the pull request, they are made one and assigned the supplied role.   If the user is already a participant in the pull request, their previous role is replaced with the supplied role unless they are already assigned the AUTHOR role which cannot be changed and will result in a Bad Request (400) response code.   The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Assign pull request participant role
     */
    async assignParticipantRoleRaw(requestParameters: AssignParticipantRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestParticipant>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling assignParticipantRole().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling assignParticipantRole().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling assignParticipantRole().'
            );
        }

        if (requestParameters['restPullRequestAssignParticipantRoleRequest'] == null) {
            throw new runtime.RequiredError(
                'restPullRequestAssignParticipantRoleRequest',
                'Required parameter "restPullRequestAssignParticipantRoleRequest" was null or undefined when calling assignParticipantRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestAssignParticipantRoleRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Assigns a participant to an explicit role in pull request. Currently only the REVIEWER role may be assigned.   If the user is not yet a participant in the pull request, they are made one and assigned the supplied role.   If the user is already a participant in the pull request, their previous role is replaced with the supplied role unless they are already assigned the AUTHOR role which cannot be changed and will result in a Bad Request (400) response code.   The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Assign pull request participant role
     */
    async assignParticipantRole(requestParameters: AssignParticipantRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestParticipant> {
        const response = await this.assignParticipantRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Test whether a pull request can be merged.   A pull request may not be merged if:   - there are conflicts that need to be manually resolved before merging; and/or - one or more merge checks have vetoed the merge.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Test if pull request can be merged
     */
    async canMergeRaw(requestParameters: CanMergeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestMergeability>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling canMerge().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling canMerge().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling canMerge().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Test whether a pull request can be merged.   A pull request may not be merged if:   - there are conflicts that need to be manually resolved before merging; and/or - one or more merge checks have vetoed the merge.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Test if pull request can be merged
     */
    async canMerge(requestParameters: CanMergeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestMergeability> {
        const response = await this.canMergeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Checks preconditions to determine whether the pull request can be rebased.  Some of the preconditions are:  - The pull request is between Git repositories - The pull request is currently open - The pull request\'s {@link PullRequest#getFromRef \"from\" ref} is a <i>branch</i>    - In other words, the qualified ID for the \"from\" ref must start with <code>refs/heads/</code>    - Tags, and other non-standard refs, cannot be rebased - The current user has an e-mail address    - Pull requests cannot be rebased anonymously    - `git rebase` records the current user as the committer for the rebased commits, which        requires a name and e-mail address - The current user has <i>write</i> access to the {@link PullRequest#getFromRef \"from\" ref}\'s repository    - Note that in order to <i>view</i> a pull request a user is only required to have <i>read</i>      access to the {@link PullRequest#getToRef toRef}\'s repository, so just because a user can <i>see</i>      a pull request does not mean they can request a rebase   This list is not exhaustive, and the exact set of preconditions applied can be extended by third-party add-ons.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Check PR rebase precondition
     */
    async canRebaseRaw(requestParameters: CanRebaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestRebaseability>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling canRebase().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling canRebase().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling canRebase().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/git/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/rebase`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Checks preconditions to determine whether the pull request can be rebased.  Some of the preconditions are:  - The pull request is between Git repositories - The pull request is currently open - The pull request\'s {@link PullRequest#getFromRef \"from\" ref} is a <i>branch</i>    - In other words, the qualified ID for the \"from\" ref must start with <code>refs/heads/</code>    - Tags, and other non-standard refs, cannot be rebased - The current user has an e-mail address    - Pull requests cannot be rebased anonymously    - `git rebase` records the current user as the committer for the rebased commits, which        requires a name and e-mail address - The current user has <i>write</i> access to the {@link PullRequest#getFromRef \"from\" ref}\'s repository    - Note that in order to <i>view</i> a pull request a user is only required to have <i>read</i>      access to the {@link PullRequest#getToRef toRef}\'s repository, so just because a user can <i>see</i>      a pull request does not mean they can request a rebase   This list is not exhaustive, and the exact set of preconditions applied can be extended by third-party add-ons.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Check PR rebase precondition
     */
    async canRebase(requestParameters: CanRebaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestRebaseability> {
        const response = await this.canRebaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancels a request to auto-merge the pull request, if the pull request was not merged yet.  The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Cancel auto-merge for pull request
     */
    async cancelAutoMergeRaw(requestParameters: CancelAutoMergeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling cancelAutoMerge().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling cancelAutoMerge().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling cancelAutoMerge().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/auto-merge`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancels a request to auto-merge the pull request, if the pull request was not merged yet.  The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Cancel auto-merge for pull request
     */
    async cancelAutoMerge(requestParameters: CancelAutoMergeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cancelAutoMergeRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new pull request from a source branch or tag to a target branch. The source and target may be in the same repository, or different ones. (Note that different repositories must belong to the same <code>Repository#getHierarchyId()</code> hierarchy.)   The <code>fromRef</code> may be a branch or a tag. The <code>toRef</code> is required to be a branch. Tags are not allowed as targets because tags are intended to be immutable and should not be changed after they are created.   The authenticated user must have <strong>REPO_READ</strong> permission for the <code>fromRef</code> and <code>toRef</code> repositories to call this resource.
     * Create pull request
     */
    async createRaw(requestParameters: CreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequest>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling create().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling create().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new pull request from a source branch or tag to a target branch. The source and target may be in the same repository, or different ones. (Note that different repositories must belong to the same <code>Repository#getHierarchyId()</code> hierarchy.)   The <code>fromRef</code> may be a branch or a tag. The <code>toRef</code> is required to be a branch. Tags are not allowed as targets because tags are intended to be immutable and should not be changed after they are created.   The authenticated user must have <strong>REPO_READ</strong> permission for the <code>fromRef</code> and <code>toRef</code> repositories to call this resource.
     * Create pull request
     */
    async create(requestParameters: CreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequest> {
        const response = await this.createRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a reviewer group.  The authenticated user must have <b>PROJECT_ADMIN</b> permission for the specified project to call this resource.
     * Create reviewer group
     */
    async create1Raw(requestParameters: Create1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestReviewerGroup>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling create1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/reviewer-groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restReviewerGroup'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a reviewer group.  The authenticated user must have <b>PROJECT_ADMIN</b> permission for the specified project to call this resource.
     * Create reviewer group
     */
    async create1(requestParameters: Create1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestReviewerGroup> {
        const response = await this.create1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a reviewer group.  The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository to call this resource.
     * Create reviewer group
     */
    async create2Raw(requestParameters: Create2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestReviewerGroup>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling create2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling create2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/reviewer-groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restReviewerGroup'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a reviewer group.  The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository to call this resource.
     * Create reviewer group
     */
    async create2(requestParameters: Create2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestReviewerGroup> {
        const response = await this.create2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new blocker comment.   Comments can be added in a few places by setting different attributes:   General pull request blocker comment:  ```  {       \"text\": \"A task on a pull request.\"  } ```  Blocker reply to a comment:   ```  {      \"text\": \"This reply is a task.\",       \"parent\": {           \"id\": 1       }  }  ```  General blocker file comment:  ```  {      \"text\": \"A blocker comment on a file.\",       \"anchor\": {           \"diffType\": \"RANGE\",           \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",           \"path\": \"path/to/file\",           \"srcPath\": \"path/to/file\",           \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"       }   }  ```  Blocker file line comment:   ```  {       \"text\": \"A task on a particular line within a file.\",       \"anchor\": {           \"diffType\": \"COMMIT\",           \"line\": 1,           \"lineType\": \"CONTEXT\",           \"fileType\": \"FROM\",           \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",           \"path\": \"path/to/file\",           \"srcPath\": \"path/to/file\",           \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"       }   }  ```  For file and line comments, \'path\' refers to the path of the file to which the comment should be applied and \'srcPath\' refers to the path the that file used to have (only required for copies and moves). Also, fromHash and toHash refer to the sinceId / untilId (respectively) used to produce the diff on which the comment was added. Finally diffType refers to the type of diff the comment was added on. For backwards compatibility purposes if no diffType is provided and no fromHash/toHash pair is provided the diffType will be resolved to \'EFFECTIVE\'. In any other cases the diffType is REQUIRED.   For line comments, \'line\' refers to the line in the diff that the comment should apply to. \'lineType\' refers to the type of diff hunk, which can be:   - \'ADDED\' - for an added line; - \'REMOVED\' - for a removed line; or - \'CONTEXT\' - for a line that was unmodified but is in the vicinity of the diff.    \'fileType\' refers to the file of the diff to which the anchor should be attached - which is of relevance when displaying the diff in a side-by-side way. Currently the supported values are:   - \'FROM\' - the source file of the diff  - \'TO\' - the destination file of the diff   If the current user is not a participant the user is added as a watcher of the pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Add new blocker comment
     */
    async createComment1Raw(requestParameters: CreateComment1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createComment1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling createComment1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createComment1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/blocker-comments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restComment'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new blocker comment.   Comments can be added in a few places by setting different attributes:   General pull request blocker comment:  ```  {       \"text\": \"A task on a pull request.\"  } ```  Blocker reply to a comment:   ```  {      \"text\": \"This reply is a task.\",       \"parent\": {           \"id\": 1       }  }  ```  General blocker file comment:  ```  {      \"text\": \"A blocker comment on a file.\",       \"anchor\": {           \"diffType\": \"RANGE\",           \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",           \"path\": \"path/to/file\",           \"srcPath\": \"path/to/file\",           \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"       }   }  ```  Blocker file line comment:   ```  {       \"text\": \"A task on a particular line within a file.\",       \"anchor\": {           \"diffType\": \"COMMIT\",           \"line\": 1,           \"lineType\": \"CONTEXT\",           \"fileType\": \"FROM\",           \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",           \"path\": \"path/to/file\",           \"srcPath\": \"path/to/file\",           \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"       }   }  ```  For file and line comments, \'path\' refers to the path of the file to which the comment should be applied and \'srcPath\' refers to the path the that file used to have (only required for copies and moves). Also, fromHash and toHash refer to the sinceId / untilId (respectively) used to produce the diff on which the comment was added. Finally diffType refers to the type of diff the comment was added on. For backwards compatibility purposes if no diffType is provided and no fromHash/toHash pair is provided the diffType will be resolved to \'EFFECTIVE\'. In any other cases the diffType is REQUIRED.   For line comments, \'line\' refers to the line in the diff that the comment should apply to. \'lineType\' refers to the type of diff hunk, which can be:   - \'ADDED\' - for an added line; - \'REMOVED\' - for a removed line; or - \'CONTEXT\' - for a line that was unmodified but is in the vicinity of the diff.    \'fileType\' refers to the file of the diff to which the anchor should be attached - which is of relevance when displaying the diff in a side-by-side way. Currently the supported values are:   - \'FROM\' - the source file of the diff  - \'TO\' - the destination file of the diff   If the current user is not a participant the user is added as a watcher of the pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Add new blocker comment
     */
    async createComment1(requestParameters: CreateComment1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.createComment1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new comment.   Comments can be added in a few places by setting different attributes: </p>General pull request comment:   <pre> {     \"text\": \"An insightful general comment on a pull request.\"   }   </pre> Reply to a comment:  <pre> {     \"text\": \"A measured reply.\",     \"parent\": {        \"id\": 1      }   }   </pre> General file comment:  <pre> {     \"text\": \"An insightful general comment on a file.\",     \"anchor\": {        \"diffType\": \"RANGE\",        \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",        \"path\": \"path/to/file\",        \"srcPath\": \"path/to/file\",        \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"     }   }   </pre> File line comment:  <pre> {     \"text\": \"A pithy comment on a particular line within a file.\",     \"anchor\": {        \"diffType\": \"COMMIT\",        \"line\": 1,        \"lineType\": \"CONTEXT\",        \"fileType\": \"FROM\",        \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",        \"path\": \"path/to/file\",        \"srcPath\": \"path/to/file\",        \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"      }   }   </pre>    Add a new task.   Tasks are just comments with the attribute \'severity\' set to \'BLOCKER\':   General pull request task:  <pre> {     \"text\": \"A task on a pull request.\",     \"severity\": \"BLOCKER\"   }   </pre>    Add a pending comment.    Pending comments are just comments with the attribute \'state\' set to \'PENDING\':   Pending comment: <pre> {     \"text\": \"This is a pending comment\",     \"state\": \"PENDING\"   }   </pre>   For file and line comments, \'path\' refers to the path of the file to which the comment should be applied and \'srcPath\' refers to the path the that file used to have (only required for copies and moves).  fromHash and toHash refer to the sinceId / untilId (respectively) used to produce the diff on which the comment was added.  For diffType \'COMMIT\' or \'RANGE\', you must specify both the fromHash and toHash. Note that this behaviour differs from `/commits/comments`  Finally diffType refers to the type of diff the comment was added on. For backwards compatibility purposes if no diffType is provided and no fromHash/toHash pair is provided the diffType will be resolved to \'EFFECTIVE\'. In any other cases the diffType is REQUIRED.  For line comments, \'line\' refers to the line in the diff that the comment should apply to. \'lineType\' refers to the type of diff hunk, which can be:   - \'ADDED\' - for an added line; - \'REMOVED\' - for a removed line; or - \'CONTEXT\' - for a line that was unmodified but is in the vicinity of the diff. </ul>\'fileType\' refers to the file of the diff to which the anchor should be attached - which is of relevance when displaying the diff in a side-by-side way. Currently the supported values are:   - \'FROM\' - the source file of the diff - \'TO\' - the destination file of the diff </ul>If the current user is not a participant the user is added as a watcher of the pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Add pull request comment
     */
    async createComment2Raw(requestParameters: CreateComment2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createComment2().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling createComment2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createComment2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restComment'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new comment.   Comments can be added in a few places by setting different attributes: </p>General pull request comment:   <pre> {     \"text\": \"An insightful general comment on a pull request.\"   }   </pre> Reply to a comment:  <pre> {     \"text\": \"A measured reply.\",     \"parent\": {        \"id\": 1      }   }   </pre> General file comment:  <pre> {     \"text\": \"An insightful general comment on a file.\",     \"anchor\": {        \"diffType\": \"RANGE\",        \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",        \"path\": \"path/to/file\",        \"srcPath\": \"path/to/file\",        \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"     }   }   </pre> File line comment:  <pre> {     \"text\": \"A pithy comment on a particular line within a file.\",     \"anchor\": {        \"diffType\": \"COMMIT\",        \"line\": 1,        \"lineType\": \"CONTEXT\",        \"fileType\": \"FROM\",        \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",        \"path\": \"path/to/file\",        \"srcPath\": \"path/to/file\",        \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"      }   }   </pre>    Add a new task.   Tasks are just comments with the attribute \'severity\' set to \'BLOCKER\':   General pull request task:  <pre> {     \"text\": \"A task on a pull request.\",     \"severity\": \"BLOCKER\"   }   </pre>    Add a pending comment.    Pending comments are just comments with the attribute \'state\' set to \'PENDING\':   Pending comment: <pre> {     \"text\": \"This is a pending comment\",     \"state\": \"PENDING\"   }   </pre>   For file and line comments, \'path\' refers to the path of the file to which the comment should be applied and \'srcPath\' refers to the path the that file used to have (only required for copies and moves).  fromHash and toHash refer to the sinceId / untilId (respectively) used to produce the diff on which the comment was added.  For diffType \'COMMIT\' or \'RANGE\', you must specify both the fromHash and toHash. Note that this behaviour differs from `/commits/comments`  Finally diffType refers to the type of diff the comment was added on. For backwards compatibility purposes if no diffType is provided and no fromHash/toHash pair is provided the diffType will be resolved to \'EFFECTIVE\'. In any other cases the diffType is REQUIRED.  For line comments, \'line\' refers to the line in the diff that the comment should apply to. \'lineType\' refers to the type of diff hunk, which can be:   - \'ADDED\' - for an added line; - \'REMOVED\' - for a removed line; or - \'CONTEXT\' - for a line that was unmodified but is in the vicinity of the diff. </ul>\'fileType\' refers to the file of the diff to which the anchor should be attached - which is of relevance when displaying the diff in a side-by-side way. Currently the supported values are:   - \'FROM\' - the source file of the diff - \'TO\' - the destination file of the diff </ul>If the current user is not a participant the user is added as a watcher of the pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Add pull request comment
     */
    async createComment2(requestParameters: CreateComment2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.createComment2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a default reviewer pull request condition for the given project.
     * Create default reviewer condition
     */
    async createPullRequestConditionRaw(requestParameters: CreatePullRequestConditionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestCondition>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createPullRequestCondition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/condition`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restDefaultReviewersRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a default reviewer pull request condition for the given project.
     * Create default reviewer condition
     */
    async createPullRequestCondition(requestParameters: CreatePullRequestConditionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestCondition> {
        const response = await this.createPullRequestConditionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a default reviewer pull request condition for the given repository.
     * Create default reviewer condition
     */
    async createPullRequestCondition1Raw(requestParameters: CreatePullRequestCondition1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestCondition>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createPullRequestCondition1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createPullRequestCondition1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/repos/{repositorySlug}/condition`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restDefaultReviewersRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a default reviewer pull request condition for the given repository.
     * Create default reviewer condition
     */
    async createPullRequestCondition1(requestParameters: CreatePullRequestCondition1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestCondition> {
        const response = await this.createPullRequestCondition1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Decline a pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Decline pull request
     */
    async declineRaw(requestParameters: DeclineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequest>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling decline().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling decline().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling decline().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestDeclineRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Decline a pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Decline pull request
     */
    async decline(requestParameters: DeclineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequest> {
        const response = await this.declineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a pull request.   To call this resource, users must be authenticated and have permission to view the pull request. Additionally, they must:   - be the pull request author, if the system is configured to allow authors to delete their own   pull requests (this is the default) OR  - have repository administrator permission for the repository the pull request is targeting   A body containing the version of the pull request must be provided with this request.   `{ \"version\": 1 }`
     * Delete pull request
     */
    async delete3Raw(requestParameters: Delete3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling delete3().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling delete3().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling delete3().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestDeleteRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a pull request.   To call this resource, users must be authenticated and have permission to view the pull request. Additionally, they must:   - be the pull request author, if the system is configured to allow authors to delete their own   pull requests (this is the default) OR  - have repository administrator permission for the repository the pull request is targeting   A body containing the version of the pull request must be provided with this request.   `{ \"version\": 1 }`
     * Delete pull request
     */
    async delete3(requestParameters: Delete3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete3Raw(requestParameters, initOverrides);
    }

    /**
     * Deletes a reviewer group.  The authenticated user must have <b>PROJECT_ADMIN</b> permission for the specified project to call this resource.
     * Delete reviewer group
     */
    async delete6Raw(requestParameters: Delete6Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling delete6().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling delete6().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/reviewer-groups/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a reviewer group.  The authenticated user must have <b>PROJECT_ADMIN</b> permission for the specified project to call this resource.
     * Delete reviewer group
     */
    async delete6(requestParameters: Delete6Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete6Raw(requestParameters, initOverrides);
    }

    /**
     * Deletes a reviewer group.  The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository to call this resource.
     * Delete reviewer group
     */
    async delete7Raw(requestParameters: Delete7Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling delete7().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling delete7().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling delete7().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/reviewer-groups/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a reviewer group.  The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository to call this resource.
     * Delete reviewer group
     */
    async delete7(requestParameters: Delete7Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete7Raw(requestParameters, initOverrides);
    }

    /**
     * Delete a pull request comment. Anyone can delete their own comment. Only users with <strong>REPO_ADMIN</strong> and above may delete comments created by other users.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Delete pull request comment
     */
    async deleteComment1Raw(requestParameters: DeleteComment1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteComment1().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling deleteComment1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling deleteComment1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteComment1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/blocker-comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a pull request comment. Anyone can delete their own comment. Only users with <strong>REPO_ADMIN</strong> and above may delete comments created by other users.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Delete pull request comment
     */
    async deleteComment1(requestParameters: DeleteComment1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteComment1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete a pull request comment. Anyone can delete their own comment. Only users with <strong>REPO_ADMIN</strong> and above may delete comments created by other users.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Delete a pull request comment
     */
    async deleteComment2Raw(requestParameters: DeleteComment2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteComment2().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling deleteComment2().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling deleteComment2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteComment2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a pull request comment. Anyone can delete their own comment. Only users with <strong>REPO_ADMIN</strong> and above may delete comments created by other users.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Delete a pull request comment
     */
    async deleteComment2(requestParameters: DeleteComment2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteComment2Raw(requestParameters, initOverrides);
    }

    /**
     * Delete the default reviewer pull request condition associated with the given ID.
     * Delete default reviewer condition
     */
    async deletePullRequestConditionRaw(requestParameters: DeletePullRequestConditionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deletePullRequestCondition().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deletePullRequestCondition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/condition/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the default reviewer pull request condition associated with the given ID.
     * Delete default reviewer condition
     */
    async deletePullRequestCondition(requestParameters: DeletePullRequestConditionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePullRequestConditionRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the default reviewer pull request condition associated with the given ID.
     * Delete default reviewer condition
     */
    async deletePullRequestCondition1Raw(requestParameters: DeletePullRequestCondition1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deletePullRequestCondition1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deletePullRequestCondition1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deletePullRequestCondition1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/repos/{repositorySlug}/condition/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the default reviewer pull request condition associated with the given ID.
     * Delete default reviewer condition
     */
    async deletePullRequestCondition1(requestParameters: DeletePullRequestCondition1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePullRequestCondition1Raw(requestParameters, initOverrides);
    }

    /**
     * Discard a pull request review for the authenticated user.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository to call this resource.
     * Discard pull request review
     */
    async discardReviewRaw(requestParameters: DiscardReviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling discardReview().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling discardReview().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling discardReview().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/review`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Discard a pull request review for the authenticated user.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository to call this resource.
     * Discard pull request review
     */
    async discardReview(requestParameters: DiscardReviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.discardReviewRaw(requestParameters, initOverrides);
    }

    /**
     * Complete a review on a pull request.
     * Complete pull request review
     */
    async finishReviewRaw(requestParameters: FinishReviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling finishReview().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling finishReview().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling finishReview().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/review`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestFinishReviewRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Complete a review on a pull request.
     * Complete pull request review
     */
    async finishReview(requestParameters: FinishReviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.finishReviewRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request
     */
    async get3Raw(requestParameters: Get3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequest>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling get3().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling get3().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling get3().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request
     */
    async get3(requestParameters: Get3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequest> {
        const response = await this.get3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of activity associated with a pull request.   Activity items include comments, approvals, rescopes (i.e. adding and removing of commits), merges and more.   Different types of activity items may be introduced in newer versions of Stash or by user installed plugins, so clients should be flexible enough to handle unexpected entity shapes in the returned page.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request activity
     */
    async getActivitiesRaw(requestParameters: GetActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetActivities200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getActivities().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getActivities().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getActivities().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromType'] != null) {
            queryParameters['fromType'] = requestParameters['fromType'];
        }

        if (requestParameters['fromId'] != null) {
            queryParameters['fromId'] = requestParameters['fromId'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/activities`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of activity associated with a pull request.   Activity items include comments, approvals, rescopes (i.e. adding and removing of commits), merges and more.   Different types of activity items may be introduced in newer versions of Stash or by user installed plugins, so clients should be flexible enough to handle unexpected entity shapes in the returned page.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request activity
     */
    async getActivities(requestParameters: GetActivitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetActivities200Response> {
        const response = await this.getActivitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an auto-merge request for the pull request, if requested.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get auto-merge request for pull request
     */
    async getAutoMergeRequestRaw(requestParameters: GetAutoMergeRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoMergeRequest>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAutoMergeRequest().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getAutoMergeRequest().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAutoMergeRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/auto-merge`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns an auto-merge request for the pull request, if requested.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get auto-merge request for pull request
     */
    async getAutoMergeRequest(requestParameters: GetAutoMergeRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoMergeRequest> {
        const response = await this.getAutoMergeRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a pull request comment.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request comment
     */
    async getComment1Raw(requestParameters: GetComment1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getComment1().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling getComment1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getComment1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getComment1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/blocker-comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a pull request comment.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request comment
     */
    async getComment1(requestParameters: GetComment1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.getComment1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a pull request comment.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get a pull request comment
     */
    async getComment2Raw(requestParameters: GetComment2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getComment2().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling getComment2().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getComment2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getComment2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a pull request comment.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get a pull request comment
     */
    async getComment2(requestParameters: GetComment2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.getComment2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets comments matching the given set of field values for the specified pull request. (Note this does <b>not</b> perform any kind of searching for comments by their text).   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Search pull request comments
     */
    async getComments1Raw(requestParameters: GetComments1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetComments200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getComments1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getComments1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getComments1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['count'] != null) {
            queryParameters['count'] = requestParameters['count'];
        }

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['states'] != null) {
            queryParameters['states'] = requestParameters['states'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/blocker-comments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets comments matching the given set of field values for the specified pull request. (Note this does <b>not</b> perform any kind of searching for comments by their text).   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Search pull request comments
     */
    async getComments1(requestParameters: GetComments1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetComments200Response> {
        const response = await this.getComments1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets comments for the specified pull request and path.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request comments for path
     */
    async getComments2Raw(requestParameters: GetComments2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetComments200Response>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling getComments2().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getComments2().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getComments2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getComments2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['fromHash'] != null) {
            queryParameters['fromHash'] = requestParameters['fromHash'];
        }

        if (requestParameters['anchorState'] != null) {
            queryParameters['anchorState'] = requestParameters['anchorState'];
        }

        if (requestParameters['diffType'] != null) {
            queryParameters['diffType'] = requestParameters['diffType'];
        }

        if (requestParameters['toHash'] != null) {
            queryParameters['toHash'] = requestParameters['toHash'];
        }

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['diffTypes'] != null) {
            queryParameters['diffTypes'] = requestParameters['diffTypes'];
        }

        if (requestParameters['states'] != null) {
            queryParameters['states'] = requestParameters['states'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets comments for the specified pull request and path.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request comments for path
     */
    async getComments2(requestParameters: GetComments2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetComments200Response> {
        const response = await this.getComments2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a suggested commit message for the given Pull Request.
     * Get commit message suggestion
     */
    async getCommitMessageSuggestionRaw(requestParameters: GetCommitMessageSuggestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestCommitMessageSuggestion>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getCommitMessageSuggestion().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getCommitMessageSuggestion().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getCommitMessageSuggestion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/commit-message-suggestion`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a suggested commit message for the given Pull Request.
     * Get commit message suggestion
     */
    async getCommitMessageSuggestion(requestParameters: GetCommitMessageSuggestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestCommitMessageSuggestion> {
        const response = await this.getCommitMessageSuggestionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve commits for the specified pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request commits
     */
    async getCommits1Raw(requestParameters: GetCommits1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCommits200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getCommits1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getCommits1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getCommits1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['avatarScheme'] != null) {
            queryParameters['avatarScheme'] = requestParameters['avatarScheme'];
        }

        if (requestParameters['withCounts'] != null) {
            queryParameters['withCounts'] = requestParameters['withCounts'];
        }

        if (requestParameters['avatarSize'] != null) {
            queryParameters['avatarSize'] = requestParameters['avatarSize'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/commits`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve commits for the specified pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request commits
     */
    async getCommits1(requestParameters: GetCommits1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCommits200Response> {
        const response = await this.getCommits1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the diff stats summary for the given Pull Request.   The stats summary include the total number of modified files, added lines, and deleted lines.   Note: The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get diff stats summary for pull request
     */
    async getDiffStatsSummary2Raw(requestParameters: GetDiffStatsSummary2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling getDiffStatsSummary2().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getDiffStatsSummary2().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getDiffStatsSummary2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getDiffStatsSummary2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sinceId'] != null) {
            queryParameters['sinceId'] = requestParameters['sinceId'];
        }

        if (requestParameters['srcPath'] != null) {
            queryParameters['srcPath'] = requestParameters['srcPath'];
        }

        if (requestParameters['untilId'] != null) {
            queryParameters['untilId'] = requestParameters['untilId'];
        }

        if (requestParameters['whitespace'] != null) {
            queryParameters['whitespace'] = requestParameters['whitespace'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/diff-stats-summary/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Retrieve the diff stats summary for the given Pull Request.   The stats summary include the total number of modified files, added lines, and deleted lines.   Note: The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get diff stats summary for pull request
     */
    async getDiffStatsSummary2(requestParameters: GetDiffStatsSummary2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getDiffStatsSummary2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the best common ancestor between the latest commits of the source and target branches of the pull request.  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
     * Get the common ancestor between the latest commits of the source and target branches of the pull request
     */
    async getMergeBase1Raw(requestParameters: GetMergeBase1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestCommit>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getMergeBase1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getMergeBase1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getMergeBase1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge-base`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the best common ancestor between the latest commits of the source and target branches of the pull request.  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
     * Get the common ancestor between the latest commits of the source and target branches of the pull request
     */
    async getMergeBase1(requestParameters: GetMergeBase1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestCommit | null | undefined > {
        const response = await this.getMergeBase1Raw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Retrieve the merge strategies available for this instance.   The user must be authenticated to call this resource.
     * Get merge strategies
     */
    async getMergeConfigRaw(requestParameters: GetMergeConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestMergeConfig>> {
        if (requestParameters['scmId'] == null) {
            throw new runtime.RequiredError(
                'scmId',
                'Required parameter "scmId" was null or undefined when calling getMergeConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/pull-requests/{scmId}`.replace(`{${"scmId"}}`, encodeURIComponent(String(requestParameters['scmId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the merge strategies available for this instance.   The user must be authenticated to call this resource.
     * Get merge strategies
     */
    async getMergeConfig(requestParameters: GetMergeConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestMergeConfig> {
        const response = await this.getMergeConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of pull requests to or from the specified repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.  Optionally clients can specify PR participant filters. Each filter has a mandatory username.N parameter, and the optional role.N and approved.N parameters.   - username.N - the \"root\" of a single participant filter, where \"N\" is a natural number   starting from 1. This allows clients to specify multiple participant filters, by providing consecutive   filters as username.1, username.2 etc. Note that the filters numbering has to start   with 1 and be continuous for all filters to be processed. The total allowed number of participant   filters is 10 and all filters exceeding that limit will be dropped. - role.N(optional) the role associated with username.N.   This must be one of AUTHOR, REVIEWER, or PARTICIPANT - approved.N (optional) the approved status associated with username.N.   That is whether username.N has approved the PR. Either true, or false 
     * Get pull requests for repository
     */
    async getPageRaw(requestParameters: GetPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPullRequests1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPage().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getPage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['withAttributes'] != null) {
            queryParameters['withAttributes'] = requestParameters['withAttributes'];
        }

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['withProperties'] != null) {
            queryParameters['withProperties'] = requestParameters['withProperties'];
        }

        if (requestParameters['draft'] != null) {
            queryParameters['draft'] = requestParameters['draft'];
        }

        if (requestParameters['filterText'] != null) {
            queryParameters['filterText'] = requestParameters['filterText'];
        }

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['direction'] != null) {
            queryParameters['direction'] = requestParameters['direction'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of pull requests to or from the specified repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.  Optionally clients can specify PR participant filters. Each filter has a mandatory username.N parameter, and the optional role.N and approved.N parameters.   - username.N - the \"root\" of a single participant filter, where \"N\" is a natural number   starting from 1. This allows clients to specify multiple participant filters, by providing consecutive   filters as username.1, username.2 etc. Note that the filters numbering has to start   with 1 and be continuous for all filters to be processed. The total allowed number of participant   filters is 10 and all filters exceeding that limit will be dropped. - role.N(optional) the role associated with username.N.   This must be one of AUTHOR, REVIEWER, or PARTICIPANT - approved.N (optional) the approved status associated with username.N.   That is whether username.N has approved the PR. Either true, or false 
     * Get pull requests for repository
     */
    async getPage(requestParameters: GetPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPullRequests1200Response> {
        const response = await this.getPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a page of default reviewer pull request conditions that have been configured for this project.
     * Get default reviewer conditions
     */
    async getPullRequestConditionsRaw(requestParameters: GetPullRequestConditionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestPullRequestCondition>>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPullRequestConditions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/conditions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return a page of default reviewer pull request conditions that have been configured for this project.
     * Get default reviewer conditions
     */
    async getPullRequestConditions(requestParameters: GetPullRequestConditionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestPullRequestCondition>> {
        const response = await this.getPullRequestConditionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a page of default reviewer pull request conditions that have been configured for this repository.
     * Get default reviewer conditions
     */
    async getPullRequestConditions1Raw(requestParameters: GetPullRequestConditions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestPullRequestCondition>>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPullRequestConditions1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getPullRequestConditions1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/repos/{repositorySlug}/conditions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return a page of default reviewer pull request conditions that have been configured for this repository.
     * Get default reviewer conditions
     */
    async getPullRequestConditions1(requestParameters: GetPullRequestConditions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestPullRequestCondition>> {
        const response = await this.getPullRequestConditions1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of pull requests in the current repository that contain the given commit.  The user must be authenticated and have access to the specified repository to call this resource.
     * Get repository pull requests containing commit
     */
    async getPullRequestsRaw(requestParameters: GetPullRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPullRequests1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPullRequests().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getPullRequests().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getPullRequests().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/pull-requests`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of pull requests in the current repository that contain the given commit.  The user must be authenticated and have access to the specified repository to call this resource.
     * Get repository pull requests containing commit
     */
    async getPullRequests(requestParameters: GetPullRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPullRequests1200Response> {
        const response = await this.getPullRequestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the <code>CommentThread</code> threads which have <code>Comment</code> comments that have a <code>CommentState#PENDING</code> pending state and are part of the pull request review for the authenticated user.
     * Get pull request comment thread
     */
    async getReviewRaw(requestParameters: GetReviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetComments200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getReview().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling getReview().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getReview().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/review`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the <code>CommentThread</code> threads which have <code>Comment</code> comments that have a <code>CommentState#PENDING</code> pending state and are part of the pull request review for the authenticated user.
     * Get pull request comment thread
     */
    async getReview(requestParameters: GetReviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetComments200Response> {
        const response = await this.getReviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a reviewer group.  The authenticated user must have <b>PROJECT_READ</b> permission for the specified project to call this resource.
     * Get reviewer group
     */
    async getReviewerGroupRaw(requestParameters: GetReviewerGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestReviewerGroup>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getReviewerGroup().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getReviewerGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/reviewer-groups/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a reviewer group.  The authenticated user must have <b>PROJECT_READ</b> permission for the specified project to call this resource.
     * Get reviewer group
     */
    async getReviewerGroup(requestParameters: GetReviewerGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestReviewerGroup> {
        const response = await this.getReviewerGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a reviewer group.  The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.
     * Get reviewer group
     */
    async getReviewerGroup1Raw(requestParameters: GetReviewerGroup1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestReviewerGroup>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getReviewerGroup1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getReviewerGroup1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getReviewerGroup1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/reviewer-groups/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a reviewer group.  The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.
     * Get reviewer group
     */
    async getReviewerGroup1(requestParameters: GetReviewerGroup1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestReviewerGroup> {
        const response = await this.getReviewerGroup1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of reviewer groups of a given scope.  The authenticated user must have <b>PROJECT_READ</b> permission for the specified project to call this resource.
     * Get all reviewer groups
     */
    async getReviewerGroupsRaw(requestParameters: GetReviewerGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetReviewerGroups1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getReviewerGroups().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/reviewer-groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of reviewer groups of a given scope.  The authenticated user must have <b>PROJECT_READ</b> permission for the specified project to call this resource.
     * Get all reviewer groups
     */
    async getReviewerGroups(requestParameters: GetReviewerGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetReviewerGroups1200Response> {
        const response = await this.getReviewerGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of reviewer groups of a given scope.  The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.
     * Get all reviewer groups
     */
    async getReviewerGroups1Raw(requestParameters: GetReviewerGroups1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetReviewerGroups1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getReviewerGroups1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getReviewerGroups1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/reviewer-groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of reviewer groups of a given scope.  The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.
     * Get all reviewer groups
     */
    async getReviewerGroups1(requestParameters: GetReviewerGroups1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetReviewerGroups1200Response> {
        const response = await this.getReviewerGroups1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a set of users who are required reviewers for pull requests created from the given source repository and ref to the given target ref in this repository.
     * Get required reviewers for PR creation
     */
    async getReviewersRaw(requestParameters: GetReviewersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestPullRequestCondition>>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getReviewers().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getReviewers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['targetRepoId'] != null) {
            queryParameters['targetRepoId'] = requestParameters['targetRepoId'];
        }

        if (requestParameters['sourceRepoId'] != null) {
            queryParameters['sourceRepoId'] = requestParameters['sourceRepoId'];
        }

        if (requestParameters['sourceRefId'] != null) {
            queryParameters['sourceRefId'] = requestParameters['sourceRefId'];
        }

        if (requestParameters['targetRefId'] != null) {
            queryParameters['targetRefId'] = requestParameters['targetRefId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/repos/{repositorySlug}/reviewers`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return a set of users who are required reviewers for pull requests created from the given source repository and ref to the given target ref in this repository.
     * Get required reviewers for PR creation
     */
    async getReviewers(requestParameters: GetReviewersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestPullRequestCondition>> {
        const response = await this.getReviewersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of the users of a reviewer group.  This does not return all the users of the group, only the users who are licensed and have <b>REPO_READ</b> permission for the specified repository.  The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.
     * Get reviewer group users
     */
    async getUsersRaw(requestParameters: GetUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestApplicationUser>>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getUsers().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getUsers().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getUsers().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/reviewer-groups/{id}/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a list of the users of a reviewer group.  This does not return all the users of the group, only the users who are licensed and have <b>REPO_READ</b> permission for the specified repository.  The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.
     * Get reviewer group users
     */
    async getUsers(requestParameters: GetUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestApplicationUser>> {
        const response = await this.getUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a page of the participants for a given pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request participants
     */
    async listParticipantsRaw(requestParameters: ListParticipantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListParticipants200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling listParticipants().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling listParticipants().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling listParticipants().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a page of the participants for a given pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Get pull request participants
     */
    async listParticipants(requestParameters: ListParticipantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListParticipants200Response> {
        const response = await this.listParticipantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Merge the specified pull request immediately or set the pull request to auto-merge when all the merge checks pass by setting <strong>autoMerge</strong> field in the request body.  The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Merge pull request
     */
    async mergeRaw(requestParameters: MergeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequest>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling merge().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling merge().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling merge().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestMergeRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Merge the specified pull request immediately or set the pull request to auto-merge when all the merge checks pass by setting <strong>autoMerge</strong> field in the request body.  The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Merge pull request
     */
    async merge(requestParameters: MergeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequest> {
        const response = await this.mergeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add an emoticon reaction to a pull request comment
     * React to a PR comment
     */
    async react1Raw(requestParameters: React1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserReaction>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling react1().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling react1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling react1().'
            );
        }

        if (requestParameters['emoticon'] == null) {
            throw new runtime.RequiredError(
                'emoticon',
                'Required parameter "emoticon" was null or undefined when calling react1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling react1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}/reactions/{emoticon}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"emoticon"}}`, encodeURIComponent(String(requestParameters['emoticon']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add an emoticon reaction to a pull request comment
     * React to a PR comment
     */
    async react1(requestParameters: React1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserReaction> {
        const response = await this.react1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Rebases the specified pull request, rewriting the incoming commits to start from the tip commit of the pull request\'s target branch. <i>This operation alters the pull request\'s source branch and cannot be undone.</i>  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets <i>and</i> <strong>REPO_WRITE</strong> permission for the pull request\'s source repository to call this resource.
     * Rebase pull request
     */
    async rebaseRaw(requestParameters: RebaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestRebaseResult>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling rebase().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling rebase().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling rebase().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/git/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/rebase`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestRebaseRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Rebases the specified pull request, rewriting the incoming commits to start from the tip commit of the pull request\'s target branch. <i>This operation alters the pull request\'s source branch and cannot be undone.</i>  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets <i>and</i> <strong>REPO_WRITE</strong> permission for the pull request\'s source repository to call this resource.
     * Rebase pull request
     */
    async rebase(requestParameters: RebaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestRebaseResult> {
        const response = await this.rebaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Re-open a declined pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Re-open pull request
     */
    async reopenRaw(requestParameters: ReopenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequest>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling reopen().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling reopen().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling reopen().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/reopen`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestReopenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Re-open a declined pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Re-open pull request
     */
    async reopen(requestParameters: ReopenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequest> {
        const response = await this.reopenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of participant users for all the pull requests to or from the specified repository.   Optionally clients can specify following filters.
     * Search pull request participants
     */
    async searchRaw(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUsersWithoutAnyPermission200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling search().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling search().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['role'] != null) {
            queryParameters['role'] = requestParameters['role'];
        }

        if (requestParameters['direction'] != null) {
            queryParameters['direction'] = requestParameters['direction'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/participants`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of participant users for all the pull requests to or from the specified repository.   Optionally clients can specify following filters.
     * Search pull request participants
     */
    async search(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUsersWithoutAnyPermission200Response> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the pull request merge strategies for the context repository.   The authenticated user must have <strong>ADMIN</strong> permission to call this resource.   Only the strategies provided will be enabled, only one may be set to default   The commit message template will not be updated if not provided, and will be deleted if the `commitMessageTemplate` attribute is empty, i.e: `commitMessageTemplate: {}`.  An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty `mergeConfig` attribute. i.e: ``` {      \"mergeConfig\": {}  }  ```  Upon completion of this request, the effective configuration will be the default configuration.
     * Update merge strategies
     */
    async setMergeConfigRaw(requestParameters: SetMergeConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestMergeConfig>> {
        if (requestParameters['scmId'] == null) {
            throw new runtime.RequiredError(
                'scmId',
                'Required parameter "scmId" was null or undefined when calling setMergeConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/pull-requests/{scmId}`.replace(`{${"scmId"}}`, encodeURIComponent(String(requestParameters['scmId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestSettings'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the pull request merge strategies for the context repository.   The authenticated user must have <strong>ADMIN</strong> permission to call this resource.   Only the strategies provided will be enabled, only one may be set to default   The commit message template will not be updated if not provided, and will be deleted if the `commitMessageTemplate` attribute is empty, i.e: `commitMessageTemplate: {}`.  An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty `mergeConfig` attribute. i.e: ``` {      \"mergeConfig\": {}  }  ```  Upon completion of this request, the effective configuration will be the default configuration.
     * Update merge strategies
     */
    async setMergeConfig(requestParameters: SetMergeConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestMergeConfig> {
        const response = await this.setMergeConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets changes for the specified PullRequest.  If the changeScope query parameter is set to \'UNREVIEWED\', the application will attempt to stream unreviewed changes based on the lastReviewedCommit of the current user, which are the changes between the lastReviewedCommit and the latest commit of the source branch. The current user is considered to <i>not</i> have any unreviewed changes for the pull request when the lastReviewedCommit is either null (everything is unreviewed, so all changes are streamed), equal to the latest commit of the source branch (everything is reviewed), or no longer on the source branch (the source branch has been rebased). In these cases, the application will fall back to streaming all changes (the default), which is the effective diff for the pull request. The type of changes streamed can be determined by the changeScope parameter included in the properties map of the response.   Note: This resource is currently <i>not paged</i>. The server will return at most one page. The server will truncate the number of changes to either the request\'s page limit or an internal maximum, whichever is smaller. The start parameter of the page request is also ignored.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Gets pull request changes
     */
    async streamChanges1Raw(requestParameters: StreamChanges1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestChange>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamChanges1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling streamChanges1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamChanges1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sinceId'] != null) {
            queryParameters['sinceId'] = requestParameters['sinceId'];
        }

        if (requestParameters['changeScope'] != null) {
            queryParameters['changeScope'] = requestParameters['changeScope'];
        }

        if (requestParameters['untilId'] != null) {
            queryParameters['untilId'] = requestParameters['untilId'];
        }

        if (requestParameters['withComments'] != null) {
            queryParameters['withComments'] = requestParameters['withComments'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/changes`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets changes for the specified PullRequest.  If the changeScope query parameter is set to \'UNREVIEWED\', the application will attempt to stream unreviewed changes based on the lastReviewedCommit of the current user, which are the changes between the lastReviewedCommit and the latest commit of the source branch. The current user is considered to <i>not</i> have any unreviewed changes for the pull request when the lastReviewedCommit is either null (everything is unreviewed, so all changes are streamed), equal to the latest commit of the source branch (everything is reviewed), or no longer on the source branch (the source branch has been rebased). In these cases, the application will fall back to streaming all changes (the default), which is the effective diff for the pull request. The type of changes streamed can be determined by the changeScope parameter included in the properties map of the response.   Note: This resource is currently <i>not paged</i>. The server will return at most one page. The server will truncate the number of changes to either the request\'s page limit or an internal maximum, whichever is smaller. The start parameter of the page request is also ignored.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Gets pull request changes
     */
    async streamChanges1(requestParameters: StreamChanges1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestChange> {
        const response = await this.streamChanges1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams a diff within a pull request.   If the specified file has been copied, moved or renamed, the <code>srcPath</code> must also be specified to produce the correct diff.   To stream a raw text representation of the diff, this endpoint can be called with the request header \'Accept: text/plain\'.   Note: This RESTful endpoint is currently <i>not paged</i>. The server will internally apply a hard cap to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Stream a diff within a pull request
     */
    async streamDiff2Raw(requestParameters: StreamDiff2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDiff>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling streamDiff2().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamDiff2().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling streamDiff2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamDiff2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['avatarScheme'] != null) {
            queryParameters['avatarScheme'] = requestParameters['avatarScheme'];
        }

        if (requestParameters['contextLines'] != null) {
            queryParameters['contextLines'] = requestParameters['contextLines'];
        }

        if (requestParameters['sinceId'] != null) {
            queryParameters['sinceId'] = requestParameters['sinceId'];
        }

        if (requestParameters['srcPath'] != null) {
            queryParameters['srcPath'] = requestParameters['srcPath'];
        }

        if (requestParameters['diffType'] != null) {
            queryParameters['diffType'] = requestParameters['diffType'];
        }

        if (requestParameters['untilId'] != null) {
            queryParameters['untilId'] = requestParameters['untilId'];
        }

        if (requestParameters['whitespace'] != null) {
            queryParameters['whitespace'] = requestParameters['whitespace'];
        }

        if (requestParameters['withComments'] != null) {
            queryParameters['withComments'] = requestParameters['withComments'];
        }

        if (requestParameters['avatarSize'] != null) {
            queryParameters['avatarSize'] = requestParameters['avatarSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/diff/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Streams a diff within a pull request.   If the specified file has been copied, moved or renamed, the <code>srcPath</code> must also be specified to produce the correct diff.   To stream a raw text representation of the diff, this endpoint can be called with the request header \'Accept: text/plain\'.   Note: This RESTful endpoint is currently <i>not paged</i>. The server will internally apply a hard cap to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Stream a diff within a pull request
     */
    async streamDiff2(requestParameters: StreamDiff2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDiff> {
        const response = await this.streamDiff2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams a patch representing a pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Stream pull request as patch
     */
    async streamPatch1Raw(requestParameters: StreamPatch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamPatch1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling streamPatch1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamPatch1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}.patch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Streams a patch representing a pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Stream pull request as patch
     */
    async streamPatch1(requestParameters: StreamPatch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamPatch1Raw(requestParameters, initOverrides);
    }

    /**
     * Streams the raw diff for a pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Stream raw pull request diff
     */
    async streamRawDiff2Raw(requestParameters: StreamRawDiff2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamRawDiff2().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling streamRawDiff2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamRawDiff2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['contextLines'] != null) {
            queryParameters['contextLines'] = requestParameters['contextLines'];
        }

        if (requestParameters['whitespace'] != null) {
            queryParameters['whitespace'] = requestParameters['whitespace'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}.diff`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Streams the raw diff for a pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Stream raw pull request diff
     */
    async streamRawDiff2(requestParameters: StreamRawDiff2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamRawDiff2Raw(requestParameters, initOverrides);
    }

    /**
     * Requests the system to try merging the pull request if auto-merge was requested on it.  The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Auto-merge pull request
     */
    async tryAutoMergeRaw(requestParameters: TryAutoMergeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoMergeProcessingResult>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling tryAutoMerge().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling tryAutoMerge().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling tryAutoMerge().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/auto-merge`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Requests the system to try merging the pull request if auto-merge was requested on it.  The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Auto-merge pull request
     */
    async tryAutoMerge(requestParameters: TryAutoMergeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoMergeProcessingResult> {
        const response = await this.tryAutoMergeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove an emoticon reaction from a pull request comment
     * Remove a reaction from a PR comment
     */
    async unReact1Raw(requestParameters: UnReact1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unReact1().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling unReact1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling unReact1().'
            );
        }

        if (requestParameters['emoticon'] == null) {
            throw new runtime.RequiredError(
                'emoticon',
                'Required parameter "emoticon" was null or undefined when calling unReact1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling unReact1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}/reactions/{emoticon}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"emoticon"}}`, encodeURIComponent(String(requestParameters['emoticon']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an emoticon reaction from a pull request comment
     * Remove a reaction from a PR comment
     */
    async unReact1(requestParameters: UnReact1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unReact1Raw(requestParameters, initOverrides);
    }

    /**
     * Unassigns a participant from the REVIEWER role they may have been given in a pull request.   If the participant has no explicit role this method has no effect.   Afterwards, the user will still remain a participant in the pull request but their role will be reduced to PARTICIPANT. This is because once made a participant of a pull request, a user will forever remain a participant. Only their role may be altered.   The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Unassign pull request participant
     */
    async unassignParticipantRoleRaw(requestParameters: UnassignParticipantRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unassignParticipantRole().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling unassignParticipantRole().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling unassignParticipantRole().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling unassignParticipantRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants/{userSlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unassigns a participant from the REVIEWER role they may have been given in a pull request.   If the participant has no explicit role this method has no effect.   Afterwards, the user will still remain a participant in the pull request but their role will be reduced to PARTICIPANT. This is because once made a participant of a pull request, a user will forever remain a participant. Only their role may be altered.   The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.
     * Unassign pull request participant
     */
    async unassignParticipantRole(requestParameters: UnassignParticipantRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unassignParticipantRoleRaw(requestParameters, initOverrides);
    }

    /**
     * Unassigns a participant from the REVIEWER role they may have been given in a pull request.   If the participant has no explicit role this method has no effect.   Afterwards, the user will still remain a participant in the pull request but their role will be reduced to PARTICIPANT. This is because once made a participant of a pull request, a user will forever remain a participant. Only their role may be altered.   The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.   <strong>Deprecated since 4.2</strong>. Use /rest/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants/{userSlug} instead.
     * Unassign pull request participant
     * @deprecated
     */
    async unassignParticipantRole1Raw(requestParameters: UnassignParticipantRole1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unassignParticipantRole1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling unassignParticipantRole1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling unassignParticipantRole1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['username'] != null) {
            queryParameters['username'] = requestParameters['username'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unassigns a participant from the REVIEWER role they may have been given in a pull request.   If the participant has no explicit role this method has no effect.   Afterwards, the user will still remain a participant in the pull request but their role will be reduced to PARTICIPANT. This is because once made a participant of a pull request, a user will forever remain a participant. Only their role may be altered.   The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that this pull request targets to call this resource.   <strong>Deprecated since 4.2</strong>. Use /rest/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants/{userSlug} instead.
     * Unassign pull request participant
     * @deprecated
     */
    async unassignParticipantRole1(requestParameters: UnassignParticipantRole1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unassignParticipantRole1Raw(requestParameters, initOverrides);
    }

    /**
     * Remove the authenticated user as a watcher for the specified pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Stop watching pull request
     */
    async unwatch1Raw(requestParameters: Unwatch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unwatch1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling unwatch1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling unwatch1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/watch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the authenticated user as a watcher for the specified pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Stop watching pull request
     */
    async unwatch1(requestParameters: Unwatch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unwatch1Raw(requestParameters, initOverrides);
    }

    /**
     * Update the title, description, reviewers, destination branch or draft status of an existing pull request.   **Note:** the <em>reviewers</em> list may be updated using this resource. However the <em>author</em> and <em>participants</em> list may not.   The authenticated user must either:   - be the author of the pull request and have the <strong>REPO_READ</strong> permission for the repository that this pull request targets; or - have the <strong>REPO_WRITE</strong> permission for the repository that this pull request targets   to call this resource.
     * Update pull request metadata
     */
    async updateRaw(requestParameters: UpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequest>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling update().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling update().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling update().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the title, description, reviewers, destination branch or draft status of an existing pull request.   **Note:** the <em>reviewers</em> list may be updated using this resource. However the <em>author</em> and <em>participants</em> list may not.   The authenticated user must either:   - be the author of the pull request and have the <strong>REPO_READ</strong> permission for the repository that this pull request targets; or - have the <strong>REPO_WRITE</strong> permission for the repository that this pull request targets   to call this resource.
     * Update pull request metadata
     */
    async update(requestParameters: UpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequest> {
        const response = await this.updateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the attributes of a reviewer group.  The authenticated user must have <b>PROJECT_READ</b> permission for the specified project to call this resource.
     * Update reviewer group attributes
     */
    async update1Raw(requestParameters: Update1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestReviewerGroup>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling update1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling update1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/reviewer-groups/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restReviewerGroup'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the attributes of a reviewer group.  The authenticated user must have <b>PROJECT_READ</b> permission for the specified project to call this resource.
     * Update reviewer group attributes
     */
    async update1(requestParameters: Update1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestReviewerGroup> {
        const response = await this.update1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the attributes of a reviewer group.  The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository to call this resource.
     * Update reviewer group attributes
     */
    async update2Raw(requestParameters: Update2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestReviewerGroup>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling update2().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling update2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling update2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/reviewer-groups/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restReviewerGroup'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the attributes of a reviewer group.  The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository to call this resource.
     * Update reviewer group attributes
     */
    async update2(requestParameters: Update2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestReviewerGroup> {
        const response = await this.update2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a comment, with the following restrictions:   - only the author of the comment may update the <i>text</i> of the comment - only the author of the comment, the author of the pull request or repository admins and above may update   the other fields of a comment   Convert a comment to a task or vice versa.   Comments can be converted to tasks by setting the \'severity\' attribute to \'BLOCKER\':  ```  {  \"severity\": \"BLOCKER\"  }  ```  Tasks can be converted to comments by setting the \'severity\' attribute to \'NORMAL\': ```  {  \"severity\": \"NORMAL\"  }  ```  Resolve a blocker comment.   Blocker comments can be resolved by setting the \'state\' attribute to \'RESOLVED\': ```  {  \"state\": \"RESOLVED\"  }  ```  <strong>Note:</strong> the supplied JSON object must contain a <code>version</code> that must match the server\'s version of the comment or the update will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the update. Look for the \'version\' attribute in the returned JSON structure.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Update pull request comment
     */
    async updateComment1Raw(requestParameters: UpdateComment1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateComment1().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling updateComment1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling updateComment1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateComment1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/blocker-comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restComment'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update a comment, with the following restrictions:   - only the author of the comment may update the <i>text</i> of the comment - only the author of the comment, the author of the pull request or repository admins and above may update   the other fields of a comment   Convert a comment to a task or vice versa.   Comments can be converted to tasks by setting the \'severity\' attribute to \'BLOCKER\':  ```  {  \"severity\": \"BLOCKER\"  }  ```  Tasks can be converted to comments by setting the \'severity\' attribute to \'NORMAL\': ```  {  \"severity\": \"NORMAL\"  }  ```  Resolve a blocker comment.   Blocker comments can be resolved by setting the \'state\' attribute to \'RESOLVED\': ```  {  \"state\": \"RESOLVED\"  }  ```  <strong>Note:</strong> the supplied JSON object must contain a <code>version</code> that must match the server\'s version of the comment or the update will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the update. Look for the \'version\' attribute in the returned JSON structure.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Update pull request comment
     */
    async updateComment1(requestParameters: UpdateComment1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.updateComment1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a comment, with the following restrictions:   - only the author of the comment may update the <i>text</i> of the comment - only the author of the comment, the author of the pull request or repository admins and above may update the other fields of a comment </ul>   Convert a comment to a task or vice versa.   Comments can be converted to tasks by setting the \'severity\' attribute to \'BLOCKER\':   <pre> {   \"severity\": \"BLOCKER\"   }   </pre>  Tasks can be converted to comments by setting the \'severity\' attribute to \'NORMAL\':  <pre> {   \"severity\": \"NORMAL\"   }   </pre>  Resolve a task.   Tasks can be resolved by setting the \'state\' attribute to \'RESOLVED\':  <pre> {   \"state\": \"RESOLVED\"   }   </pre>  <strong>Note:</strong> the supplied JSON object must contain a <code>version</code> that must match the server\'s version of the comment or the update will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the update. Look for the \'version\' attribute in the returned JSON structure.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Update pull request comment
     */
    async updateComment2Raw(requestParameters: UpdateComment2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateComment2().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling updateComment2().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling updateComment2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateComment2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restComment'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update a comment, with the following restrictions:   - only the author of the comment may update the <i>text</i> of the comment - only the author of the comment, the author of the pull request or repository admins and above may update the other fields of a comment </ul>   Convert a comment to a task or vice versa.   Comments can be converted to tasks by setting the \'severity\' attribute to \'BLOCKER\':   <pre> {   \"severity\": \"BLOCKER\"   }   </pre>  Tasks can be converted to comments by setting the \'severity\' attribute to \'NORMAL\':  <pre> {   \"severity\": \"NORMAL\"   }   </pre>  Resolve a task.   Tasks can be resolved by setting the \'state\' attribute to \'RESOLVED\':  <pre> {   \"state\": \"RESOLVED\"   }   </pre>  <strong>Note:</strong> the supplied JSON object must contain a <code>version</code> that must match the server\'s version of the comment or the update will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the update. Look for the \'version\' attribute in the returned JSON structure.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Update pull request comment
     */
    async updateComment2(requestParameters: UpdateComment2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.updateComment2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the default reviewer pull request condition for the given ID.
     * Update default reviewer condition
     */
    async updatePullRequestConditionRaw(requestParameters: UpdatePullRequestConditionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestCondition>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePullRequestCondition().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updatePullRequestCondition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/condition/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restDefaultReviewersRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the default reviewer pull request condition for the given ID.
     * Update default reviewer condition
     */
    async updatePullRequestCondition(requestParameters: UpdatePullRequestConditionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestCondition> {
        const response = await this.updatePullRequestConditionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the default reviewer pull request condition for the given ID.
     * Update default reviewer condition
     */
    async updatePullRequestCondition1Raw(requestParameters: UpdatePullRequestCondition1OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestCondition>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePullRequestCondition1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updatePullRequestCondition1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updatePullRequestCondition1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/default-reviewers/latest/projects/{projectKey}/repos/{repositorySlug}/condition/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['updatePullRequestCondition1Request'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the default reviewer pull request condition for the given ID.
     * Update default reviewer condition
     */
    async updatePullRequestCondition1(requestParameters: UpdatePullRequestCondition1OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestCondition> {
        const response = await this.updatePullRequestCondition1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Change the current user\'s status for a pull request. Implicitly adds the user as a participant if they are not already. If the current user is the author, this method will fail.   The possible values for {@code status} are <strong>UNAPPROVED</strong>, <strong>NEEDS_WORK</strong> (which is referred to as \"Requested changes\" in the frontend from 8.10 onward), or <strong>APPROVED</strong>.   If the new {@code status} is <strong>NEEDS_WORK</strong> or <strong>APPROVED</strong> then the {@code lastReviewedCommit} for the participant will be updated to the latest commit of the source branch of the pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Change pull request status
     */
    async updateStatusRaw(requestParameters: UpdateStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestParticipant>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateStatus().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling updateStatus().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling updateStatus().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateStatus().'
            );
        }

        if (requestParameters['restPullRequestAssignStatusRequest'] == null) {
            throw new runtime.RequiredError(
                'restPullRequestAssignStatusRequest',
                'Required parameter "restPullRequestAssignStatusRequest" was null or undefined when calling updateStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants/{userSlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestAssignStatusRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Change the current user\'s status for a pull request. Implicitly adds the user as a participant if they are not already. If the current user is the author, this method will fail.   The possible values for {@code status} are <strong>UNAPPROVED</strong>, <strong>NEEDS_WORK</strong> (which is referred to as \"Requested changes\" in the frontend from 8.10 onward), or <strong>APPROVED</strong>.   If the new {@code status} is <strong>NEEDS_WORK</strong> or <strong>APPROVED</strong> then the {@code lastReviewedCommit} for the participant will be updated to the latest commit of the source branch of the pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Change pull request status
     */
    async updateStatus(requestParameters: UpdateStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestParticipant> {
        const response = await this.updateStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add the authenticated user as a watcher for the specified pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Watch pull request
     */
    async watch1Raw(requestParameters: Watch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling watch1().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling watch1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling watch1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/watch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add the authenticated user as a watcher for the specified pull request.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.
     * Watch pull request
     */
    async watch1(requestParameters: Watch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.watch1Raw(requestParameters, initOverrides);
    }

    /**
     * Remove approval from a pull request as the current user. This does not remove the user as a participant.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.   <strong>Deprecated since 4.2</strong>. Use /rest/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants/{userSlug} instead
     * Unapprove pull request
     * @deprecated
     */
    async withdrawApprovalRaw(requestParameters: WithdrawApprovalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestParticipant>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling withdrawApproval().'
            );
        }

        if (requestParameters['pullRequestId'] == null) {
            throw new runtime.RequiredError(
                'pullRequestId',
                'Required parameter "pullRequestId" was null or undefined when calling withdrawApproval().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling withdrawApproval().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/approve`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"pullRequestId"}}`, encodeURIComponent(String(requestParameters['pullRequestId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Remove approval from a pull request as the current user. This does not remove the user as a participant.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this pull request targets to call this resource.   <strong>Deprecated since 4.2</strong>. Use /rest/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants/{userSlug} instead
     * Unapprove pull request
     * @deprecated
     */
    async withdrawApproval(requestParameters: WithdrawApprovalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestParticipant> {
        const response = await this.withdrawApprovalRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
