/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ExampleSettings,
  GetAll200Response,
  GetAllAccessTokens401Response,
  GetConfigurations200Response,
  GetDefaultTasks1200Response,
  GetGroups1200Response,
  GetGroupsWithAnyPermission200Response,
  GetProjects200Response,
  GetRepositoriesRecentlyAccessed200Response,
  GetRepositoryHooks1200Response,
  GetRestrictions1200Response,
  GetUsersWithAnyPermission1200Response,
  GetUsersWithoutAnyPermission200Response,
  RestAutoDeclineSettings,
  RestAutoDeclineSettingsRequest,
  RestAutoMergeProjectSettingsRequest,
  RestAutoMergeRestrictedSettings,
  RestBranch,
  RestDefaultTask,
  RestDefaultTaskRequest,
  RestDetailedInvocation,
  RestHookScriptConfig,
  RestHookScriptTriggers,
  RestMinimalRef,
  RestPermitted,
  RestProject,
  RestProjectSettingsRestriction,
  RestProjectSettingsRestrictionRequest,
  RestPullRequestSettings,
  RestRefRestriction,
  RestRepository,
  RestRepositoryHook,
  RestRestrictionRequest,
  RestWebhook,
  RestWebhookCredentials,
} from '../models/index';

interface AddDefaultTaskRequest {
    projectKey: string;
    restDefaultTaskRequest: RestDefaultTaskRequest;
}

interface Create3Request {
    projectKey: string;
    restProjectSettingsRestrictionRequest: RestProjectSettingsRestrictionRequest;
}

interface CreateProjectRequest {
    restProject?: Omit<RestProject, 'description'|'id'|'name'|'public'|'scope'|'type'>;
}

interface CreateRepositoryRequest {
    projectKey: string;
    restRepository?: Omit<RestRepository, 'archived'|'description'|'forkable'|'hierarchyId'|'id'|'partition'|'public'|'relatedLinks'|'scope'|'state'|'statusMessage'>;
}

interface CreateRestrictionsRequest {
    projectKey: string;
    restRestrictionRequest?: Array<RestRestrictionRequest>;
}

interface CreateWebhookRequest {
    projectKey: string;
    restWebhook?: RestWebhook;
}

interface Delete4Request {
    projectKey: string;
}

interface Delete9Request {
    projectKey: string;
    namespace: string;
    featureKey: string;
    componentKey?: string;
}

interface DeleteAllDefaultTasksRequest {
    projectKey: string;
}

interface DeleteAutoDeclineSettingsRequest {
    projectKey: string;
}

interface DeleteDefaultTaskRequest {
    projectKey: string;
    taskId: string;
}

interface DeleteProjectRequest {
    projectKey: string;
}

interface DeleteRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
}

interface DeleteRestrictionRequest {
    projectKey: string;
    id: string;
}

interface DeleteWebhookRequest {
    projectKey: string;
    webhookId: string;
}

interface DisableHookRequest {
    projectKey: string;
    hookKey: string;
}

interface EnableHookRequest {
    projectKey: string;
    hookKey: string;
    contentLength?: number;
}

interface FindWebhooksRequest {
    projectKey: string;
    event?: string;
    statistics?: boolean;
}

interface ForkRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
    restRepository?: Omit<RestRepository, 'archived'|'description'|'forkable'|'hierarchyId'|'id'|'partition'|'public'|'relatedLinks'|'scope'|'state'|'statusMessage'>;
}

interface Get4Request {
    projectKey: string;
}

interface Get7Request {
    projectKey: string;
    namespace: string;
    featureKey: string;
    componentKey?: string;
}

interface GetAllRequest {
    projectKey: string;
    namespace: string;
    featureKey: string;
    start?: number;
    limit?: number;
}

interface GetAutoDeclineSettingsRequest {
    projectKey: string;
}

interface GetAvatarRequest {
    hookKey: string;
    version?: string;
}

interface GetConfigurationsRequest {
    projectKey: string;
    start?: number;
    limit?: number;
}

interface GetDefaultBranch2Request {
    projectKey: string;
    repositorySlug: string;
}

interface GetDefaultTasksRequest {
    projectKey: string;
    markup?: string;
    start?: number;
    limit?: number;
}

interface GetForkedRepositoriesRequest {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetGroupsWithAnyPermission1Request {
    projectKey: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetGroupsWithoutAnyPermission1Request {
    projectKey: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetLatestInvocationRequest {
    projectKey: string;
    webhookId: string;
    event?: string;
    outcome?: string;
}

interface GetProjectRequest {
    projectKey: string;
}

interface GetProjectAvatarRequest {
    projectKey: string;
    s?: string;
}

interface GetProjectsRequest {
    name?: string;
    permission?: string;
    start?: number;
    limit?: number;
}

interface GetPullRequestSettingsRequest {
    projectKey: string;
    scmId: string;
}

interface GetRelatedRepositoriesRequest {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetRepositoriesRequest {
    projectKey: string;
    start?: number;
    limit?: number;
}

interface GetRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
}

interface GetRepositoryHookRequest {
    projectKey: string;
    hookKey: string;
}

interface GetRepositoryHooksRequest {
    projectKey: string;
    type?: GetRepositoryHooksTypeEnum;
    start?: number;
    limit?: number;
}

interface GetRestrictionRequest {
    projectKey: string;
    id: string;
}

interface GetRestrictionsRequest {
    projectKey: string;
    matcherType?: GetRestrictionsMatcherTypeEnum;
    matcherId?: string;
    type?: GetRestrictionsTypeEnum;
    start?: number;
    limit?: number;
}

interface GetSettingsRequest {
    projectKey: string;
    hookKey: string;
}

interface GetStatisticsRequest {
    projectKey: string;
    webhookId: string;
    event?: string;
}

interface GetStatisticsSummaryRequest {
    projectKey: string;
    webhookId: string;
}

interface GetUsersWithAnyPermission1Request {
    projectKey: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetUsersWithoutPermissionRequest {
    projectKey: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetWebhookRequest {
    projectKey: string;
    webhookId: string;
    statistics?: string;
}

interface HasAllUserPermissionRequest {
    projectKey: string;
    permission: string;
}

interface ModifyAllUserPermissionRequest {
    projectKey: string;
    permission: string;
    allow?: string;
}

interface RemoveConfigurationRequest {
    projectKey: string;
    scriptId: string;
}

interface RetryCreateRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
}

interface RevokePermissionsRequest {
    projectKey: string;
    user?: string;
    group?: string;
}

interface RevokePermissionsForGroup1Request {
    projectKey: string;
    name?: string;
}

interface RevokePermissionsForUser1Request {
    projectKey: string;
    name?: string;
}

interface SearchPermissionsRequest {
    projectKey: string;
    permission?: string;
    filterText?: string;
    type?: string;
}

interface SetRequest {
    projectKey: string;
    restAutoMergeProjectSettingsRequest?: RestAutoMergeProjectSettingsRequest;
}

interface SetAutoDeclineSettingsRequest {
    projectKey: string;
    restAutoDeclineSettingsRequest?: RestAutoDeclineSettingsRequest;
}

interface SetConfigurationRequest {
    projectKey: string;
    scriptId: string;
    restHookScriptTriggers?: RestHookScriptTriggers;
}

interface SetDefaultBranch2Request {
    projectKey: string;
    repositorySlug: string;
    restBranch?: Omit<RestBranch, 'default'|'displayId'|'latestChangeset'|'latestCommit'>;
}

interface SetPermissionForGroups1Request {
    projectKey: string;
    name?: string;
    permission?: string;
}

interface SetPermissionForUsers1Request {
    projectKey: string;
    name?: string;
    permission?: string;
}

interface SetSettingsRequest {
    projectKey: string;
    hookKey: string;
    exampleSettings?: ExampleSettings;
}

interface StreamContributingRequest {
    projectKey: string;
    repositorySlug: string;
    at?: string;
    markup?: string;
    htmlEscape?: string;
    includeHeadingId?: string;
    hardwrap?: string;
}

interface StreamLicenseRequest {
    projectKey: string;
    repositorySlug: string;
    at?: string;
    markup?: string;
    htmlEscape?: string;
    includeHeadingId?: string;
    hardwrap?: string;
}

interface StreamReadmeRequest {
    projectKey: string;
    repositorySlug: string;
    at?: string;
    markup?: string;
    htmlEscape?: string;
    includeHeadingId?: string;
    hardwrap?: string;
}

interface TestWebhookRequest {
    projectKey: string;
    webhookId?: number;
    sslVerificationRequired?: boolean;
    url?: string;
    restWebhookCredentials?: RestWebhookCredentials;
}

interface UpdateDefaultTaskRequest {
    projectKey: string;
    taskId: string;
    restDefaultTaskRequest: RestDefaultTaskRequest;
}

interface UpdateProjectRequest {
    projectKey: string;
    restProject?: Omit<RestProject, 'description'|'id'|'name'|'public'|'scope'|'type'>;
}

interface UpdatePullRequestSettingsRequest {
    projectKey: string;
    scmId: string;
    restPullRequestSettings?: RestPullRequestSettings;
}

interface UpdateRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
    restRepository?: Omit<RestRepository, 'archived'|'description'|'forkable'|'hierarchyId'|'id'|'partition'|'public'|'relatedLinks'|'scope'|'state'|'statusMessage'>;
}

interface UpdateWebhookRequest {
    projectKey: string;
    webhookId: string;
    restWebhook?: RestWebhook;
}

interface UploadAvatarRequest {
    projectKey: string;
    avatar?: Blob;
}

/**
 * 
 */
export class ProjectApi extends runtime.BaseAPI {

    /**
     * Creates a default task for the project.  The authenticated user must have **PROJECT_ADMIN** permission for this project to call the resource.
     * Add a default task
     */
    async addDefaultTaskRaw(requestParameters: AddDefaultTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDefaultTask>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addDefaultTask().'
            );
        }

        if (requestParameters['restDefaultTaskRequest'] == null) {
            throw new runtime.RequiredError(
                'restDefaultTaskRequest',
                'Required parameter "restDefaultTaskRequest" was null or undefined when calling addDefaultTask().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/default-tasks/latest/projects/{projectKey}/tasks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restDefaultTaskRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a default task for the project.  The authenticated user must have **PROJECT_ADMIN** permission for this project to call the resource.
     * Add a default task
     */
    async addDefaultTask(requestParameters: AddDefaultTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDefaultTask> {
        const response = await this.addDefaultTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new project settings restriction for the given project.  The authenticated user must have **PROJECT_ADMIN** permission for the target project to create a settings restriction.
     * Enforce project restriction
     */
    async create3Raw(requestParameters: Create3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProjectSettingsRestriction>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling create3().'
            );
        }

        if (requestParameters['restProjectSettingsRestrictionRequest'] == null) {
            throw new runtime.RequiredError(
                'restProjectSettingsRestrictionRequest',
                'Required parameter "restProjectSettingsRestrictionRequest" was null or undefined when calling create3().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings-restriction`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restProjectSettingsRestrictionRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new project settings restriction for the given project.  The authenticated user must have **PROJECT_ADMIN** permission for the target project to create a settings restriction.
     * Enforce project restriction
     */
    async create3(requestParameters: Create3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProjectSettingsRestriction> {
        const response = await this.create3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new project.   To include a custom avatar for the project, the project definition should contain an additional attribute with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI should be in the following format: <pre>    data:(content type, e.g. image/png);base64,(data) </pre>If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is otherwise invalid, <em>project creation will fail</em>.   The authenticated user must have <strong>PROJECT_CREATE</strong> permission to call this resource.
     * Create a new project
     */
    async createProjectRaw(requestParameters: CreateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restProject'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new project.   To include a custom avatar for the project, the project definition should contain an additional attribute with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI should be in the following format: <pre>    data:(content type, e.g. image/png);base64,(data) </pre>If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is otherwise invalid, <em>project creation will fail</em>.   The authenticated user must have <strong>PROJECT_CREATE</strong> permission to call this resource.
     * Create a new project
     */
    async createProject(requestParameters: CreateProjectRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.createProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new repository. Requires an existing project in which this repository will be created. The only parameters which will be used are name and scmId.   The authenticated user must have <strong>REPO_CREATE</strong> permission or higher, for the context project to call this resource.
     * Create repository
     */
    async createRepositoryRaw(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepository'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new repository. Requires an existing project in which this repository will be created. The only parameters which will be used are name and scmId.   The authenticated user must have <strong>REPO_CREATE</strong> permission or higher, for the context project to call this resource.
     * Create repository
     */
    async createRepository(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.createRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows creating multiple restrictions at once.
     * Create multiple ref restrictions
     */
    async createRestrictionsRaw(requestParameters: CreateRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefRestriction>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createRestrictions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/vnd.atl.bitbucket.bulk+json';

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/restrictions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRestrictionRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Allows creating multiple restrictions at once.
     * Create multiple ref restrictions
     */
    async createRestrictions(requestParameters: CreateRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefRestriction> {
        const response = await this.createRestrictionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a webhook for the project specified via the URL.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Create webhook
     */
    async createWebhookRaw(requestParameters: CreateWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestWebhook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createWebhook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restWebhook'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a webhook for the project specified via the URL.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Create webhook
     */
    async createWebhook(requestParameters: CreateWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestWebhook> {
        const response = await this.createWebhookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes pull request auto-merge settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Delete pull request auto-merge settings
     */
    async delete4Raw(requestParameters: Delete4Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling delete4().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-merge`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes pull request auto-merge settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Delete pull request auto-merge settings
     */
    async delete4(requestParameters: Delete4Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete4Raw(requestParameters, initOverrides);
    }

    /**
     * Delete a specified project settings restriction.  If a restriction does not exist for the specified project, namespace, featureKey, and componentKey, the request will be ignored and a 204 response will be returned.  The authenticated user must have **PROJECT_ADMIN** permission for the target project to delete a settings restriction.
     * Stop enforcing project restriction
     */
    async delete9Raw(requestParameters: Delete9Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling delete9().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling delete9().'
            );
        }

        if (requestParameters['featureKey'] == null) {
            throw new runtime.RequiredError(
                'featureKey',
                'Required parameter "featureKey" was null or undefined when calling delete9().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['namespace'] != null) {
            queryParameters['namespace'] = requestParameters['namespace'];
        }

        if (requestParameters['componentKey'] != null) {
            queryParameters['componentKey'] = requestParameters['componentKey'];
        }

        if (requestParameters['featureKey'] != null) {
            queryParameters['featureKey'] = requestParameters['featureKey'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings-restriction`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specified project settings restriction.  If a restriction does not exist for the specified project, namespace, featureKey, and componentKey, the request will be ignored and a 204 response will be returned.  The authenticated user must have **PROJECT_ADMIN** permission for the target project to delete a settings restriction.
     * Stop enforcing project restriction
     */
    async delete9(requestParameters: Delete9Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete9Raw(requestParameters, initOverrides);
    }

    /**
     * Delete all the default tasks for the supplied project  The authenticated user must have **PROJECT_ADMIN** permission for this project to call the resource.
     * Deletes all default tasks for the project
     */
    async deleteAllDefaultTasksRaw(requestParameters: DeleteAllDefaultTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteAllDefaultTasks().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/default-tasks/latest/projects/{projectKey}/tasks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete all the default tasks for the supplied project  The authenticated user must have **PROJECT_ADMIN** permission for this project to call the resource.
     * Deletes all default tasks for the project
     */
    async deleteAllDefaultTasks(requestParameters: DeleteAllDefaultTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAllDefaultTasksRaw(requestParameters, initOverrides);
    }

    /**
     * Delete auto decline settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Delete auto decline settings
     */
    async deleteAutoDeclineSettingsRaw(requestParameters: DeleteAutoDeclineSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteAutoDeclineSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete auto decline settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Delete auto decline settings
     */
    async deleteAutoDeclineSettings(requestParameters: DeleteAutoDeclineSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAutoDeclineSettingsRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a specific default task for a project.  The authenticated user must have **PROJECT_ADMIN** permission for this project to call the resource.
     * Delete a specific default task
     */
    async deleteDefaultTaskRaw(requestParameters: DeleteDefaultTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteDefaultTask().'
            );
        }

        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling deleteDefaultTask().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/default-tasks/latest/projects/{projectKey}/tasks/{taskId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specific default task for a project.  The authenticated user must have **PROJECT_ADMIN** permission for this project to call the resource.
     * Delete a specific default task
     */
    async deleteDefaultTask(requestParameters: DeleteDefaultTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteDefaultTaskRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Delete project
     */
    async deleteProjectRaw(requestParameters: DeleteProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Delete project
     */
    async deleteProject(requestParameters: DeleteProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Schedule the repository matching the supplied <strong>projectKey</strong> and <strong>repositorySlug</strong> to be deleted.   The authenticated user must have sufficient permissions specified by the repository delete policy to call this resource. The default permission required is <strong>REPO_ADMIN</strong> permission.
     * Delete repository
     */
    async deleteRepositoryRaw(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Schedule the repository matching the supplied <strong>projectKey</strong> and <strong>repositorySlug</strong> to be deleted.   The authenticated user must have sufficient permissions specified by the repository delete policy to call this resource. The default permission required is <strong>REPO_ADMIN</strong> permission.
     * Delete repository
     */
    async deleteRepository(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a restriction as specified by a restriction id.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Delete a ref restriction
     */
    async deleteRestrictionRaw(requestParameters: DeleteRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteRestriction().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteRestriction().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/restrictions/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a restriction as specified by a restriction id.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Delete a ref restriction
     */
    async deleteRestriction(requestParameters: DeleteRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRestrictionRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a webhook for the project specified via the URL.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Delete webhook
     */
    async deleteWebhookRaw(requestParameters: DeleteWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteWebhook().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling deleteWebhook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks/{webhookId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a webhook for the project specified via the URL.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Delete webhook
     */
    async deleteWebhook(requestParameters: DeleteWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWebhookRaw(requestParameters, initOverrides);
    }

    /**
     * Disable a repository hook for this project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Disable repository hook
     */
    async disableHookRaw(requestParameters: DisableHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling disableHook().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling disableHook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}/enabled`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Disable a repository hook for this project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Disable repository hook
     */
    async disableHook(requestParameters: DisableHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.disableHookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable a repository hook for this project and optionally apply new configuration.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.   A JSON document may be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     * Enable repository hook
     */
    async enableHookRaw(requestParameters: EnableHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling enableHook().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling enableHook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['contentLength'] != null) {
            headerParameters['Content-Length'] = String(requestParameters['contentLength']);
        }

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}/enabled`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enable a repository hook for this project and optionally apply new configuration.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.   A JSON document may be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     * Enable repository hook
     */
    async enableHook(requestParameters: EnableHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.enableHookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find webhooks in this project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Find webhooks
     */
    async findWebhooksRaw(requestParameters: FindWebhooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling findWebhooks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['event'] != null) {
            queryParameters['event'] = requestParameters['event'];
        }

        if (requestParameters['statistics'] != null) {
            queryParameters['statistics'] = requestParameters['statistics'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Find webhooks in this project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Find webhooks
     */
    async findWebhooks(requestParameters: FindWebhooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.findWebhooksRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new repository forked from an existing repository.   The JSON body for this <code>POST</code> is not required to contain <i>any</i> properties. Even the name may be omitted. The following properties will be used, if provided:   - <code>\"name\":\"Fork name\"</code> - Specifies the forked repository\'s name    - Defaults to the name of the origin repository if not specified - <code>\"defaultBranch\":\"main\"</code> - Specifies the forked repository\'s default branch   - Defaults to the origin repository\'s default branch if not specified - <code>\"project\":{\"key\":\"TARGET_KEY\"}</code> - Specifies the forked repository\'s target project by key   - Defaults to the current user\'s personal project if not specified   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository and <strong>PROJECT_ADMIN</strong> on the target project to call this resource. Note that users <i>always</i> have <b>PROJECT_ADMIN</b> permission on their personal projects.
     * Fork repository
     */
    async forkRepositoryRaw(requestParameters: ForkRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling forkRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling forkRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepository'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new repository forked from an existing repository.   The JSON body for this <code>POST</code> is not required to contain <i>any</i> properties. Even the name may be omitted. The following properties will be used, if provided:   - <code>\"name\":\"Fork name\"</code> - Specifies the forked repository\'s name    - Defaults to the name of the origin repository if not specified - <code>\"defaultBranch\":\"main\"</code> - Specifies the forked repository\'s default branch   - Defaults to the origin repository\'s default branch if not specified - <code>\"project\":{\"key\":\"TARGET_KEY\"}</code> - Specifies the forked repository\'s target project by key   - Defaults to the current user\'s personal project if not specified   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository and <strong>PROJECT_ADMIN</strong> on the target project to call this resource. Note that users <i>always</i> have <b>PROJECT_ADMIN</b> permission on their personal projects.
     * Fork repository
     */
    async forkRepository(requestParameters: ForkRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.forkRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the pull request auto-merge settings for the supplied project. Default settings will be returned if no explicit settings have been set for the project  The authenticated user must have <strong>PROJECT_VIEW</strong> permission for this project to call the resource.
     * Get pull request auto-merge settings
     */
    async get4Raw(requestParameters: Get4Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoMergeRestrictedSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling get4().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-merge`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the pull request auto-merge settings for the supplied project. Default settings will be returned if no explicit settings have been set for the project  The authenticated user must have <strong>PROJECT_VIEW</strong> permission for this project to call the resource.
     * Get pull request auto-merge settings
     */
    async get4(requestParameters: Get4Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoMergeRestrictedSettings> {
        const response = await this.get4Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a specified project settings restriction for the given namespace, feature key and component key. Note that not providing the component key will **not** return restrictions for the namespace and feature key with a component key set.  The authenticated user must have **PROJECT_VIEW** permission for the target project to retrieve a settings restriction.
     * Get enforcing project setting
     */
    async get7Raw(requestParameters: Get7Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProjectSettingsRestriction>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling get7().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling get7().'
            );
        }

        if (requestParameters['featureKey'] == null) {
            throw new runtime.RequiredError(
                'featureKey',
                'Required parameter "featureKey" was null or undefined when calling get7().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['namespace'] != null) {
            queryParameters['namespace'] = requestParameters['namespace'];
        }

        if (requestParameters['componentKey'] != null) {
            queryParameters['componentKey'] = requestParameters['componentKey'];
        }

        if (requestParameters['featureKey'] != null) {
            queryParameters['featureKey'] = requestParameters['featureKey'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings-restriction`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a specified project settings restriction for the given namespace, feature key and component key. Note that not providing the component key will **not** return restrictions for the namespace and feature key with a component key set.  The authenticated user must have **PROJECT_VIEW** permission for the target project to retrieve a settings restriction.
     * Get enforcing project setting
     */
    async get7(requestParameters: Get7Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProjectSettingsRestriction> {
        const response = await this.get7Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all project settings restrictions for the given namespace and feature key, including those with a component key set.  The authenticated user must have **PROJECT_VIEW** permission for the target project to retrieve a settings restrictions.
     * Get all enforcing project settings
     */
    async getAllRaw(requestParameters: GetAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAll200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAll().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling getAll().'
            );
        }

        if (requestParameters['featureKey'] == null) {
            throw new runtime.RequiredError(
                'featureKey',
                'Required parameter "featureKey" was null or undefined when calling getAll().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['namespace'] != null) {
            queryParameters['namespace'] = requestParameters['namespace'];
        }

        if (requestParameters['featureKey'] != null) {
            queryParameters['featureKey'] = requestParameters['featureKey'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings-restriction/all`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all project settings restrictions for the given namespace and feature key, including those with a component key set.  The authenticated user must have **PROJECT_VIEW** permission for the target project to retrieve a settings restrictions.
     * Get all enforcing project settings
     */
    async getAll(requestParameters: GetAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAll200Response> {
        const response = await this.getAllRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the auto decline settings for the supplied project. Default settings are returned if no explicit settings have been set for the project.
     * Get auto decline settings
     */
    async getAutoDeclineSettingsRaw(requestParameters: GetAutoDeclineSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoDeclineSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAutoDeclineSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the auto decline settings for the supplied project. Default settings are returned if no explicit settings have been set for the project.
     * Get auto decline settings
     */
    async getAutoDeclineSettings(requestParameters: GetAutoDeclineSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoDeclineSettings> {
        const response = await this.getAutoDeclineSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>moduleKey</strong>.
     * Get project avatar
     */
    async getAvatarRaw(requestParameters: GetAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling getAvatar().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/hooks/{hookKey}/avatar`.replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>moduleKey</strong>.
     * Get project avatar
     */
    async getAvatar(requestParameters: GetAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAvatarRaw(requestParameters, initOverrides);
    }

    /**
     * Return a page of hook scripts configured for the specified project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Get configured hook scripts
     */
    async getConfigurationsRaw(requestParameters: GetConfigurationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetConfigurations200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getConfigurations().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/hook-scripts`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return a page of hook scripts configured for the specified project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Get configured hook scripts
     */
    async getConfigurations(requestParameters: GetConfigurationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetConfigurations200Response> {
        const response = await this.getConfigurationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the repository\'s <i>configured</i> default branch.   Every repository has a <i>configured</i> default branch, but that branch may not actually <i>exist</i> in the repository. For example, a newly-created repository will have a configured default branch even though no branches have been pushed yet.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository default branch
     */
    async getDefaultBranch2Raw(requestParameters: GetDefaultBranch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMinimalRef>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getDefaultBranch2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getDefaultBranch2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/default-branch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the repository\'s <i>configured</i> default branch.   Every repository has a <i>configured</i> default branch, but that branch may not actually <i>exist</i> in the repository. For example, a newly-created repository will have a configured default branch even though no branches have been pushed yet.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository default branch
     */
    async getDefaultBranch2(requestParameters: GetDefaultBranch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMinimalRef> {
        const response = await this.getDefaultBranch2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the default tasks for the supplied project.  The authenticated user must have **PROJECT_VIEW** permission for this project to call the resource.
     * Get a page of default tasks
     */
    async getDefaultTasksRaw(requestParameters: GetDefaultTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetDefaultTasks1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getDefaultTasks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['markup'] != null) {
            queryParameters['markup'] = requestParameters['markup'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/default-tasks/latest/projects/{projectKey}/tasks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the default tasks for the supplied project.  The authenticated user must have **PROJECT_VIEW** permission for this project to call the resource.
     * Get a page of default tasks
     */
    async getDefaultTasks(requestParameters: GetDefaultTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetDefaultTasks1200Response> {
        const response = await this.getDefaultTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve repositories which have been forked from this one. Unlike #getRelatedRepositories(Repository, PageRequest) related repositories, this only looks at a given repository\'s direct forks. If those forks have themselves been the origin of more forks, such \"grandchildren\" repositories will not be retrieved.   Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included, even if other repositories have been forked from this one.
     * Get repository forks
     */
    async getForkedRepositoriesRaw(requestParameters: GetForkedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForkedRepositories().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getForkedRepositories().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/forks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve repositories which have been forked from this one. Unlike #getRelatedRepositories(Repository, PageRequest) related repositories, this only looks at a given repository\'s direct forks. If those forks have themselves been the origin of more forks, such \"grandchildren\" repositories will not be retrieved.   Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included, even if other repositories have been forked from this one.
     * Get repository forks
     */
    async getForkedRepositories(requestParameters: GetForkedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.getForkedRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups that have been granted at least one permission for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get groups with permission to project
     */
    async getGroupsWithAnyPermission1Raw(requestParameters: GetGroupsWithAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroupsWithAnyPermission200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getGroupsWithAnyPermission1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups that have been granted at least one permission for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get groups with permission to project
     */
    async getGroupsWithAnyPermission1(requestParameters: GetGroupsWithAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroupsWithAnyPermission200Response> {
        const response = await this.getGroupsWithAnyPermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups that have no granted permissions for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher
     * Get groups without project permission
     */
    async getGroupsWithoutAnyPermission1Raw(requestParameters: GetGroupsWithoutAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroups1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getGroupsWithoutAnyPermission1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/groups/none`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups that have no granted permissions for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher
     * Get groups without project permission
     */
    async getGroupsWithoutAnyPermission1(requestParameters: GetGroupsWithoutAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroups1200Response> {
        const response = await this.getGroupsWithoutAnyPermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the latest invocations for a specific webhook.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Get last webhook invocation details
     */
    async getLatestInvocationRaw(requestParameters: GetLatestInvocationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDetailedInvocation>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getLatestInvocation().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getLatestInvocation().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['event'] != null) {
            queryParameters['event'] = requestParameters['event'];
        }

        if (requestParameters['outcome'] != null) {
            queryParameters['outcome'] = requestParameters['outcome'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks/{webhookId}/latest`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the latest invocations for a specific webhook.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Get last webhook invocation details
     */
    async getLatestInvocation(requestParameters: GetLatestInvocationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDetailedInvocation> {
        const response = await this.getLatestInvocationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project to call this resource.
     * Get a project
     */
    async getProjectRaw(requestParameters: GetProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project to call this resource.
     * Get a project
     */
    async getProject(requestParameters: GetProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.getProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project to call this resource.
     * Get avatar for project
     */
    async getProjectAvatarRaw(requestParameters: GetProjectAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getProjectAvatar().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/avatar.png`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project to call this resource.
     * Get avatar for project
     */
    async getProjectAvatar(requestParameters: GetProjectAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getProjectAvatarRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a page of projects.   Only projects for which the authenticated user has the <strong>PROJECT_VIEW</strong> permission will be returned.
     * Get projects
     */
    async getProjectsRaw(requestParameters: GetProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetProjects200Response>> {
        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of projects.   Only projects for which the authenticated user has the <strong>PROJECT_VIEW</strong> permission will be returned.
     * Get projects
     */
    async getProjects(requestParameters: GetProjectsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetProjects200Response> {
        const response = await this.getProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the merge strategy configuration for this project and SCM.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the context repository to call this resource.
     * Get merge strategy
     */
    async getPullRequestSettingsRaw(requestParameters: GetPullRequestSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPullRequestSettings().'
            );
        }

        if (requestParameters['scmId'] == null) {
            throw new runtime.RequiredError(
                'scmId',
                'Required parameter "scmId" was null or undefined when calling getPullRequestSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/pull-requests/{scmId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"scmId"}}`, encodeURIComponent(String(requestParameters['scmId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the merge strategy configuration for this project and SCM.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the context repository to call this resource.
     * Get merge strategy
     */
    async getPullRequestSettings(requestParameters: GetPullRequestSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestSettings> {
        const response = await this.getPullRequestSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve repositories which are related to this one. Related repositories are from the same Repository#getHierarchyId() hierarchy as this repository.   Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included, even if more repositories are part of this repository\'s hierarchy.
     * Get related repository
     */
    async getRelatedRepositoriesRaw(requestParameters: GetRelatedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRelatedRepositories().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getRelatedRepositories().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/related`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve repositories which are related to this one. Related repositories are from the same Repository#getHierarchyId() hierarchy as this repository.   Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included, even if more repositories are part of this repository\'s hierarchy.
     * Get related repository
     */
    async getRelatedRepositories(requestParameters: GetRelatedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.getRelatedRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve repositories from the project corresponding to the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repositories for project
     */
    async getRepositoriesRaw(requestParameters: GetRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRepositories().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve repositories from the project corresponding to the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repositories for project
     */
    async getRepositories(requestParameters: GetRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.getRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the repository matching the supplied <strong>projectKey</strong> and <strong>repositorySlug</strong>.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository
     */
    async getRepositoryRaw(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the repository matching the supplied <strong>projectKey</strong> and <strong>repositorySlug</strong>.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository
     */
    async getRepository(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.getRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a repository hook for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get a repository hook
     */
    async getRepositoryHookRaw(requestParameters: GetRepositoryHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRepositoryHook().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling getRepositoryHook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a repository hook for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get a repository hook
     */
    async getRepositoryHook(requestParameters: GetRepositoryHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.getRepositoryHookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of repository hooks for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repository hooks
     */
    async getRepositoryHooksRaw(requestParameters: GetRepositoryHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoryHooks1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRepositoryHooks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of repository hooks for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repository hooks
     */
    async getRepositoryHooks(requestParameters: GetRepositoryHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoryHooks1200Response> {
        const response = await this.getRepositoryHooksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a restriction as specified by a restriction id.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Get a ref restriction
     */
    async getRestrictionRaw(requestParameters: GetRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefRestriction>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRestriction().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRestriction().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/restrictions/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a restriction as specified by a restriction id.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Get a ref restriction
     */
    async getRestriction(requestParameters: GetRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefRestriction> {
        const response = await this.getRestrictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for restrictions using the supplied parameters.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Search for ref restrictions
     */
    async getRestrictionsRaw(requestParameters: GetRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRestrictions1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRestrictions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['matcherType'] != null) {
            queryParameters['matcherType'] = requestParameters['matcherType'];
        }

        if (requestParameters['matcherId'] != null) {
            queryParameters['matcherId'] = requestParameters['matcherId'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/restrictions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for restrictions using the supplied parameters.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Search for ref restrictions
     */
    async getRestrictions(requestParameters: GetRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRestrictions1200Response> {
        const response = await this.getRestrictionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the settings for a repository hook for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repository hook settings
     */
    async getSettingsRaw(requestParameters: GetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getSettings().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling getSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}/settings`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the settings for a repository hook for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repository hook settings
     */
    async getSettings(requestParameters: GetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleSettings> {
        const response = await this.getSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the statistics for a specific webhook.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Get webhook statistics
     */
    async getStatisticsRaw(requestParameters: GetStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getStatistics().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getStatistics().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['event'] != null) {
            queryParameters['event'] = requestParameters['event'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks/{webhookId}/statistics`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get the statistics for a specific webhook.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Get webhook statistics
     */
    async getStatistics(requestParameters: GetStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getStatisticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the statistics summary for a specific webhook.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Get webhook statistics summary
     */
    async getStatisticsSummaryRaw(requestParameters: GetStatisticsSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getStatisticsSummary().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getStatisticsSummary().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks/{webhookId}/statistics/summary`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get the statistics summary for a specific webhook.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Get webhook statistics summary
     */
    async getStatisticsSummary(requestParameters: GetStatisticsSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any | null | undefined > {
        const response = await this.getStatisticsSummaryRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Retrieve a page of users that have been granted at least one permission for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get users with permission to project
     */
    async getUsersWithAnyPermission1Raw(requestParameters: GetUsersWithAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUsersWithAnyPermission1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getUsersWithAnyPermission1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of users that have been granted at least one permission for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get users with permission to project
     */
    async getUsersWithAnyPermission1(requestParameters: GetUsersWithAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUsersWithAnyPermission1200Response> {
        const response = await this.getUsersWithAnyPermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of <i>licensed</i> users that have no granted permissions for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get users without project permission
     */
    async getUsersWithoutPermissionRaw(requestParameters: GetUsersWithoutPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUsersWithoutAnyPermission200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getUsersWithoutPermission().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/users/none`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of <i>licensed</i> users that have no granted permissions for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get users without project permission
     */
    async getUsersWithoutPermission(requestParameters: GetUsersWithoutPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUsersWithoutAnyPermission200Response> {
        const response = await this.getUsersWithoutPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a webhook by ID.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Get webhook
     */
    async getWebhookRaw(requestParameters: GetWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestWebhook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getWebhook().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getWebhook().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['statistics'] != null) {
            queryParameters['statistics'] = requestParameters['statistics'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks/{webhookId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a webhook by ID.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Get webhook
     */
    async getWebhook(requestParameters: GetWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestWebhook> {
        const response = await this.getWebhookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check whether the specified permission is the default permission (granted to all users) for a project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Check default project permission
     */
    async hasAllUserPermissionRaw(requestParameters: HasAllUserPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPermitted>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling hasAllUserPermission().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling hasAllUserPermission().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/{permission}/all`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Check whether the specified permission is the default permission (granted to all users) for a project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Check default project permission
     */
    async hasAllUserPermission(requestParameters: HasAllUserPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPermitted> {
        const response = await this.hasAllUserPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Grant or revoke a project permission to all users, i.e. set the default permission.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Grant project permission
     */
    async modifyAllUserPermissionRaw(requestParameters: ModifyAllUserPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling modifyAllUserPermission().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling modifyAllUserPermission().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['allow'] != null) {
            queryParameters['allow'] = requestParameters['allow'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/{permission}/all`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Grant or revoke a project permission to all users, i.e. set the default permission.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Grant project permission
     */
    async modifyAllUserPermission(requestParameters: ModifyAllUserPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.modifyAllUserPermissionRaw(requestParameters, initOverrides);
    }

    /**
     * Removes the hook script from the set of hook scripts configured to run in all repositories under the project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Remove a hook script
     */
    async removeConfigurationRaw(requestParameters: RemoveConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling removeConfiguration().'
            );
        }

        if (requestParameters['scriptId'] == null) {
            throw new runtime.RequiredError(
                'scriptId',
                'Required parameter "scriptId" was null or undefined when calling removeConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/hook-scripts/{scriptId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters['scriptId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes the hook script from the set of hook scripts configured to run in all repositories under the project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Remove a hook script
     */
    async removeConfiguration(requestParameters: RemoveConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     * If a create or fork operation fails, calling this method will clean up the broken repository and try again. The repository must be in an INITIALISATION_FAILED state.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Retry repository creation
     */
    async retryCreateRepositoryRaw(requestParameters: RetryCreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling retryCreateRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling retryCreateRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/recreate`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * If a create or fork operation fails, calling this method will clean up the broken repository and try again. The repository must be in an INITIALISATION_FAILED state.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Retry repository creation
     */
    async retryCreateRepository(requestParameters: RetryCreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.retryCreateRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revoke all permissions for the specified project for the given groups and users.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permission if their own permission would be revoked as a result, nor may they revoke their own permission unless they have a global permission that already implies that permission.
     * Revoke project permissions
     */
    async revokePermissionsRaw(requestParameters: RevokePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokePermissions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        if (requestParameters['group'] != null) {
            queryParameters['group'] = requestParameters['group'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all permissions for the specified project for the given groups and users.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permission if their own permission would be revoked as a result, nor may they revoke their own permission unless they have a global permission that already implies that permission.
     * Revoke project permissions
     */
    async revokePermissions(requestParameters: RevokePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsRaw(requestParameters, initOverrides);
    }

    /**
     *  Revoke all permissions for the specified project for a group.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permissions if it will reduce their own permission level.
     * Revoke group project permission
     */
    async revokePermissionsForGroup1Raw(requestParameters: RevokePermissionsForGroup1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokePermissionsForGroup1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Revoke all permissions for the specified project for a group.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permissions if it will reduce their own permission level.
     * Revoke group project permission
     */
    async revokePermissionsForGroup1(requestParameters: RevokePermissionsForGroup1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsForGroup1Raw(requestParameters, initOverrides);
    }

    /**
     * Revoke all permissions for the specified project for a user.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke their own project permissions if they do not have a higher global permission.
     * Revoke user project permission
     */
    async revokePermissionsForUser1Raw(requestParameters: RevokePermissionsForUser1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokePermissionsForUser1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all permissions for the specified project for a user.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke their own project permissions if they do not have a higher global permission.
     * Revoke user project permission
     */
    async revokePermissionsForUser1(requestParameters: RevokePermissionsForUser1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsForUser1Raw(requestParameters, initOverrides);
    }

    /**
     * Search direct and implied permissions of principals (users and groups). This endpoint returns a superset of the results returned by the /users and /groups endpoints because it allows filtering by global permissions too.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Search project permissions
     */
    async searchPermissionsRaw(requestParameters: SearchPermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling searchPermissions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['filterText'] != null) {
            queryParameters['filterText'] = requestParameters['filterText'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/search`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Search direct and implied permissions of principals (users and groups). This endpoint returns a superset of the results returned by the /users and /groups endpoints because it allows filtering by global permissions too.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Search project permissions
     */
    async searchPermissions(requestParameters: SearchPermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.searchPermissionsRaw(requestParameters, initOverrides);
    }

    /**
     * Creates or updates the pull request auto-merge settings for the supplied project, and applies the restriction action specified in the request.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Create or update the pull request auto-merge settings
     */
    async setRaw(requestParameters: SetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoMergeRestrictedSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling set().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-merge`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAutoMergeProjectSettingsRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates or updates the pull request auto-merge settings for the supplied project, and applies the restriction action specified in the request.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Create or update the pull request auto-merge settings
     */
    async set(requestParameters: SetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoMergeRestrictedSettings> {
        const response = await this.setRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates or updates the auto decline settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Create/Update auto decline settings
     */
    async setAutoDeclineSettingsRaw(requestParameters: SetAutoDeclineSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoDeclineSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setAutoDeclineSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAutoDeclineSettingsRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates or updates the auto decline settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Create/Update auto decline settings
     */
    async setAutoDeclineSettings(requestParameters: SetAutoDeclineSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoDeclineSettings> {
        const response = await this.setAutoDeclineSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates/updates the hook script configuration for the provided hook script and project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Create/update a hook script
     */
    async setConfigurationRaw(requestParameters: SetConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestHookScriptConfig>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setConfiguration().'
            );
        }

        if (requestParameters['scriptId'] == null) {
            throw new runtime.RequiredError(
                'scriptId',
                'Required parameter "scriptId" was null or undefined when calling setConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/hook-scripts/{scriptId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters['scriptId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restHookScriptTriggers'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates/updates the hook script configuration for the provided hook script and project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Create/update a hook script
     */
    async setConfiguration(requestParameters: SetConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestHookScriptConfig> {
        const response = await this.setConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the default branch of a repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update default branch for repository
     */
    async setDefaultBranch2Raw(requestParameters: SetDefaultBranch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setDefaultBranch2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setDefaultBranch2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/default-branch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restBranch'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the default branch of a repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update default branch for repository
     */
    async setDefaultBranch2(requestParameters: SetDefaultBranch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setDefaultBranch2Raw(requestParameters, initOverrides);
    }

    /**
     * Promote or demote a group\'s permission level for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource. In addition, a user may not demote a group\'s permission level if theirown permission level would be reduced as a result.
     * Update group project permission
     */
    async setPermissionForGroups1Raw(requestParameters: SetPermissionForGroups1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setPermissionForGroups1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote or demote a group\'s permission level for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource. In addition, a user may not demote a group\'s permission level if theirown permission level would be reduced as a result.
     * Update group project permission
     */
    async setPermissionForGroups1(requestParameters: SetPermissionForGroups1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPermissionForGroups1Raw(requestParameters, initOverrides);
    }

    /**
     * Promote or demote a user\'s permission level for the specified project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource. In addition, a user may not reduce their own permission level unless they have a global permission that already implies that permission.
     * Update user project permission
     */
    async setPermissionForUsers1Raw(requestParameters: SetPermissionForUsers1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setPermissionForUsers1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote or demote a user\'s permission level for the specified project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource. In addition, a user may not reduce their own permission level unless they have a global permission that already implies that permission.
     * Update user project permission
     */
    async setPermissionForUsers1(requestParameters: SetPermissionForUsers1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPermissionForUsers1Raw(requestParameters, initOverrides);
    }

    /**
     * Modify the settings for a repository hook for this project.   The service will reject any settings which are too large, the current limit is 32KB once serialized.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.   A JSON document can be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     * Update repository hook settings
     */
    async setSettingsRaw(requestParameters: SetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setSettings().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling setSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}/settings`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['exampleSettings'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify the settings for a repository hook for this project.   The service will reject any settings which are too large, the current limit is 32KB once serialized.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.   A JSON document can be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     * Update repository hook settings
     */
    async setSettings(requestParameters: SetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleSettings> {
        const response = await this.setSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the contributing guidelines for the repository, if they\'ve been defined.   This checks the repository for a CONTRIBUTING file, optionally with an md or txt extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <code>?markup</code> to the URL will stream an HTML-rendered version instead.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository contributing guidelines
     */
    async streamContributingRaw(requestParameters: StreamContributingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamContributing().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamContributing().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['markup'] != null) {
            queryParameters['markup'] = requestParameters['markup'];
        }

        if (requestParameters['htmlEscape'] != null) {
            queryParameters['htmlEscape'] = requestParameters['htmlEscape'];
        }

        if (requestParameters['includeHeadingId'] != null) {
            queryParameters['includeHeadingId'] = requestParameters['includeHeadingId'];
        }

        if (requestParameters['hardwrap'] != null) {
            queryParameters['hardwrap'] = requestParameters['hardwrap'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/contributing`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the contributing guidelines for the repository, if they\'ve been defined.   This checks the repository for a CONTRIBUTING file, optionally with an md or txt extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <code>?markup</code> to the URL will stream an HTML-rendered version instead.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository contributing guidelines
     */
    async streamContributing(requestParameters: StreamContributingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamContributingRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the license for the repository, if it\'s been defined.   This checks the repository for a <pre>LICENSE</pre> file, optionally with an <pre>md</pre> or <pre>txt</pre>extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <pre>?markup</pre> to the URL will stream an HTML-rendered version instead.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository license
     */
    async streamLicenseRaw(requestParameters: StreamLicenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamLicense().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamLicense().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['markup'] != null) {
            queryParameters['markup'] = requestParameters['markup'];
        }

        if (requestParameters['htmlEscape'] != null) {
            queryParameters['htmlEscape'] = requestParameters['htmlEscape'];
        }

        if (requestParameters['includeHeadingId'] != null) {
            queryParameters['includeHeadingId'] = requestParameters['includeHeadingId'];
        }

        if (requestParameters['hardwrap'] != null) {
            queryParameters['hardwrap'] = requestParameters['hardwrap'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/license`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the license for the repository, if it\'s been defined.   This checks the repository for a <pre>LICENSE</pre> file, optionally with an <pre>md</pre> or <pre>txt</pre>extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <pre>?markup</pre> to the URL will stream an HTML-rendered version instead.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository license
     */
    async streamLicense(requestParameters: StreamLicenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamLicenseRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the README for the repository, if it\'s been defined.   This checks the repository for a <pre>README</pre> file, optionally with an <pre>md</pre> or <pre>txt</pre>extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <pre>?markup</pre> to the URL will stream an HTML-rendered version instead. Note that, when streaming HTML, relative URLs in the README will not work if applied relative to this URL.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository readme
     */
    async streamReadmeRaw(requestParameters: StreamReadmeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamReadme().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamReadme().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['markup'] != null) {
            queryParameters['markup'] = requestParameters['markup'];
        }

        if (requestParameters['htmlEscape'] != null) {
            queryParameters['htmlEscape'] = requestParameters['htmlEscape'];
        }

        if (requestParameters['includeHeadingId'] != null) {
            queryParameters['includeHeadingId'] = requestParameters['includeHeadingId'];
        }

        if (requestParameters['hardwrap'] != null) {
            queryParameters['hardwrap'] = requestParameters['hardwrap'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/readme`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the README for the repository, if it\'s been defined.   This checks the repository for a <pre>README</pre> file, optionally with an <pre>md</pre> or <pre>txt</pre>extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <pre>?markup</pre> to the URL will stream an HTML-rendered version instead. Note that, when streaming HTML, relative URLs in the README will not work if applied relative to this URL.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository readme
     */
    async streamReadme(requestParameters: StreamReadmeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamReadmeRaw(requestParameters, initOverrides);
    }

    /**
     * Test connectivity to a specific endpoint.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Test webhook
     */
    async testWebhookRaw(requestParameters: TestWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling testWebhook().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['webhookId'] != null) {
            queryParameters['webhookId'] = requestParameters['webhookId'];
        }

        if (requestParameters['sslVerificationRequired'] != null) {
            queryParameters['sslVerificationRequired'] = requestParameters['sslVerificationRequired'];
        }

        if (requestParameters['url'] != null) {
            queryParameters['url'] = requestParameters['url'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks/test`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restWebhookCredentials'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Test connectivity to a specific endpoint.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Test webhook
     */
    async testWebhook(requestParameters: TestWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.testWebhookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a default task for the supplied project.  The authenticated user must have **PROJECT_ADMIN** permission for this project to call the resource.
     * Update a default task
     */
    async updateDefaultTaskRaw(requestParameters: UpdateDefaultTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDefaultTask>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateDefaultTask().'
            );
        }

        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling updateDefaultTask().'
            );
        }

        if (requestParameters['restDefaultTaskRequest'] == null) {
            throw new runtime.RequiredError(
                'restDefaultTaskRequest',
                'Required parameter "restDefaultTaskRequest" was null or undefined when calling updateDefaultTask().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/default-tasks/latest/projects/{projectKey}/tasks/{taskId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restDefaultTaskRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates a default task for the supplied project.  The authenticated user must have **PROJECT_ADMIN** permission for this project to call the resource.
     * Update a default task
     */
    async updateDefaultTask(requestParameters: UpdateDefaultTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDefaultTask> {
        const response = await this.updateDefaultTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the project matching the <strong>projectKey</strong> supplied in the resource path.   To include a custom avatar for the updated project, the project definition should contain an additional attribute with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI should be in the following format:  ```    data:(content type, e.g. image/png);base64,(data)```  If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is otherwise invalid, <em>project creation will fail</em>.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update project
     */
    async updateProjectRaw(requestParameters: UpdateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restProject'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the project matching the <strong>projectKey</strong> supplied in the resource path.   To include a custom avatar for the updated project, the project definition should contain an additional attribute with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI should be in the following format:  ```    data:(content type, e.g. image/png);base64,(data)```  If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is otherwise invalid, <em>project creation will fail</em>.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update project
     */
    async updateProject(requestParameters: UpdateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.updateProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the pull request merge strategy configuration for this project and SCM.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the context repository to call this resource.   Only the strategies provided will be enabled, the default must be set and included in the set of strategies.   An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty \"mergeConfig\" attribute. i.e:  <pre>{      \"mergeConfig\": {}  }  </pre>  Upon completion of this request, the effective configuration will be the configuration explicitly set for the SCM, or if no such explicit configuration is set then the default configuration will be used.
     * Update merge strategy
     */
    async updatePullRequestSettingsRaw(requestParameters: UpdatePullRequestSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePullRequestSettings().'
            );
        }

        if (requestParameters['scmId'] == null) {
            throw new runtime.RequiredError(
                'scmId',
                'Required parameter "scmId" was null or undefined when calling updatePullRequestSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/pull-requests/{scmId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"scmId"}}`, encodeURIComponent(String(requestParameters['scmId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPullRequestSettings'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the pull request merge strategy configuration for this project and SCM.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the context repository to call this resource.   Only the strategies provided will be enabled, the default must be set and included in the set of strategies.   An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty \"mergeConfig\" attribute. i.e:  <pre>{      \"mergeConfig\": {}  }  </pre>  Upon completion of this request, the effective configuration will be the configuration explicitly set for the SCM, or if no such explicit configuration is set then the default configuration will be used.
     * Update merge strategy
     */
    async updatePullRequestSettings(requestParameters: UpdatePullRequestSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestSettings> {
        const response = await this.updatePullRequestSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the repository matching the <strong>repositorySlug</strong> supplied in the resource path.   The repository\'s slug is derived from its name. If the name changes the slug may also change.   This resource can be used to change the repository\'s default branch by specifying a new default branch in the request. For example: <code>\"defaultBranch\":\"main\"</code>  This resource can be used to move the repository to a different project by specifying a new project in the request. For example: <code>\"project\":{\"key\":\"NEW_KEY\"}</code>  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update repository
     */
    async updateRepositoryRaw(requestParameters: UpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepository'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the repository matching the <strong>repositorySlug</strong> supplied in the resource path.   The repository\'s slug is derived from its name. If the name changes the slug may also change.   This resource can be used to change the repository\'s default branch by specifying a new default branch in the request. For example: <code>\"defaultBranch\":\"main\"</code>  This resource can be used to move the repository to a different project by specifying a new project in the request. For example: <code>\"project\":{\"key\":\"NEW_KEY\"}</code>  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update repository
     */
    async updateRepository(requestParameters: UpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.updateRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing webhook.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update webhook
     */
    async updateWebhookRaw(requestParameters: UpdateWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestWebhook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateWebhook().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling updateWebhook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/webhooks/{webhookId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restWebhook'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update an existing webhook.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update webhook
     */
    async updateWebhook(requestParameters: UpdateWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestWebhook> {
        const response = await this.updateWebhookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the avatar for the project matching the supplied <strong>projectKey</strong>.   This resource accepts POST multipart form data, containing a single image in a form-field named \'avatar\'.   There are configurable server limits on both the dimensions (1024x1024 pixels by default) and uploaded file size (1MB by default). Several different image formats are supported, but <strong>PNG</strong> and <strong>JPEG</strong> are preferred due to the file size limit.   This resource has Cross-Site Request Forgery (XSRF) protection. To allow the request to pass the XSRF check the caller needs to send an <code>X-Atlassian-Token</code> HTTP header with the value <code>no-check</code>.   An example <a href=\"http://curl.haxx.se/\">curl</a> request to upload an image name \'avatar.png\' would be: ```curl -X POST -u username:password -H \"X-Atlassian-Token: no-check\" http://example.com/rest/api/1.0/projects/STASH/avatar.png -F avatar=@avatar.png ```  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update project avatar
     */
    async uploadAvatarRaw(requestParameters: UploadAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling uploadAvatar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['avatar'] != null) {
            formParams.append('avatar', requestParameters['avatar'] as any);
        }

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/avatar.png`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the avatar for the project matching the supplied <strong>projectKey</strong>.   This resource accepts POST multipart form data, containing a single image in a form-field named \'avatar\'.   There are configurable server limits on both the dimensions (1024x1024 pixels by default) and uploaded file size (1MB by default). Several different image formats are supported, but <strong>PNG</strong> and <strong>JPEG</strong> are preferred due to the file size limit.   This resource has Cross-Site Request Forgery (XSRF) protection. To allow the request to pass the XSRF check the caller needs to send an <code>X-Atlassian-Token</code> HTTP header with the value <code>no-check</code>.   An example <a href=\"http://curl.haxx.se/\">curl</a> request to upload an image name \'avatar.png\' would be: ```curl -X POST -u username:password -H \"X-Atlassian-Token: no-check\" http://example.com/rest/api/1.0/projects/STASH/avatar.png -F avatar=@avatar.png ```  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update project avatar
     */
    async uploadAvatar(requestParameters: UploadAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uploadAvatarRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const GetRepositoryHooksTypeEnum = {
    PreReceive: 'PRE_RECEIVE',
    PostReceive: 'POST_RECEIVE'
} as const;
export type GetRepositoryHooksTypeEnum = typeof GetRepositoryHooksTypeEnum[keyof typeof GetRepositoryHooksTypeEnum];
/**
 * @export
 */
export const GetRestrictionsMatcherTypeEnum = {
    Branch: 'BRANCH',
    Pattern: 'PATTERN',
    ModelCategory: 'MODEL_CATEGORY',
    ModelBranch: 'MODEL_BRANCH'
} as const;
export type GetRestrictionsMatcherTypeEnum = typeof GetRestrictionsMatcherTypeEnum[keyof typeof GetRestrictionsMatcherTypeEnum];
/**
 * @export
 */
export const GetRestrictionsTypeEnum = {
    ReadOnly: 'read-only',
    NoDeletes: 'no-deletes',
    FastForwardOnly: 'fast-forward-only',
    PullRequestOnly: 'pull-request-only',
    NoCreates: 'no-creates'
} as const;
export type GetRestrictionsTypeEnum = typeof GetRestrictionsTypeEnum[keyof typeof GetRestrictionsTypeEnum];
