/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Server
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 8.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ExampleFiles,
  ExampleSettings,
  FindByCommit200Response,
  GetAll401Response,
  GetBranches200Response,
  GetChanges1200Response,
  GetComments200Response,
  GetCommits200Response1,
  GetConfigurations200Response,
  GetRefChangeActivity200Response,
  GetRepositoriesRecentlyAccessed200Response,
  GetRepositoryHooks1200Response,
  GetRestrictions1200Response,
  GetTags200Response,
  RestAttachmentMetadata,
  RestAutoDeclineSettings,
  RestAutoDeclineSettingsRequest,
  RestBranch,
  RestBranchCreateRequest,
  RestBranchDeleteRequest,
  RestComment,
  RestCommit,
  RestCreateBranchRequest,
  RestCreateTagRequest,
  RestDetailedInvocation,
  RestDiff,
  RestGitTagCreateRequest,
  RestHookScriptConfig,
  RestHookScriptTriggers,
  RestLabel,
  RestRefRestriction,
  RestRefSyncRequest,
  RestRefSyncStatus,
  RestRejectedRef,
  RestRepository,
  RestRepositoryHook,
  RestRepositoryPullRequestSettings,
  RestRestrictionRequest,
  RestTag,
  RestUserReaction,
  RestWebhook,
  RestWebhookCredentials,
  StreamDiff2200Response,
  StreamFiles200Response,
} from '../models/index';

interface AddLabelRequest {
    projectKey: string;
    repositorySlug: string;
    restLabel?: RestLabel;
}

interface CreateBranchRequest {
    projectKey: string;
    repositorySlug: string;
    restBranchCreateRequest: RestBranchCreateRequest;
}

interface CreateBranch0Request {
    projectKey: string;
    repositorySlug: string;
    restCreateBranchRequest?: RestCreateBranchRequest;
}

interface CreateCommentRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    since?: string;
    restComment?: Omit<RestComment, 'updatedDate'|'createdDate'|'reply'|'pending'|'anchored'|'html'|'comments'>;
}

interface CreateRestrictions1Request {
    projectKey: string;
    repositorySlug: string;
    restRestrictionRequest?: Array<RestRestrictionRequest>;
}

interface CreateTagRequest {
    projectKey: string;
    repositorySlug: string;
    restGitTagCreateRequest?: RestGitTagCreateRequest;
}

interface CreateTag0Request {
    projectKey: string;
    repositorySlug: string;
    restCreateTagRequest?: RestCreateTagRequest;
}

interface CreateWebhook1Request {
    projectKey: string;
    repositorySlug: string;
    restWebhook?: RestWebhook;
}

interface Delete1Request {
    projectKey: string;
    repositorySlug: string;
}

interface DeleteAttachmentRequest {
    projectKey: string;
    attachmentId: string;
    repositorySlug: string;
}

interface DeleteAttachmentMetadataRequest {
    projectKey: string;
    attachmentId: string;
    repositorySlug: string;
}

interface DeleteBranchRequest {
    projectKey: string;
    repositorySlug: string;
    restBranchDeleteRequest?: RestBranchDeleteRequest;
}

interface DeleteCommentRequest {
    projectKey: string;
    commentId: string;
    commitId: string;
    repositorySlug: string;
    version?: string;
}

interface DeleteRepositoryHookRequest {
    projectKey: string;
    hookKey: string;
    repositorySlug: string;
}

interface DeleteRestriction1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface DeleteTagRequest {
    projectKey: string;
    name: string;
    repositorySlug: string;
}

interface DeleteWebhook1Request {
    projectKey: string;
    webhookId: string;
    repositorySlug: string;
}

interface DisableHook1Request {
    projectKey: string;
    hookKey: string;
    repositorySlug: string;
}

interface EditFileRequest {
    path: string;
    projectKey: string;
    repositorySlug: string;
    branch?: string;
    content?: string;
    message?: string;
    sourceBranch?: string;
    sourceCommitId?: string;
}

interface EnableHook1Request {
    projectKey: string;
    hookKey: string;
    repositorySlug: string;
    contentLength?: string;
}

interface FindBranchesRequest {
    projectKey: string;
    repositorySlug: string;
    filterText?: string;
    start?: number;
    limit?: number;
}

interface FindByCommitRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
    start2?: number;
    limit2?: number;
}

interface FindWebhooks1Request {
    projectKey: string;
    repositorySlug: string;
    event?: string;
    statistics?: boolean;
}

interface Get1Request {
    projectKey: string;
    repositorySlug: string;
}

interface GetAllLabelsForRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
}

interface GetArchiveRequest {
    projectKey: string;
    repositorySlug: string;
    path?: string;
    filename?: string;
    at?: string;
    prefix?: string;
    format?: string;
}

interface GetAttachmentRequest {
    projectKey: string;
    attachmentId: string;
    repositorySlug: string;
    userAgent?: string;
}

interface GetAttachmentMetadataRequest {
    projectKey: string;
    attachmentId: string;
    repositorySlug: string;
}

interface GetBranchesRequest {
    projectKey: string;
    repositorySlug: string;
    boostMatches?: boolean;
    orderBy?: GetBranchesOrderByEnum;
    details?: boolean;
    filterText?: string;
    base?: string;
    start?: number;
    limit?: number;
}

interface GetChangesRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    withComments?: string;
    since?: string;
    start?: number;
    limit?: number;
}

interface GetChanges1Request {
    projectKey: string;
    repositorySlug: string;
    until?: string;
    since?: string;
    start?: number;
    limit?: number;
}

interface GetCommentRequest {
    projectKey: string;
    commentId: string;
    commitId: string;
    repositorySlug: string;
}

interface GetCommentsRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    path?: string;
    since?: string;
    start?: number;
    limit?: number;
}

interface GetCommitRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    path?: string;
}

interface GetCommitsRequest {
    projectKey: string;
    repositorySlug: string;
    avatarScheme?: string;
    path?: string;
    withCounts?: string;
    followRenames?: string;
    until?: string;
    avatarSize?: string;
    since?: string;
    merges?: string;
    ignoreMissing?: string;
    start?: number;
    limit?: number;
}

interface GetConfigurations1Request {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetContentRequest {
    projectKey: string;
    repositorySlug: string;
    noContent?: string;
    at?: string;
    size?: string;
    blame?: string;
    type?: string;
}

interface GetContent1Request {
    path: string;
    projectKey: string;
    repositorySlug: string;
    noContent?: string;
    at?: string;
    size?: string;
    blame?: string;
    type?: string;
}

interface GetDefaultBranch1Request {
    projectKey: string;
    repositorySlug: string;
}

interface GetLatestInvocation1Request {
    projectKey: string;
    webhookId: string;
    repositorySlug: string;
    event?: string;
    outcome?: string;
}

interface GetPullRequestSettings1Request {
    projectKey: string;
    repositorySlug: string;
}

interface GetRefChangeActivityRequest {
    projectKey: string;
    repositorySlug: string;
    ref?: string;
    start?: number;
    limit?: number;
}

interface GetRepositories1Request {
    archived?: string;
    projectname?: string;
    projectkey?: string;
    visibility?: GetRepositories1VisibilityEnum;
    name?: string;
    permission?: GetRepositories1PermissionEnum;
    state?: GetRepositories1StateEnum;
    start?: number;
    limit?: number;
}

interface GetRepositoriesRecentlyAccessedRequest {
    permission?: string;
    start?: number;
    limit?: number;
}

interface GetRepositoryHook1Request {
    projectKey: string;
    hookKey: string;
    repositorySlug: string;
}

interface GetRepositoryHooks1Request {
    projectKey: string;
    repositorySlug: string;
    type?: GetRepositoryHooks1TypeEnum;
    start?: number;
    limit?: number;
}

interface GetRestriction1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface GetRestrictions1Request {
    projectKey: string;
    repositorySlug: string;
    matcherType?: GetRestrictions1MatcherTypeEnum;
    matcherId?: string;
    type?: GetRestrictions1TypeEnum;
    start?: number;
    limit?: number;
}

interface GetSettings1Request {
    projectKey: string;
    hookKey: string;
    repositorySlug: string;
}

interface GetStatistics1Request {
    projectKey: string;
    webhookId: string;
    repositorySlug: string;
    event?: string;
}

interface GetStatisticsSummary1Request {
    projectKey: string;
    webhookId: string;
    repositorySlug: string;
}

interface GetStatusRequest {
    projectKey: string;
    repositorySlug: string;
    at?: string;
}

interface GetTagRequest {
    projectKey: string;
    name: string;
    repositorySlug: string;
}

interface GetTagsRequest {
    projectKey: string;
    repositorySlug: string;
    orderBy?: string;
    filterText?: string;
    start?: number;
    limit?: number;
}

interface GetWebhook1Request {
    projectKey: string;
    webhookId: string;
    repositorySlug: string;
    statistics?: string;
}

interface ReactRequest {
    projectKey: string;
    commentId: string;
    commitId: string;
    emoticon: string;
    repositorySlug: string;
}

interface RemoveConfiguration1Request {
    projectKey: string;
    scriptId: string;
    repositorySlug: string;
}

interface RemoveLabelRequest {
    projectKey: string;
    labelName: string;
    repositorySlug: string;
}

interface SaveAttachmentMetadataRequest {
    projectKey: string;
    attachmentId: string;
    repositorySlug: string;
    body?: string;
}

interface SearchWebhooksRequest {
    projectKey: string;
    repositorySlug: string;
    scopeType?: string;
    event?: string;
    statistics?: boolean;
}

interface Set1Request {
    projectKey: string;
    repositorySlug: string;
    restAutoDeclineSettingsRequest?: RestAutoDeclineSettingsRequest;
}

interface SetConfiguration1Request {
    projectKey: string;
    scriptId: string;
    repositorySlug: string;
    restHookScriptTriggers?: RestHookScriptTriggers;
}

interface SetDefaultBranch1Request {
    projectKey: string;
    repositorySlug: string;
    restBranch?: Omit<RestBranch, 'displayId'|'default'|'latestCommit'|'latestChangeset'>;
}

interface SetEnabledRequest {
    projectKey: string;
    repositorySlug: string;
    restRefSyncStatus?: Omit<RestRefSyncStatus, 'lastSync'|'available'>;
}

interface SetSettings1Request {
    projectKey: string;
    hookKey: string;
    repositorySlug: string;
    exampleSettings?: ExampleSettings;
}

interface StreamRequest {
    path: string;
    projectKey: string;
    repositorySlug: string;
    at?: string;
}

interface Stream1Request {
    projectKey: string;
    repositorySlug: string;
    at?: string;
}

interface StreamChangesRequest {
    projectKey: string;
    repositorySlug: string;
    fromRepo?: string;
    from?: string;
    to?: string;
    start?: number;
    limit?: number;
}

interface StreamCommitsRequest {
    projectKey: string;
    repositorySlug: string;
    fromRepo?: string;
    from?: string;
    to?: string;
    start?: number;
    limit?: number;
}

interface StreamDiffRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
    contextLines?: number;
    srcPath?: string;
    autoSrcPath?: boolean;
    whitespace?: string;
    withComments?: boolean;
    since?: string;
}

interface StreamDiff1Request {
    commitId: string;
    repositorySlug: string;
    path: string;
    projectKey: string;
    sinceId?: string;
    srcPath?: string;
    avatarSize?: string;
    avatarScheme?: string;
    filter?: string;
    contextLines?: string;
    autoSrcPath?: string;
    whitespace?: string;
    withComments?: string;
    since?: string;
}

interface StreamDiff2Request {
    path: string;
    projectKey: string;
    repositorySlug: string;
    contextLines?: string;
    fromRepo?: string;
    srcPath?: string;
    from?: string;
    to?: string;
    whitespace?: string;
    start?: number;
    limit?: number;
}

interface StreamFilesRequest {
    projectKey: string;
    repositorySlug: string;
    at?: string;
    start?: number;
    limit?: number;
}

interface StreamFiles1Request {
    path: string;
    projectKey: string;
    repositorySlug: string;
    at?: string;
    start?: number;
    limit?: number;
}

interface StreamPatchRequest {
    projectKey: string;
    repositorySlug: string;
    until?: string;
    allAncestors?: string;
    since?: string;
}

interface StreamRawRequest {
    path: string;
    projectKey: string;
    repositorySlug: string;
    at?: string;
    markup?: string;
    htmlEscape?: string;
    includeHeadingId?: string;
    hardwrap?: string;
}

interface StreamRawDiffRequest {
    projectKey: string;
    repositorySlug: string;
    contextLines?: string;
    srcPath?: string;
    until?: string;
    whitespace?: string;
    since?: string;
}

interface StreamRawDiff1Request {
    path: string;
    projectKey: string;
    repositorySlug: string;
    contextLines?: string;
    srcPath?: string;
    until?: string;
    whitespace?: string;
    since?: string;
}

interface SynchronizeRequest {
    projectKey: string;
    repositorySlug: string;
    restRefSyncRequest?: RestRefSyncRequest;
}

interface TestWebhook1Request {
    projectKey: string;
    repositorySlug: string;
    webhookId?: number;
    sslVerificationRequired?: string;
    url?: string;
    restWebhookCredentials?: RestWebhookCredentials;
}

interface UnReactRequest {
    projectKey: string;
    commentId: string;
    commitId: string;
    emoticon: string;
    repositorySlug: string;
}

interface UnwatchRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
}

interface Unwatch2Request {
    projectKey: string;
    repositorySlug: string;
}

interface UpdateCommentRequest {
    projectKey: string;
    commentId: string;
    commitId: string;
    repositorySlug: string;
    restComment?: Omit<RestComment, 'updatedDate'|'createdDate'|'reply'|'pending'|'anchored'|'html'|'comments'>;
}

interface UpdatePullRequestSettings1Request {
    projectKey: string;
    repositorySlug: string;
    restRepositoryPullRequestSettings?: RestRepositoryPullRequestSettings;
}

interface UpdateWebhook1Request {
    projectKey: string;
    webhookId: string;
    repositorySlug: string;
    restWebhook?: RestWebhook;
}

interface WatchRequest {
    projectKey: string;
    commitId: string;
    repositorySlug: string;
}

interface Watch2Request {
    projectKey: string;
    repositorySlug: string;
    restRepository?: Omit<RestRepository, 'defaultBranch'|'hierarchyId'|'statusMessage'|'relatedLinks'|'partition'|'archived'|'forkable'|'scope'|'description'|'public'|'id'|'state'>;
}

/**
 * 
 */
export class RepositoryApi extends runtime.BaseAPI {

    /**
     * Applies a label to the repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository.
     * Add repository label
     */
    async addLabelRaw(requestParameters: AddLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestLabel>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addLabel().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling addLabel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restLabel'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Applies a label to the repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository.
     * Add repository label
     */
    async addLabel(requestParameters: AddLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestLabel> {
        const response = await this.addLabelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Creates a branch in the specified repository.   The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource. If branch permissions are set up in the repository, the authenticated user must also have access to the branch name that is to be created.
     * Create branch
     */
    async createBranchRaw(requestParameters: CreateBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBranch>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createBranch().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createBranch().'
            );
        }

        if (requestParameters['restBranchCreateRequest'] == null) {
            throw new runtime.RequiredError(
                'restBranchCreateRequest',
                'Required parameter "restBranchCreateRequest" was null or undefined when calling createBranch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restBranchCreateRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  Creates a branch in the specified repository.   The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource. If branch permissions are set up in the repository, the authenticated user must also have access to the branch name that is to be created.
     * Create branch
     */
    async createBranch(requestParameters: CreateBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBranch> {
        const response = await this.createBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a branch using the information provided in the RestCreateBranchRequest request   The authenticated user must have <strong>REPO_WRITE</strong> permission for the context repository to call this resource.
     * Create branch
     */
    async createBranch_1Raw(requestParameters: CreateBranch0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBranch>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createBranch_1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createBranch_1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restCreateBranchRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a branch using the information provided in the RestCreateBranchRequest request   The authenticated user must have <strong>REPO_WRITE</strong> permission for the context repository to call this resource.
     * Create branch
     */
    async createBranch_1(requestParameters: CreateBranch0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBranch> {
        const response = await this.createBranch_1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new comment.  Comments can be added in a few places by setting different attributes:  General commit comment:  ```{       \"text\": \"An insightful general comment on a commit.\" }  </pre> Reply to a comment: <pre>{       \"text\": \"A measured reply.\",       \"parent\": {           \"id\": 1       } } </pre> General file comment: <pre>{       \"text\": \"An insightful general comment on a file.\",       \"anchor\": {           \"diffType\": \"COMMIT\",           \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",           \"path\": \"path/to/file\",           \"srcPath\": \"path/to/file\",           \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"       } } </pre> File line comment: <pre>{       \"text\": \"A pithy comment on a particular line within a file.\",       \"anchor\": {           \"diffType\": \"COMMIT\",           \"line\": 1,           \"lineType\": \"CONTEXT\",           \"fileType\": \"FROM\",           \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",           \"path\": \"path/to/file\",           \"srcPath\": \"path/to/file\",           \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"       } } ```  Note: general file comments are an experimental feature and may change in the near future!  For file and line comments, \'path\' refers to the path of the file to which the comment should be applied and \'srcPath\' refers to the path the that file used to have (only required for copies and moves). Also, fromHash and toHash refer to the sinceId / untilId (respectively) used to produce the diff on which the comment was added. Finally diffType refers to the type of diff the comment was added on.  For line comments, \'line\' refers to the line in the diff that the comment should apply to. \'lineType\' refers to the type of diff hunk, which can be:- \'ADDED\' - for an added line;</li>- \'REMOVED\' - for a removed line; or</li>- \'CONTEXT\' - for a line that was unmodified but is in the vicinity of the diff.</li>\'fileType\' refers to the file of the diff to which the anchor should be attached - which is of relevance when displaying the diff in a side-by-side way. Currently the supported values are:- \'FROM\' - the source file of the diff</li>- \'TO\' - the destination file of the diff</li>If the current user is not a participant the user is added as one and updated to watch the commit.  The authenticated user must have REPO_READ permission for the repository that the commit is in to call this resource.
     * Add a new commit comment
     */
    async createCommentRaw(requestParameters: CreateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createComment().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling createComment().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createComment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restComment'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new comment.  Comments can be added in a few places by setting different attributes:  General commit comment:  ```{       \"text\": \"An insightful general comment on a commit.\" }  </pre> Reply to a comment: <pre>{       \"text\": \"A measured reply.\",       \"parent\": {           \"id\": 1       } } </pre> General file comment: <pre>{       \"text\": \"An insightful general comment on a file.\",       \"anchor\": {           \"diffType\": \"COMMIT\",           \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",           \"path\": \"path/to/file\",           \"srcPath\": \"path/to/file\",           \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"       } } </pre> File line comment: <pre>{       \"text\": \"A pithy comment on a particular line within a file.\",       \"anchor\": {           \"diffType\": \"COMMIT\",           \"line\": 1,           \"lineType\": \"CONTEXT\",           \"fileType\": \"FROM\",           \"fromHash\": \"6df3858eeb9a53a911cd17e66a9174d44ffb02cd\",           \"path\": \"path/to/file\",           \"srcPath\": \"path/to/file\",           \"toHash\": \"04c7c5c931b9418ca7b66f51fe934d0bd9b2ba4b\"       } } ```  Note: general file comments are an experimental feature and may change in the near future!  For file and line comments, \'path\' refers to the path of the file to which the comment should be applied and \'srcPath\' refers to the path the that file used to have (only required for copies and moves). Also, fromHash and toHash refer to the sinceId / untilId (respectively) used to produce the diff on which the comment was added. Finally diffType refers to the type of diff the comment was added on.  For line comments, \'line\' refers to the line in the diff that the comment should apply to. \'lineType\' refers to the type of diff hunk, which can be:- \'ADDED\' - for an added line;</li>- \'REMOVED\' - for a removed line; or</li>- \'CONTEXT\' - for a line that was unmodified but is in the vicinity of the diff.</li>\'fileType\' refers to the file of the diff to which the anchor should be attached - which is of relevance when displaying the diff in a side-by-side way. Currently the supported values are:- \'FROM\' - the source file of the diff</li>- \'TO\' - the destination file of the diff</li>If the current user is not a participant the user is added as one and updated to watch the commit.  The authenticated user must have REPO_READ permission for the repository that the commit is in to call this resource.
     * Add a new commit comment
     */
    async createComment(requestParameters: CreateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.createCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows creating multiple restrictions at once.
     * Create multiple ref restrictions
     */
    async createRestrictions1Raw(requestParameters: CreateRestrictions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefRestriction>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createRestrictions1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createRestrictions1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/vnd.atl.bitbucket.bulk+json';

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRestrictionRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Allows creating multiple restrictions at once.
     * Create multiple ref restrictions
     */
    async createRestrictions1(requestParameters: CreateRestrictions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefRestriction> {
        const response = await this.createRestrictions1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a tag in the specified repository.  The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource.  \'LIGHTWEIGHT\' and \'ANNOTATED\' are the two type of tags that can be created. The \'startPoint\' can either be a ref or a \'commit\'.
     * Create tag
     */
    async createTagRaw(requestParameters: CreateTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestTag>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createTag().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createTag().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/git/latest/projects/{projectKey}/repos/{repositorySlug}/tags`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restGitTagCreateRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a tag in the specified repository.  The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource.  \'LIGHTWEIGHT\' and \'ANNOTATED\' are the two type of tags that can be created. The \'startPoint\' can either be a ref or a \'commit\'.
     * Create tag
     */
    async createTag(requestParameters: CreateTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestTag> {
        const response = await this.createTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a tag using the information provided in the RestCreateTagRequest request   The authenticated user must have <strong>REPO_WRITE</strong> permission for the context repository to call this resource.
     * Create tag
     */
    async createTag_2Raw(requestParameters: CreateTag0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestTag>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createTag_2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createTag_2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restCreateTagRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a tag using the information provided in the RestCreateTagRequest request   The authenticated user must have <strong>REPO_WRITE</strong> permission for the context repository to call this resource.
     * Create tag
     */
    async createTag_2(requestParameters: CreateTag0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestTag> {
        const response = await this.createTag_2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a webhook for the repository specified via the URL.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Create webhook
     */
    async createWebhook1Raw(requestParameters: CreateWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestWebhook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createWebhook1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createWebhook1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restWebhook'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a webhook for the repository specified via the URL.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Create webhook
     */
    async createWebhook1(requestParameters: CreateWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestWebhook> {
        const response = await this.createWebhook1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete auto decline settings for the supplied repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for this repository to call the resource.
     * Delete auto decline settings
     */
    async delete1Raw(requestParameters: Delete1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling delete1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling delete1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete auto decline settings for the supplied repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for this repository to call the resource.
     * Delete auto decline settings
     */
    async delete1(requestParameters: Delete1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete an attachment.  The user must be authenticated and have <strong>REPO_ADMIN</strong> permission for the specified repository.
     * Delete an attachment
     */
    async deleteAttachmentRaw(requestParameters: DeleteAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteAttachment().'
            );
        }

        if (requestParameters['attachmentId'] == null) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter "attachmentId" was null or undefined when calling deleteAttachment().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteAttachment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters['attachmentId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an attachment.  The user must be authenticated and have <strong>REPO_ADMIN</strong> permission for the specified repository.
     * Delete an attachment
     */
    async deleteAttachment(requestParameters: DeleteAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAttachmentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete attachment metadata.  The user must be authenticated and have <strong>REPO_ADMIN</strong> permission for the specified repository.
     * Delete attachment metadata
     */
    async deleteAttachmentMetadataRaw(requestParameters: DeleteAttachmentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteAttachmentMetadata().'
            );
        }

        if (requestParameters['attachmentId'] == null) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter "attachmentId" was null or undefined when calling deleteAttachmentMetadata().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteAttachmentMetadata().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters['attachmentId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete attachment metadata.  The user must be authenticated and have <strong>REPO_ADMIN</strong> permission for the specified repository.
     * Delete attachment metadata
     */
    async deleteAttachmentMetadata(requestParameters: DeleteAttachmentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAttachmentMetadataRaw(requestParameters, initOverrides);
    }

    /**
     *  Deletes a branch in the specified repository.    If the branch does not exist, this operation will not raise an error. In other words after calling this resource  and receiving a 204 response the branch provided in the request is guaranteed to not exist in the specified  repository any more, regardless of its existence beforehand.    The optional \'endPoint\' parameter of the request may contain a commit ID that the provided ref name is  expected to point to. Should the ref point to a different commit ID, a 400 response will be returned with  appropriate error details.    The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource. If  branch permissions are set up in the repository, the authenticated user must also have access to the branch name  that is to be deleted.
     * Delete branch
     */
    async deleteBranchRaw(requestParameters: DeleteBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteBranch().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteBranch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restBranchDeleteRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Deletes a branch in the specified repository.    If the branch does not exist, this operation will not raise an error. In other words after calling this resource  and receiving a 204 response the branch provided in the request is guaranteed to not exist in the specified  repository any more, regardless of its existence beforehand.    The optional \'endPoint\' parameter of the request may contain a commit ID that the provided ref name is  expected to point to. Should the ref point to a different commit ID, a 400 response will be returned with  appropriate error details.    The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource. If  branch permissions are set up in the repository, the authenticated user must also have access to the branch name  that is to be deleted.
     * Delete branch
     */
    async deleteBranch(requestParameters: DeleteBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteBranchRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a commit comment. Anyone can delete their own comment. Only users with <strong>REPO_ADMIN</strong> and above may delete comments created by other users. Comments which have replies <i>may not be deleted</i>, regardless of the user\'s granted permissions.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.
     * Delete a commit comment
     */
    async deleteCommentRaw(requestParameters: DeleteCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteComment().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling deleteComment().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling deleteComment().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteComment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a commit comment. Anyone can delete their own comment. Only users with <strong>REPO_ADMIN</strong> and above may delete comments created by other users. Comments which have replies <i>may not be deleted</i>, regardless of the user\'s granted permissions.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.
     * Delete a commit comment
     */
    async deleteComment(requestParameters: DeleteCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete repository hook configuration for the supplied <strong>hookKey</strong> and <strong>repositorySlug</strong>  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     */
    async deleteRepositoryHookRaw(requestParameters: DeleteRepositoryHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteRepositoryHook().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling deleteRepositoryHook().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteRepositoryHook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete repository hook configuration for the supplied <strong>hookKey</strong> and <strong>repositorySlug</strong>  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     */
    async deleteRepositoryHook(requestParameters: DeleteRepositoryHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryHookRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a restriction as specified by a restriction id.  The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Delete a ref restriction
     */
    async deleteRestriction1Raw(requestParameters: DeleteRestriction1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteRestriction1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteRestriction1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteRestriction1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a restriction as specified by a restriction id.  The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Delete a ref restriction
     */
    async deleteRestriction1(requestParameters: DeleteRestriction1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRestriction1Raw(requestParameters, initOverrides);
    }

    /**
     * Deletes a tag in the specified repository.  The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource.
     * Delete tag
     */
    async deleteTagRaw(requestParameters: DeleteTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteTag().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteTag().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteTag().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/git/latest/projects/{projectKey}/repos/{repositorySlug}/tags/{name}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a tag in the specified repository.  The authenticated user must have an effective <strong>REPO_WRITE</strong> permission to call this resource.
     * Delete tag
     */
    async deleteTag(requestParameters: DeleteTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteTagRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a webhook for the repository specified via the URL.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Delete webhook
     */
    async deleteWebhook1Raw(requestParameters: DeleteWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteWebhook1().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling deleteWebhook1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteWebhook1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a webhook for the repository specified via the URL.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Delete webhook
     */
    async deleteWebhook1(requestParameters: DeleteWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWebhook1Raw(requestParameters, initOverrides);
    }

    /**
     * Disable a repository hook for this repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     */
    async disableHook1Raw(requestParameters: DisableHook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling disableHook1().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling disableHook1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling disableHook1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Disable a repository hook for this repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     */
    async disableHook1(requestParameters: DisableHook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.disableHook1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the content of path, on the given repository and branch.   This resource accepts PUT multipart form data, containing the file in a form-field named content.   An example <a href=\"http://curl.haxx.se/\">curl</a> request to update \'README.md\' would be:  ```curl -X PUT -u username:password -F content=@README.md  -F \'message=Updated using file-edit REST API\' -F branch=master -F  sourceCommitId=5636641a50b  http://example.com/rest/api/latest/projects/PROJECT_1/repos/repo_1/browse/README.md ```  - branch:  the branch on which the path should be modified or created - content: the full content of the file at path  - message: the message associated with this change, to be used as the commit message. Or null if the default message should be used. - sourceCommitId: the commit ID of the file before it was edited, used to identify if content has changed. Or null if this is a new file   The file can be updated or created on a new branch. In this case, the sourceBranch parameter should be provided to identify the starting point for the new branch and the branch parameter identifies the branch to create the new commit on.
     * Edit file
     */
    async editFileRaw(requestParameters: EditFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestCommit>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling editFile().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling editFile().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling editFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['branch'] != null) {
            formParams.append('branch', requestParameters['branch'] as any);
        }

        if (requestParameters['content'] != null) {
            formParams.append('content', requestParameters['content'] as any);
        }

        if (requestParameters['message'] != null) {
            formParams.append('message', requestParameters['message'] as any);
        }

        if (requestParameters['sourceBranch'] != null) {
            formParams.append('sourceBranch', requestParameters['sourceBranch'] as any);
        }

        if (requestParameters['sourceCommitId'] != null) {
            formParams.append('sourceCommitId', requestParameters['sourceCommitId'] as any);
        }

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the content of path, on the given repository and branch.   This resource accepts PUT multipart form data, containing the file in a form-field named content.   An example <a href=\"http://curl.haxx.se/\">curl</a> request to update \'README.md\' would be:  ```curl -X PUT -u username:password -F content=@README.md  -F \'message=Updated using file-edit REST API\' -F branch=master -F  sourceCommitId=5636641a50b  http://example.com/rest/api/latest/projects/PROJECT_1/repos/repo_1/browse/README.md ```  - branch:  the branch on which the path should be modified or created - content: the full content of the file at path  - message: the message associated with this change, to be used as the commit message. Or null if the default message should be used. - sourceCommitId: the commit ID of the file before it was edited, used to identify if content has changed. Or null if this is a new file   The file can be updated or created on a new branch. In this case, the sourceBranch parameter should be provided to identify the starting point for the new branch and the branch parameter identifies the branch to create the new commit on.
     * Edit file
     */
    async editFile(requestParameters: EditFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestCommit> {
        const response = await this.editFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable a repository hook for this repository and optionally apply new configuration.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.   A JSON document may be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     */
    async enableHook1Raw(requestParameters: EnableHook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling enableHook1().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling enableHook1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling enableHook1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['contentLength'] != null) {
            headerParameters['Content-Length'] = String(requestParameters['contentLength']);
        }

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enable a repository hook for this repository and optionally apply new configuration.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.   A JSON document may be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     */
    async enableHook1(requestParameters: EnableHook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.enableHook1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of branches with ref change activities for a specific repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission to call this resource.
     * Get branches with ref change activities for repository
     */
    async findBranchesRaw(requestParameters: FindBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindByCommit200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling findBranches().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling findBranches().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filterText'] != null) {
            queryParameters['filterText'] = requestParameters['filterText'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/ref-change-activities/branches`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of branches with ref change activities for a specific repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission to call this resource.
     * Get branches with ref change activities for repository
     */
    async findBranches(requestParameters: FindBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindByCommit200Response> {
        const response = await this.findBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the branch information associated with a single commit from a given repository.
     * Get branch
     */
    async findByCommitRaw(requestParameters: FindByCommitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindByCommit200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling findByCommit().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling findByCommit().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling findByCommit().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['start2'] != null) {
            queryParameters['start'] = requestParameters['start2'];
        }

        if (requestParameters['limit2'] != null) {
            queryParameters['limit'] = requestParameters['limit2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-utils/latest/projects/{projectKey}/repos/{repositorySlug}/branches/info/{commitId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the branch information associated with a single commit from a given repository.
     * Get branch
     */
    async findByCommit(requestParameters: FindByCommitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindByCommit200Response> {
        const response = await this.findByCommitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find webhooks in this repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Find webhooks
     */
    async findWebhooks1Raw(requestParameters: FindWebhooks1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling findWebhooks1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling findWebhooks1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['event'] != null) {
            queryParameters['event'] = requestParameters['event'];
        }

        if (requestParameters['statistics'] != null) {
            queryParameters['statistics'] = requestParameters['statistics'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Find webhooks in this repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Find webhooks
     */
    async findWebhooks1(requestParameters: FindWebhooks1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.findWebhooks1Raw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the auto decline settings for the supplied repository. Project settings will be returned if no explicit settings have been set for the repository. In the case that there are no project settings, the default settings will be returned.  The authenticated user must have <strong>REPO_READ</strong> permission for this repository to call the resource.
     * Get auto decline settings
     */
    async get1Raw(requestParameters: Get1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoDeclineSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling get1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling get1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the auto decline settings for the supplied repository. Project settings will be returned if no explicit settings have been set for the repository. In the case that there are no project settings, the default settings will be returned.  The authenticated user must have <strong>REPO_READ</strong> permission for this repository to call the resource.
     * Get auto decline settings
     */
    async get1(requestParameters: Get1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoDeclineSettings> {
        const response = await this.get1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all labels applied to the given repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository.
     * Get repository labels
     */
    async getAllLabelsForRepositoryRaw(requestParameters: GetAllLabelsForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestLabel>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAllLabelsForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAllLabelsForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all labels applied to the given repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository.
     * Get repository labels
     */
    async getAllLabelsForRepository(requestParameters: GetAllLabelsForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestLabel> {
        const response = await this.getAllLabelsForRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams an archive of the repository\'s contents at the requested commit. If no `at=` commit is requested, an archive of the default branch is streamed.  The <code>filename=</code> query parameter may be used to specify the exact filename to include in the \"Content-Disposition\" header. If an explicit filename is not provided, one will be automatically generated based on what is being archived. Its format depends on the at= value:   - No <code>at=</code> commit:     &lt;slug&gt;-&lt;default-branch-name&gt;@&lt;commit&gt;.&lt;format&gt;;     e.g. example-master@43c2f8a0fe8.zip - <code>at=</code>sha: &lt;slug&gt;-&lt;at&gt;.&lt;format&gt;; e.g.     example-09bcbb00100cfbb5310fb6834a1d5ce6cac253e9.tar.gz - <code>at=</code>branchOrTag: &lt;slug&gt;-&lt;branchOrTag&gt;@&lt;commit&gt;.&lt;format&gt;;     e.g. example-feature@bbb225f16e1.tar       - If the branch or tag is qualified (e.g. refs/heads/master, the short name         (master) will be included in the filename     - If the branch or tag\'s <i>short name</i> includes slashes (e.g. release/4.6),         they will be converted to hyphens in the filename (release-4.5)     Archives may be requested in the following formats by adding the <code>format=</code> query parameter:   - zip: A zip file using standard compression (Default) - tar: An uncompressed tarball - tar.gz or tgz: A GZip-compressed tarball   The contents of the archive may be filtered by using the <code>path=</code> query parameter to specify paths to include. <code>path=</code> may be specified multiple times to include multiple paths.   The <code>prefix=</code> query parameter may be used to define a directory (or multiple directories) where the archive\'s contents should be placed. If the prefix does not end with /, one will be added automatically. The prefix is <i>always</i> treated as a directory; it is not possible to use it to prepend characters to the entries in the archive.   Archives of public repositories may be streamed by any authenticated or anonymous user. Streaming archives for non-public repositories requires an <i>authenticated user</i> with at least <b>REPO_READ</b> permission.
     * Stream archive of repository
     */
    async getArchiveRaw(requestParameters: GetArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getArchive().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getArchive().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['filename'] != null) {
            queryParameters['filename'] = requestParameters['filename'];
        }

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['prefix'] != null) {
            queryParameters['prefix'] = requestParameters['prefix'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/archive`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Streams an archive of the repository\'s contents at the requested commit. If no `at=` commit is requested, an archive of the default branch is streamed.  The <code>filename=</code> query parameter may be used to specify the exact filename to include in the \"Content-Disposition\" header. If an explicit filename is not provided, one will be automatically generated based on what is being archived. Its format depends on the at= value:   - No <code>at=</code> commit:     &lt;slug&gt;-&lt;default-branch-name&gt;@&lt;commit&gt;.&lt;format&gt;;     e.g. example-master@43c2f8a0fe8.zip - <code>at=</code>sha: &lt;slug&gt;-&lt;at&gt;.&lt;format&gt;; e.g.     example-09bcbb00100cfbb5310fb6834a1d5ce6cac253e9.tar.gz - <code>at=</code>branchOrTag: &lt;slug&gt;-&lt;branchOrTag&gt;@&lt;commit&gt;.&lt;format&gt;;     e.g. example-feature@bbb225f16e1.tar       - If the branch or tag is qualified (e.g. refs/heads/master, the short name         (master) will be included in the filename     - If the branch or tag\'s <i>short name</i> includes slashes (e.g. release/4.6),         they will be converted to hyphens in the filename (release-4.5)     Archives may be requested in the following formats by adding the <code>format=</code> query parameter:   - zip: A zip file using standard compression (Default) - tar: An uncompressed tarball - tar.gz or tgz: A GZip-compressed tarball   The contents of the archive may be filtered by using the <code>path=</code> query parameter to specify paths to include. <code>path=</code> may be specified multiple times to include multiple paths.   The <code>prefix=</code> query parameter may be used to define a directory (or multiple directories) where the archive\'s contents should be placed. If the prefix does not end with /, one will be added automatically. The prefix is <i>always</i> treated as a directory; it is not possible to use it to prepend characters to the entries in the archive.   Archives of public repositories may be streamed by any authenticated or anonymous user. Streaming archives for non-public repositories requires an <i>authenticated user</i> with at least <b>REPO_READ</b> permission.
     * Stream archive of repository
     */
    async getArchive(requestParameters: GetArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getArchiveRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve the attachment.  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment.
     * Get an attachment
     */
    async getAttachmentRaw(requestParameters: GetAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAttachment().'
            );
        }

        if (requestParameters['attachmentId'] == null) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter "attachmentId" was null or undefined when calling getAttachment().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAttachment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters['attachmentId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve the attachment.  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment.
     * Get an attachment
     */
    async getAttachment(requestParameters: GetAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAttachmentRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve the attachment metadata.  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment that has the attachment metadata.
     * Get attachment metadata
     */
    async getAttachmentMetadataRaw(requestParameters: GetAttachmentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAttachmentMetadata>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAttachmentMetadata().'
            );
        }

        if (requestParameters['attachmentId'] == null) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter "attachmentId" was null or undefined when calling getAttachmentMetadata().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAttachmentMetadata().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters['attachmentId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the attachment metadata.  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment that has the attachment metadata.
     * Get attachment metadata
     */
    async getAttachmentMetadata(requestParameters: GetAttachmentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAttachmentMetadata> {
        const response = await this.getAttachmentMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the branches matching the supplied <strong>filterText</strong> param.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Find branches
     */
    async getBranchesRaw(requestParameters: GetBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetBranches200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getBranches().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getBranches().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['boostMatches'] != null) {
            queryParameters['boostMatches'] = requestParameters['boostMatches'];
        }

        if (requestParameters['orderBy'] != null) {
            queryParameters['orderBy'] = requestParameters['orderBy'];
        }

        if (requestParameters['details'] != null) {
            queryParameters['details'] = requestParameters['details'];
        }

        if (requestParameters['filterText'] != null) {
            queryParameters['filterText'] = requestParameters['filterText'];
        }

        if (requestParameters['base'] != null) {
            queryParameters['base'] = requestParameters['base'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the branches matching the supplied <strong>filterText</strong> param.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Find branches
     */
    async getBranches(requestParameters: GetBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetBranches200Response> {
        const response = await this.getBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of changes made in a specified commit.    <strong>Note:</strong> The implementation will apply a hard cap (<code>page.max.changes</code>) and it is not possible to request subsequent content when that cap is exceeded.    The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get changes in commit
     */
    async getChangesRaw(requestParameters: GetChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetChanges1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getChanges().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getChanges().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getChanges().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['withComments'] != null) {
            queryParameters['withComments'] = requestParameters['withComments'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/changes`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of changes made in a specified commit.    <strong>Note:</strong> The implementation will apply a hard cap (<code>page.max.changes</code>) and it is not possible to request subsequent content when that cap is exceeded.    The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get changes in commit
     */
    async getChanges(requestParameters: GetChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetChanges1200Response> {
        const response = await this.getChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of changes made in a specified commit.   <strong>Note:</strong> The implementation will apply a hard cap ({@code page.max.changes}) and it is not possible to request subsequent content when that cap is exceeded.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get changes made in commit
     */
    async getChanges1Raw(requestParameters: GetChanges1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetChanges1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getChanges1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getChanges1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['until'] != null) {
            queryParameters['until'] = requestParameters['until'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/changes`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of changes made in a specified commit.   <strong>Note:</strong> The implementation will apply a hard cap ({@code page.max.changes}) and it is not possible to request subsequent content when that cap is exceeded.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get changes made in commit
     */
    async getChanges1(requestParameters: GetChanges1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetChanges1200Response> {
        const response = await this.getChanges1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a commit discussion comment.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.
     * Get a commit comment
     */
    async getCommentRaw(requestParameters: GetCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getComment().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling getComment().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getComment().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a commit discussion comment.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.
     * Get a commit comment
     */
    async getComment(requestParameters: GetCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.getCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the commit discussion comments that match the specified search criteria.  It is possible to retrieve commit discussion comments that are anchored to a range of commits by providing the sinceId that the comments anchored from.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.
     * Search for commit comments
     */
    async getCommentsRaw(requestParameters: GetCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetComments200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getComments().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getComments().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the commit discussion comments that match the specified search criteria.  It is possible to retrieve commit discussion comments that are anchored to a range of commits by providing the sinceId that the comments anchored from.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.
     * Search for commit comments
     */
    async getComments(requestParameters: GetCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetComments200Response> {
        const response = await this.getCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a single commit <i>identified by its ID</i>. In general, that ID is a SHA1. <u>From 2.11, ref names like \"refs/heads/master\" are no longer accepted by this resource.</u>  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get commit by ID
     */
    async getCommitRaw(requestParameters: GetCommitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestCommit>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getCommit().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling getCommit().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getCommit().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a single commit <i>identified by its ID</i>. In general, that ID is a SHA1. <u>From 2.11, ref names like \"refs/heads/master\" are no longer accepted by this resource.</u>  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get commit by ID
     */
    async getCommit(requestParameters: GetCommitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestCommit> {
        const response = await this.getCommitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of commits from a given starting commit or \"between\" two commits. If no explicit commit is specified, the tip of the repository\'s default branch is assumed. commits may be identified by branch or tag name or by ID. A path may be supplied to restrict the returned commits to only those which affect that path.   The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.
     * Get commits
     */
    async getCommitsRaw(requestParameters: GetCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCommits200Response1>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getCommits().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getCommits().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['avatarScheme'] != null) {
            queryParameters['avatarScheme'] = requestParameters['avatarScheme'];
        }

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['withCounts'] != null) {
            queryParameters['withCounts'] = requestParameters['withCounts'];
        }

        if (requestParameters['followRenames'] != null) {
            queryParameters['followRenames'] = requestParameters['followRenames'];
        }

        if (requestParameters['until'] != null) {
            queryParameters['until'] = requestParameters['until'];
        }

        if (requestParameters['avatarSize'] != null) {
            queryParameters['avatarSize'] = requestParameters['avatarSize'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        if (requestParameters['merges'] != null) {
            queryParameters['merges'] = requestParameters['merges'];
        }

        if (requestParameters['ignoreMissing'] != null) {
            queryParameters['ignoreMissing'] = requestParameters['ignoreMissing'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of commits from a given starting commit or \"between\" two commits. If no explicit commit is specified, the tip of the repository\'s default branch is assumed. commits may be identified by branch or tag name or by ID. A path may be supplied to restrict the returned commits to only those which affect that path.   The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call this resource.
     * Get commits
     */
    async getCommits(requestParameters: GetCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCommits200Response1> {
        const response = await this.getCommitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a page of hook scripts configured for the specified repository.   This endpoint requires **REPO_ADMIN** permission.
     * Get hook scripts
     */
    async getConfigurations1Raw(requestParameters: GetConfigurations1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetConfigurations200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getConfigurations1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getConfigurations1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return a page of hook scripts configured for the specified repository.   This endpoint requires **REPO_ADMIN** permission.
     * Get hook scripts
     */
    async getConfigurations1(requestParameters: GetConfigurations1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetConfigurations200Response> {
        const response = await this.getConfigurations1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of content for a file path at a specified revision.   Responses from this endpoint vary widely depending on the query parameters. The example JSON is for a request that does not use size, type, blame or noContent.   1. size will return a response like {\"size\":10000} 2. type will return a response like {\"type\":\"FILE\"}, where possible values are    \"DIRECTORY\", \"FILE\" and \"SUBMODULE\" 3. blame <i>without</i> noContent will include blame for the lines of    content returned on the page 4. blame <i>with</i> noContent will omit file contents and only return    blame for the requested lines 5. noContent without blame is ignored and does nothing   The various parameters are \"processed\" in the above order. That means ?size=true&amp;type=truewill return a size response, not a type one; the type parameter will be ignored.   The blame and noContent query parameters are handled differently from size and type. For blame and noContent, the <i>presence</i> of the parameter implies \"true\" if no value is specified; size and and type both require an explicit=true or they\'re treated as \"false\".   - ?blame is the same as ?blame=true - ?blame&amp;noContent is the same as ?blame=true&amp;noContent=true - ?size is the same as ?size=false - ?type is the same as ?type=false   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get file content at revision
     */
    async getContentRaw(requestParameters: GetContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getContent().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getContent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['noContent'] != null) {
            queryParameters['noContent'] = requestParameters['noContent'];
        }

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['blame'] != null) {
            queryParameters['blame'] = requestParameters['blame'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve a page of content for a file path at a specified revision.   Responses from this endpoint vary widely depending on the query parameters. The example JSON is for a request that does not use size, type, blame or noContent.   1. size will return a response like {\"size\":10000} 2. type will return a response like {\"type\":\"FILE\"}, where possible values are    \"DIRECTORY\", \"FILE\" and \"SUBMODULE\" 3. blame <i>without</i> noContent will include blame for the lines of    content returned on the page 4. blame <i>with</i> noContent will omit file contents and only return    blame for the requested lines 5. noContent without blame is ignored and does nothing   The various parameters are \"processed\" in the above order. That means ?size=true&amp;type=truewill return a size response, not a type one; the type parameter will be ignored.   The blame and noContent query parameters are handled differently from size and type. For blame and noContent, the <i>presence</i> of the parameter implies \"true\" if no value is specified; size and and type both require an explicit=true or they\'re treated as \"false\".   - ?blame is the same as ?blame=true - ?blame&amp;noContent is the same as ?blame=true&amp;noContent=true - ?size is the same as ?size=false - ?type is the same as ?type=false   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get file content at revision
     */
    async getContent(requestParameters: GetContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getContentRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a page of content for a file path at a specified revision.   Responses from this endpoint vary widely depending on the query parameters. The example JSON is for a request that does not use size, type, blame or noContent.   1. size will return a response like {\"size\":10000} 2. type will return a response like {\"type\":\"FILE\"}, where possible values are    \"DIRECTORY\", \"FILE\" and \"SUBMODULE\" 3. blame <i>without</i> noContent will include blame for the lines of    content returned on the page 4. blame <i>with</i> noContent will omit file contents and only return    blame for the requested lines 5. noContent without blame is ignored and does nothing   The various parameters are \"processed\" in the above order. That means ?size=true&amp;type=truewill return a size response, not a type one; the type parameter will be ignored.   The blame and noContent query parameters are handled differently from size and type. For blame and noContent, the <i>presence</i> of the parameter implies \"true\" if no value is specified; size and and type both require an explicit=true or they\'re treated as \"false\".   - ?blame is the same as ?blame=true - ?blame&amp;noContent is the same as ?blame=true&amp;noContent=true - ?size is the same as ?size=false - ?type is the same as ?type=false   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get file content
     */
    async getContent1Raw(requestParameters: GetContent1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling getContent1().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getContent1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getContent1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['noContent'] != null) {
            queryParameters['noContent'] = requestParameters['noContent'];
        }

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['blame'] != null) {
            queryParameters['blame'] = requestParameters['blame'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/browse/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve a page of content for a file path at a specified revision.   Responses from this endpoint vary widely depending on the query parameters. The example JSON is for a request that does not use size, type, blame or noContent.   1. size will return a response like {\"size\":10000} 2. type will return a response like {\"type\":\"FILE\"}, where possible values are    \"DIRECTORY\", \"FILE\" and \"SUBMODULE\" 3. blame <i>without</i> noContent will include blame for the lines of    content returned on the page 4. blame <i>with</i> noContent will omit file contents and only return    blame for the requested lines 5. noContent without blame is ignored and does nothing   The various parameters are \"processed\" in the above order. That means ?size=true&amp;type=truewill return a size response, not a type one; the type parameter will be ignored.   The blame and noContent query parameters are handled differently from size and type. For blame and noContent, the <i>presence</i> of the parameter implies \"true\" if no value is specified; size and and type both require an explicit=true or they\'re treated as \"false\".   - ?blame is the same as ?blame=true - ?blame&amp;noContent is the same as ?blame=true&amp;noContent=true - ?size is the same as ?size=false - ?type is the same as ?type=false   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get file content
     */
    async getContent1(requestParameters: GetContent1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getContent1Raw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the repository\'s default branch, if it has been created. If the repository is empty, 204 No Content will be returned. For non-empty repositories, if the configured default branch has not yet been created a 404 Not Found will be returned.   This URL is deprecated. Callers should use <code>GET /projects/{key}/repos/{slug}/default-branch</code> instead, which allows retrieving the <i>configured</i> default branch even if the ref has not been created yet.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get default branch
     * @deprecated
     */
    async getDefaultBranch1Raw(requestParameters: GetDefaultBranch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBranch>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getDefaultBranch1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getDefaultBranch1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches/default`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the repository\'s default branch, if it has been created. If the repository is empty, 204 No Content will be returned. For non-empty repositories, if the configured default branch has not yet been created a 404 Not Found will be returned.   This URL is deprecated. Callers should use <code>GET /projects/{key}/repos/{slug}/default-branch</code> instead, which allows retrieving the <i>configured</i> default branch even if the ref has not been created yet.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get default branch
     * @deprecated
     */
    async getDefaultBranch1(requestParameters: GetDefaultBranch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBranch | null | undefined > {
        const response = await this.getDefaultBranch1Raw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Get the latest invocations for a specific webhook.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Get last webhook invocation details
     */
    async getLatestInvocation1Raw(requestParameters: GetLatestInvocation1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDetailedInvocation>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getLatestInvocation1().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getLatestInvocation1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getLatestInvocation1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['event'] != null) {
            queryParameters['event'] = requestParameters['event'];
        }

        if (requestParameters['outcome'] != null) {
            queryParameters['outcome'] = requestParameters['outcome'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/latest`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the latest invocations for a specific webhook.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Get last webhook invocation details
     */
    async getLatestInvocation1(requestParameters: GetLatestInvocation1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDetailedInvocation | null | undefined > {
        const response = await this.getLatestInvocation1Raw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Retrieve the pull request settings for the context repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource.   This resource will call all RestFragments that are registered with the key <strong>bitbucket.repository.settings.pullRequests</strong>. If any fragment fails validations by returning a non-empty Map of errors, then no fragments will execute.   The property keys for the settings that are bundled with the application are   - mergeConfig - the merge strategy configuration for pull requests - requiredApprovers - (Deprecated, please use com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook instead) the number of approvals required on a pull request for it to be mergeable, or 0 if the merge check is disabled - com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook - the merge check configuration for required approvers - requiredAllApprovers - whether or not all approvers must approve a pull request for it to be mergeable - requiredAllTasksComplete - whether or not all tasks on a pull request need to be completed for it to be mergeable - requiredSuccessfulBuilds - (Deprecated, please use com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck instead) the number of successful builds on a pull request for it to be mergeable, or 0 if the merge check is disabled - com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck - the merge check configuration for required builds   
     * Get pull request settings
     */
    async getPullRequestSettings1Raw(requestParameters: GetPullRequestSettings1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryPullRequestSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPullRequestSettings1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getPullRequestSettings1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/pull-requests`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the pull request settings for the context repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource.   This resource will call all RestFragments that are registered with the key <strong>bitbucket.repository.settings.pullRequests</strong>. If any fragment fails validations by returning a non-empty Map of errors, then no fragments will execute.   The property keys for the settings that are bundled with the application are   - mergeConfig - the merge strategy configuration for pull requests - requiredApprovers - (Deprecated, please use com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook instead) the number of approvals required on a pull request for it to be mergeable, or 0 if the merge check is disabled - com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook - the merge check configuration for required approvers - requiredAllApprovers - whether or not all approvers must approve a pull request for it to be mergeable - requiredAllTasksComplete - whether or not all tasks on a pull request need to be completed for it to be mergeable - requiredSuccessfulBuilds - (Deprecated, please use com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck instead) the number of successful builds on a pull request for it to be mergeable, or 0 if the merge check is disabled - com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck - the merge check configuration for required builds   
     * Get pull request settings
     */
    async getPullRequestSettings1(requestParameters: GetPullRequestSettings1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryPullRequestSettings> {
        const response = await this.getPullRequestSettings1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of repository ref change activity.   The authenticated user must have <strong>REPO_ADMIN</strong> permission to call this resource.
     * Get ref change activity
     */
    async getRefChangeActivityRaw(requestParameters: GetRefChangeActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRefChangeActivity200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRefChangeActivity().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getRefChangeActivity().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ref'] != null) {
            queryParameters['ref'] = requestParameters['ref'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/ref-change-activities`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of repository ref change activity.   The authenticated user must have <strong>REPO_ADMIN</strong> permission to call this resource.
     * Get ref change activity
     */
    async getRefChangeActivity(requestParameters: GetRefChangeActivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRefChangeActivity200Response> {
        const response = await this.getRefChangeActivityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of repositories based on query parameters that control the search. See the documentation of the parameters for more details.   This resource is anonymously accessible.   <b>Note on permissions.</b> In absence of the <code>permission</code> query parameter the implicit \'read\' permission is assumed. Please note that this permission is lower than the <tt>REPO_READ</tt> permission rather than being equal to it. The implicit \'read\' permission for a given repository is assigned to any user that has any of the higher permissions, such as <tt>REPO_READ</tt>, as well as to anonymous users if the repository is marked as public. The important implication of the above is that an anonymous request to this resource with a permission level <tt>REPO_READ</tt> is guaranteed to receive an empty list of repositories as a result. For anonymous requests it is therefore recommended to not specify the <tt>permission</tt> parameter at all.
     * Search for repositories
     */
    async getRepositories1Raw(requestParameters: GetRepositories1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        const queryParameters: any = {};

        if (requestParameters['archived'] != null) {
            queryParameters['archived'] = requestParameters['archived'];
        }

        if (requestParameters['projectname'] != null) {
            queryParameters['projectname'] = requestParameters['projectname'];
        }

        if (requestParameters['projectkey'] != null) {
            queryParameters['projectkey'] = requestParameters['projectkey'];
        }

        if (requestParameters['visibility'] != null) {
            queryParameters['visibility'] = requestParameters['visibility'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repos`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of repositories based on query parameters that control the search. See the documentation of the parameters for more details.   This resource is anonymously accessible.   <b>Note on permissions.</b> In absence of the <code>permission</code> query parameter the implicit \'read\' permission is assumed. Please note that this permission is lower than the <tt>REPO_READ</tt> permission rather than being equal to it. The implicit \'read\' permission for a given repository is assigned to any user that has any of the higher permissions, such as <tt>REPO_READ</tt>, as well as to anonymous users if the repository is marked as public. The important implication of the above is that an anonymous request to this resource with a permission level <tt>REPO_READ</tt> is guaranteed to receive an empty list of repositories as a result. For anonymous requests it is therefore recommended to not specify the <tt>permission</tt> parameter at all.
     * Search for repositories
     */
    async getRepositories1(requestParameters: GetRepositories1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.getRepositories1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of recently accessed repositories for the currently authenticated user.   Repositories are ordered from most recently to least recently accessed. <p>Only authenticated users may call this resource.
     * Get recently accessed repositories
     */
    async getRepositoriesRecentlyAccessedRaw(requestParameters: GetRepositoriesRecentlyAccessedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        const queryParameters: any = {};

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/profile/recent/repos`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of recently accessed repositories for the currently authenticated user.   Repositories are ordered from most recently to least recently accessed. <p>Only authenticated users may call this resource.
     * Get recently accessed repositories
     */
    async getRepositoriesRecentlyAccessed(requestParameters: GetRepositoriesRecentlyAccessedRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.getRepositoriesRecentlyAccessedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a repository hook for this repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     */
    async getRepositoryHook1Raw(requestParameters: GetRepositoryHook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRepositoryHook1().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling getRepositoryHook1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getRepositoryHook1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a repository hook for this repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     */
    async getRepositoryHook1(requestParameters: GetRepositoryHook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.getRepositoryHook1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of repository hooks for this repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     */
    async getRepositoryHooks1Raw(requestParameters: GetRepositoryHooks1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoryHooks1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRepositoryHooks1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getRepositoryHooks1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of repository hooks for this repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     */
    async getRepositoryHooks1(requestParameters: GetRepositoryHooks1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoryHooks1200Response> {
        const response = await this.getRepositoryHooks1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a restriction as specified by a restriction id.   The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Get a ref restriction
     */
    async getRestriction1Raw(requestParameters: GetRestriction1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefRestriction>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRestriction1().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRestriction1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getRestriction1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a restriction as specified by a restriction id.   The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Get a ref restriction
     */
    async getRestriction1(requestParameters: GetRestriction1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefRestriction> {
        const response = await this.getRestriction1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for restrictions using the supplied parameters.  The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Search for ref restrictions
     */
    async getRestrictions1Raw(requestParameters: GetRestrictions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRestrictions1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRestrictions1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getRestrictions1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['matcherType'] != null) {
            queryParameters['matcherType'] = requestParameters['matcherType'];
        }

        if (requestParameters['matcherId'] != null) {
            queryParameters['matcherId'] = requestParameters['matcherId'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/repos/{repositorySlug}/restrictions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for restrictions using the supplied parameters.  The authenticated user must have <strong>REPO_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Search for ref restrictions
     */
    async getRestrictions1(requestParameters: GetRestrictions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRestrictions1200Response> {
        const response = await this.getRestrictions1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the settings for a repository hook for this repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     */
    async getSettings1Raw(requestParameters: GetSettings1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getSettings1().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling getSettings1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getSettings1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the settings for a repository hook for this repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     */
    async getSettings1(requestParameters: GetSettings1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleSettings> {
        const response = await this.getSettings1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the statistics for a specific webhook.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Get webhook statistics
     */
    async getStatistics1Raw(requestParameters: GetStatistics1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getStatistics1().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getStatistics1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getStatistics1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['event'] != null) {
            queryParameters['event'] = requestParameters['event'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/statistics`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get the statistics for a specific webhook.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Get webhook statistics
     */
    async getStatistics1(requestParameters: GetStatistics1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getStatistics1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the statistics summary for a specific webhook.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Get webhook statistics summary
     */
    async getStatisticsSummary1Raw(requestParameters: GetStatisticsSummary1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getStatisticsSummary1().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getStatisticsSummary1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getStatisticsSummary1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}/statistics/summary`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get the statistics summary for a specific webhook.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Get webhook statistics summary
     */
    async getStatisticsSummary1(requestParameters: GetStatisticsSummary1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getStatisticsSummary1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the synchronization status for the specified repository. In addition to listing refs which cannot be synchronized, if any, the status also provides the timestamp for the most recent synchronization and indicates whether synchronization is available and enabled. If \"?at\" is specified in the URL, the synchronization status for the specified ref is returned, rather than the complete repository status.  The authenticated user must have <b>REPO_READ</b> permission for the repository, or it must be public if the request is anonymous. Additionally, after synchronization is enabled for a repository, meaning synchronization was available at that time, permission changes and other actions can cause it to become unavailable. Even when synchronization is enabled, if it is no longer available for the repository it will not be performed.
     * Get synchronization status
     */
    async getStatusRaw(requestParameters: GetStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefSyncStatus>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getStatus().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sync/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the synchronization status for the specified repository. In addition to listing refs which cannot be synchronized, if any, the status also provides the timestamp for the most recent synchronization and indicates whether synchronization is available and enabled. If \"?at\" is specified in the URL, the synchronization status for the specified ref is returned, rather than the complete repository status.  The authenticated user must have <b>REPO_READ</b> permission for the repository, or it must be public if the request is anonymous. Additionally, after synchronization is enabled for a repository, meaning synchronization was available at that time, permission changes and other actions can cause it to become unavailable. Even when synchronization is enabled, if it is no longer available for the repository it will not be performed.
     * Get synchronization status
     */
    async getStatus(requestParameters: GetStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefSyncStatus> {
        const response = await this.getStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a tag in the specified repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource.
     * Get tag
     */
    async getTagRaw(requestParameters: GetTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestTag>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getTag().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getTag().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getTag().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags/{name}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a tag in the specified repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource.
     * Get tag
     */
    async getTag(requestParameters: GetTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestTag> {
        const response = await this.getTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the tags matching the supplied <strong>filterText</strong> param.   The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource.
     * Find tag
     */
    async getTagsRaw(requestParameters: GetTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTags200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getTags().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getTags().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['orderBy'] != null) {
            queryParameters['orderBy'] = requestParameters['orderBy'];
        }

        if (requestParameters['filterText'] != null) {
            queryParameters['filterText'] = requestParameters['filterText'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/tags`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the tags matching the supplied <strong>filterText</strong> param.   The authenticated user must have <strong>REPO_READ</strong> permission for the context repository to call this resource.
     * Find tag
     */
    async getTags(requestParameters: GetTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTags200Response> {
        const response = await this.getTagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a webhook by ID.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Get webhook
     */
    async getWebhook1Raw(requestParameters: GetWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestWebhook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getWebhook1().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getWebhook1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getWebhook1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['statistics'] != null) {
            queryParameters['statistics'] = requestParameters['statistics'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a webhook by ID.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Get webhook
     */
    async getWebhook1(requestParameters: GetWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestWebhook> {
        const response = await this.getWebhook1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add an emoticon reaction to a comment
     * React to a comment
     */
    async reactRaw(requestParameters: ReactRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserReaction>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling react().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling react().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling react().'
            );
        }

        if (requestParameters['emoticon'] == null) {
            throw new runtime.RequiredError(
                'emoticon',
                'Required parameter "emoticon" was null or undefined when calling react().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling react().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}/reactions/{emoticon}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"emoticon"}}`, encodeURIComponent(String(requestParameters['emoticon']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add an emoticon reaction to a comment
     * React to a comment
     */
    async react(requestParameters: ReactRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserReaction> {
        const response = await this.reactRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes the hook script from the set of hook scripts configured to run in the repository.   This endpoint requires **REPO_ADMIN** permission.
     * Remove a hook script
     */
    async removeConfiguration1Raw(requestParameters: RemoveConfiguration1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling removeConfiguration1().'
            );
        }

        if (requestParameters['scriptId'] == null) {
            throw new runtime.RequiredError(
                'scriptId',
                'Required parameter "scriptId" was null or undefined when calling removeConfiguration1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling removeConfiguration1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts/{scriptId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters['scriptId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes the hook script from the set of hook scripts configured to run in the repository.   This endpoint requires **REPO_ADMIN** permission.
     * Remove a hook script
     */
    async removeConfiguration1(requestParameters: RemoveConfiguration1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeConfiguration1Raw(requestParameters, initOverrides);
    }

    /**
     * Remove label that is applied to the given repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository.
     * Remove repository label
     */
    async removeLabelRaw(requestParameters: RemoveLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling removeLabel().'
            );
        }

        if (requestParameters['labelName'] == null) {
            throw new runtime.RequiredError(
                'labelName',
                'Required parameter "labelName" was null or undefined when calling removeLabel().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling removeLabel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/labels/{labelName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"labelName"}}`, encodeURIComponent(String(requestParameters['labelName']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove label that is applied to the given repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository.
     * Remove repository label
     */
    async removeLabel(requestParameters: RemoveLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeLabelRaw(requestParameters, initOverrides);
    }

    /**
     * Save attachment metadata.  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment that has the attachment metadata.
     * Save attachment metadata
     */
    async saveAttachmentMetadataRaw(requestParameters: SaveAttachmentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling saveAttachmentMetadata().'
            );
        }

        if (requestParameters['attachmentId'] == null) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter "attachmentId" was null or undefined when calling saveAttachmentMetadata().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling saveAttachmentMetadata().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/attachments/{attachmentId}/metadata`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters['attachmentId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Save attachment metadata.  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository that is associated to the attachment that has the attachment metadata.
     * Save attachment metadata
     */
    async saveAttachmentMetadata(requestParameters: SaveAttachmentMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.saveAttachmentMetadataRaw(requestParameters, initOverrides);
    }

    /**
     * Search webhooks in this repository and parent project. This endpoint returns a superset of the results returned by the /webhooks endpoint because it allows filtering by project scope too, not just repository webhooks.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Search webhooks
     */
    async searchWebhooksRaw(requestParameters: SearchWebhooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling searchWebhooks().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling searchWebhooks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['scopeType'] != null) {
            queryParameters['scopeType'] = requestParameters['scopeType'];
        }

        if (requestParameters['event'] != null) {
            queryParameters['event'] = requestParameters['event'];
        }

        if (requestParameters['statistics'] != null) {
            queryParameters['statistics'] = requestParameters['statistics'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/search`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Search webhooks in this repository and parent project. This endpoint returns a superset of the results returned by the /webhooks endpoint because it allows filtering by project scope too, not just repository webhooks.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Search webhooks
     */
    async searchWebhooks(requestParameters: SearchWebhooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.searchWebhooksRaw(requestParameters, initOverrides);
    }

    /**
     * Creates or updates the auto decline settings for the supplied repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for this repository to call the resource
     * Create auto decline settings
     */
    async set1Raw(requestParameters: Set1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoDeclineSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling set1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling set1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAutoDeclineSettingsRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates or updates the auto decline settings for the supplied repository.  The authenticated user must have <strong>REPO_ADMIN</strong> permission for this repository to call the resource
     * Create auto decline settings
     */
    async set1(requestParameters: Set1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoDeclineSettings> {
        const response = await this.set1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates/updates the hook script configuration for the provided hook script and repository.   This endpoint requires **REPO_ADMIN** permission.
     * Create/update a hook script
     */
    async setConfiguration1Raw(requestParameters: SetConfiguration1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestHookScriptConfig>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setConfiguration1().'
            );
        }

        if (requestParameters['scriptId'] == null) {
            throw new runtime.RequiredError(
                'scriptId',
                'Required parameter "scriptId" was null or undefined when calling setConfiguration1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setConfiguration1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/hook-scripts/{scriptId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters['scriptId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restHookScriptTriggers'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates/updates the hook script configuration for the provided hook script and repository.   This endpoint requires **REPO_ADMIN** permission.
     * Create/update a hook script
     */
    async setConfiguration1(requestParameters: SetConfiguration1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestHookScriptConfig> {
        const response = await this.setConfiguration1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the default branch of a repository.   This URL is deprecated. Callers should use <code>PUT /projects/{key}/repos/{slug}/default-branch</code> instead.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update default branch
     * @deprecated
     */
    async setDefaultBranch1Raw(requestParameters: SetDefaultBranch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setDefaultBranch1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setDefaultBranch1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/branches/default`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restBranch'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the default branch of a repository.   This URL is deprecated. Callers should use <code>PUT /projects/{key}/repos/{slug}/default-branch</code> instead.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update default branch
     * @deprecated
     */
    async setDefaultBranch1(requestParameters: SetDefaultBranch1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setDefaultBranch1Raw(requestParameters, initOverrides);
    }

    /**
     * Enables or disables synchronization for the specified repository. When synchronization is enabled, branches within the repository are immediately synchronized and the status is updated with the outcome. That initial synchronization is performed before the REST request returns, allowing it to return the updated status.  The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository. Anonymous users cannot manage synchronization, even on public repositories. Additionally, synchronization must be available for the specified repository. Synchronization is only available if:  - The repository is a fork, since its origin is used as upstream - The owning user still has access to the fork\'s origin,  if the repository is a <i>personalfork</i>
     * Disable synchronization
     */
    async setEnabledRaw(requestParameters: SetEnabledRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefSyncStatus>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setEnabled().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setEnabled().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sync/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRefSyncStatus'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enables or disables synchronization for the specified repository. When synchronization is enabled, branches within the repository are immediately synchronized and the status is updated with the outcome. That initial synchronization is performed before the REST request returns, allowing it to return the updated status.  The authenticated user must have <b>REPO_ADMIN</b> permission for the specified repository. Anonymous users cannot manage synchronization, even on public repositories. Additionally, synchronization must be available for the specified repository. Synchronization is only available if:  - The repository is a fork, since its origin is used as upstream - The owning user still has access to the fork\'s origin,  if the repository is a <i>personalfork</i>
     * Disable synchronization
     */
    async setEnabled(requestParameters: SetEnabledRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefSyncStatus | null | undefined > {
        const response = await this.setEnabledRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Modify the settings for a repository hook for this repository.   The service will reject any settings which are too large, the current limit is 32KB once serialized.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.   A JSON document can be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     */
    async setSettings1Raw(requestParameters: SetSettings1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling setSettings1().'
            );
        }

        if (requestParameters['hookKey'] == null) {
            throw new runtime.RequiredError(
                'hookKey',
                'Required parameter "hookKey" was null or undefined when calling setSettings1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling setSettings1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters['hookKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['exampleSettings'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify the settings for a repository hook for this repository.   The service will reject any settings which are too large, the current limit is 32KB once serialized.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.   A JSON document can be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     */
    async setSettings1(requestParameters: SetSettings1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleSettings> {
        const response = await this.setSettings1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams files in the requested <code>path</code> with the last commit to modify each file. Commit modifications are traversed starting from the <code>at</code> commit or, if not specified, from the tip of the default branch.  Unless the repository is public, the authenticated user must have <b>REPO_READ</b> access to call this resource.
     * Stream files with last modified commit in path
     */
    async _streamRaw(requestParameters: StreamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleFiles>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling stream().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling stream().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling stream().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/last-modified/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Streams files in the requested <code>path</code> with the last commit to modify each file. Commit modifications are traversed starting from the <code>at</code> commit or, if not specified, from the tip of the default branch.  Unless the repository is public, the authenticated user must have <b>REPO_READ</b> access to call this resource.
     * Stream files with last modified commit in path
     */
    async stream(requestParameters: StreamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleFiles> {
        const response = await this._streamRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams files from the repository\'s root with the last commit to modify each file. Commit modifications are traversed starting from the <code>at</code> commit or, if not specified, from the tip of the default branch.  Unless the repository is public, the authenticated user must have <b>REPO_READ</b> access to call this resource.
     * Stream files
     */
    async stream1Raw(requestParameters: Stream1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleFiles>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling stream1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling stream1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/last-modified`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Streams files from the repository\'s root with the last commit to modify each file. Commit modifications are traversed starting from the <code>at</code> commit or, if not specified, from the tip of the default branch.  Unless the repository is public, the authenticated user must have <b>REPO_READ</b> access to call this resource.
     * Stream files
     */
    async stream1(requestParameters: Stream1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleFiles> {
        const response = await this.stream1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the file changes available in the <code> from</code> commit but not in the <code> to</code> commit.   If either the <code> from</code> or <code> to</code> commit are not specified, they will be replaced by the default branch of their containing repository.
     * Compare commits
     */
    async streamChangesRaw(requestParameters: StreamChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetChanges1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamChanges().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamChanges().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromRepo'] != null) {
            queryParameters['fromRepo'] = requestParameters['fromRepo'];
        }

        if (requestParameters['from'] != null) {
            queryParameters['from'] = requestParameters['from'];
        }

        if (requestParameters['to'] != null) {
            queryParameters['to'] = requestParameters['to'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/changes`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the file changes available in the <code> from</code> commit but not in the <code> to</code> commit.   If either the <code> from</code> or <code> to</code> commit are not specified, they will be replaced by the default branch of their containing repository.
     * Compare commits
     */
    async streamChanges(requestParameters: StreamChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetChanges1200Response> {
        const response = await this.streamChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the commits accessible from the <code>from</code> commit but not in the <code>to</code> commit.  If either the <code>from</code> or <code>to</code> commit are not specified, they will be replaced by the default branch of their containing repository.
     * Get accessible commits
     */
    async streamCommitsRaw(requestParameters: StreamCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCommits200Response1>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamCommits().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamCommits().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromRepo'] != null) {
            queryParameters['fromRepo'] = requestParameters['fromRepo'];
        }

        if (requestParameters['from'] != null) {
            queryParameters['from'] = requestParameters['from'];
        }

        if (requestParameters['to'] != null) {
            queryParameters['to'] = requestParameters['to'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/commits`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the commits accessible from the <code>from</code> commit but not in the <code>to</code> commit.  If either the <code>from</code> or <code>to</code> commit are not specified, they will be replaced by the default branch of their containing repository.
     * Get accessible commits
     */
    async streamCommits(requestParameters: StreamCommitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCommits200Response1> {
        const response = await this.streamCommitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async streamDiffRaw(requestParameters: StreamDiffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamDiff().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling streamDiff().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamDiff().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['contextLines'] != null) {
            queryParameters['contextLines'] = requestParameters['contextLines'];
        }

        if (requestParameters['srcPath'] != null) {
            queryParameters['srcPath'] = requestParameters['srcPath'];
        }

        if (requestParameters['autoSrcPath'] != null) {
            queryParameters['autoSrcPath'] = requestParameters['autoSrcPath'];
        }

        if (requestParameters['whitespace'] != null) {
            queryParameters['whitespace'] = requestParameters['whitespace'];
        }

        if (requestParameters['withComments'] != null) {
            queryParameters['withComments'] = requestParameters['withComments'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async streamDiff(requestParameters: StreamDiffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamDiffRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve the diff between two provided revisions.  Note:</strong> This resource is currently <i>not paged</i>. The server will internally apply a hard cap to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded. In the event that the cap is reached, the diff will be cut short and one or more {@code truncated} flags will be set to true on the \"segments\", \"hunks\" and \"diffs\" properties, as well as the top-level object, in the returned JSON response.  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get diff between revisions
     */
    async streamDiff1Raw(requestParameters: StreamDiff1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDiff>> {
        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling streamDiff1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamDiff1().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling streamDiff1().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamDiff1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sinceId'] != null) {
            queryParameters['sinceId'] = requestParameters['sinceId'];
        }

        if (requestParameters['srcPath'] != null) {
            queryParameters['srcPath'] = requestParameters['srcPath'];
        }

        if (requestParameters['avatarSize'] != null) {
            queryParameters['avatarSize'] = requestParameters['avatarSize'];
        }

        if (requestParameters['avatarScheme'] != null) {
            queryParameters['avatarScheme'] = requestParameters['avatarScheme'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['contextLines'] != null) {
            queryParameters['contextLines'] = requestParameters['contextLines'];
        }

        if (requestParameters['autoSrcPath'] != null) {
            queryParameters['autoSrcPath'] = requestParameters['autoSrcPath'];
        }

        if (requestParameters['whitespace'] != null) {
            queryParameters['whitespace'] = requestParameters['whitespace'];
        }

        if (requestParameters['withComments'] != null) {
            queryParameters['withComments'] = requestParameters['withComments'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff/{path}`.replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the diff between two provided revisions.  Note:</strong> This resource is currently <i>not paged</i>. The server will internally apply a hard cap to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded. In the event that the cap is reached, the diff will be cut short and one or more {@code truncated} flags will be set to true on the \"segments\", \"hunks\" and \"diffs\" properties, as well as the top-level object, in the returned JSON response.  The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get diff between revisions
     */
    async streamDiff1(requestParameters: StreamDiff1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDiff> {
        const response = await this.streamDiff1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a diff of the changes available in the <code>from</code> commit but not in the <code> to</code> commit.  If either the <code> from</code> or <code> to</code> commit are not specified, they will be replaced by the default branch of their containing repository.
     * Get diff between commits
     */
    async streamDiff2Raw(requestParameters: StreamDiff2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamDiff2200Response>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling streamDiff2().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamDiff2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamDiff2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['contextLines'] != null) {
            queryParameters['contextLines'] = requestParameters['contextLines'];
        }

        if (requestParameters['fromRepo'] != null) {
            queryParameters['fromRepo'] = requestParameters['fromRepo'];
        }

        if (requestParameters['srcPath'] != null) {
            queryParameters['srcPath'] = requestParameters['srcPath'];
        }

        if (requestParameters['from'] != null) {
            queryParameters['from'] = requestParameters['from'];
        }

        if (requestParameters['to'] != null) {
            queryParameters['to'] = requestParameters['to'];
        }

        if (requestParameters['whitespace'] != null) {
            queryParameters['whitespace'] = requestParameters['whitespace'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/compare/diff{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets a diff of the changes available in the <code>from</code> commit but not in the <code> to</code> commit.  If either the <code> from</code> or <code> to</code> commit are not specified, they will be replaced by the default branch of their containing repository.
     * Get diff between commits
     */
    async streamDiff2(requestParameters: StreamDiff2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamDiff2200Response> {
        const response = await this.streamDiff2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of files from particular directory of a repository. The search is done recursively, so all files from any sub-directory of the specified directory will be returned.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get files in directory
     */
    async streamFilesRaw(requestParameters: StreamFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamFiles200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamFiles().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/files`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of files from particular directory of a repository. The search is done recursively, so all files from any sub-directory of the specified directory will be returned.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get files in directory
     */
    async streamFiles(requestParameters: StreamFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamFiles200Response> {
        const response = await this.streamFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of files from particular directory of a repository. The search is done recursively, so all files from any sub-directory of the specified directory will be returned.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get files in directory
     */
    async streamFiles1Raw(requestParameters: StreamFiles1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamFiles200Response>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling streamFiles1().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamFiles1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamFiles1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/files/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of files from particular directory of a repository. The search is done recursively, so all files from any sub-directory of the specified directory will be returned.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get files in directory
     */
    async streamFiles1(requestParameters: StreamFiles1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamFiles200Response> {
        const response = await this.streamFiles1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the patch content for a repository at a specified revision.   Cache headers are added to the response (only if full commit hashes are used, not in the case of short hashes).   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get patch content at revision
     */
    async streamPatchRaw(requestParameters: StreamPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamPatch().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamPatch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['until'] != null) {
            queryParameters['until'] = requestParameters['until'];
        }

        if (requestParameters['allAncestors'] != null) {
            queryParameters['allAncestors'] = requestParameters['allAncestors'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/patch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve the patch content for a repository at a specified revision.   Cache headers are added to the response (only if full commit hashes are used, not in the case of short hashes).   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get patch content at revision
     */
    async streamPatch(requestParameters: StreamPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamPatchRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve the raw content for a file path at a specified revision.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get raw content of a file at revision
     */
    async streamRawRaw(requestParameters: StreamRawRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling streamRaw().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamRaw().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamRaw().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['at'] != null) {
            queryParameters['at'] = requestParameters['at'];
        }

        if (requestParameters['markup'] != null) {
            queryParameters['markup'] = requestParameters['markup'];
        }

        if (requestParameters['htmlEscape'] != null) {
            queryParameters['htmlEscape'] = requestParameters['htmlEscape'];
        }

        if (requestParameters['includeHeadingId'] != null) {
            queryParameters['includeHeadingId'] = requestParameters['includeHeadingId'];
        }

        if (requestParameters['hardwrap'] != null) {
            queryParameters['hardwrap'] = requestParameters['hardwrap'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/raw/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve the raw content for a file path at a specified revision.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get raw content of a file at revision
     */
    async streamRaw(requestParameters: StreamRawRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamRawRaw(requestParameters, initOverrides);
    }

    /**
     * Stream the raw diff between two provided revisions.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get raw diff for path
     */
    async streamRawDiffRaw(requestParameters: StreamRawDiffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamRawDiff().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamRawDiff().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['contextLines'] != null) {
            queryParameters['contextLines'] = requestParameters['contextLines'];
        }

        if (requestParameters['srcPath'] != null) {
            queryParameters['srcPath'] = requestParameters['srcPath'];
        }

        if (requestParameters['until'] != null) {
            queryParameters['until'] = requestParameters['until'];
        }

        if (requestParameters['whitespace'] != null) {
            queryParameters['whitespace'] = requestParameters['whitespace'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/diff`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stream the raw diff between two provided revisions.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get raw diff for path
     */
    async streamRawDiff(requestParameters: StreamRawDiffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamRawDiffRaw(requestParameters, initOverrides);
    }

    /**
     * Stream the raw diff between two provided revisions.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get raw diff for path
     */
    async streamRawDiff1Raw(requestParameters: StreamRawDiff1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling streamRawDiff1().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling streamRawDiff1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling streamRawDiff1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['contextLines'] != null) {
            queryParameters['contextLines'] = requestParameters['contextLines'];
        }

        if (requestParameters['srcPath'] != null) {
            queryParameters['srcPath'] = requestParameters['srcPath'];
        }

        if (requestParameters['until'] != null) {
            queryParameters['until'] = requestParameters['until'];
        }

        if (requestParameters['whitespace'] != null) {
            queryParameters['whitespace'] = requestParameters['whitespace'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/diff/{path}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stream the raw diff between two provided revisions.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get raw diff for path
     */
    async streamRawDiff1(requestParameters: StreamRawDiff1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamRawDiff1Raw(requestParameters, initOverrides);
    }

    /**
     * Allows developers to apply a manual operation to bring a ref back in sync with upstream when it becomes out of sync due to conflicting changes. The following actions are supported:  - <tt>MERGE</tt>: Merges in commits from the upstream ref. After applying this action, the   synchronized ref will be <tt>AHEAD</tt> (as it still includes commits that do not exist   upstream.    - This action is only supported for <tt>DIVERGED</tt> refs    - If a \"commitMessage\" is provided in the context, it will be used on the merge commit.      Otherwise a default message is used. - <tt>DISCARD</tt>: <i>Throws away</i> local changes in favour of those made upstream. This is a   <i>destructive</i> operation where commits in the local repository are lost.    - No context entries are supported for this action    - If the upstream ref has been deleted, the local ref is deleted as well    - Otherwise, the local ref is updated to reference the same commit as upstream, even if      the update is not fast-forward (similar to a forced push)   The authenticated user must have <b>REPO_WRITE</b> permission for the specified repository. Anonymous users cannot synchronize refs, even on public repositories. Additionally, synchronization must be <i>enabled</i> and <i>available</i> for the specified repository.
     * Manual synchronization
     */
    async synchronizeRaw(requestParameters: SynchronizeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRejectedRef>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling synchronize().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling synchronize().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sync/latest/projects/{projectKey}/repos/{repositorySlug}/synchronize`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRefSyncRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Allows developers to apply a manual operation to bring a ref back in sync with upstream when it becomes out of sync due to conflicting changes. The following actions are supported:  - <tt>MERGE</tt>: Merges in commits from the upstream ref. After applying this action, the   synchronized ref will be <tt>AHEAD</tt> (as it still includes commits that do not exist   upstream.    - This action is only supported for <tt>DIVERGED</tt> refs    - If a \"commitMessage\" is provided in the context, it will be used on the merge commit.      Otherwise a default message is used. - <tt>DISCARD</tt>: <i>Throws away</i> local changes in favour of those made upstream. This is a   <i>destructive</i> operation where commits in the local repository are lost.    - No context entries are supported for this action    - If the upstream ref has been deleted, the local ref is deleted as well    - Otherwise, the local ref is updated to reference the same commit as upstream, even if      the update is not fast-forward (similar to a forced push)   The authenticated user must have <b>REPO_WRITE</b> permission for the specified repository. Anonymous users cannot synchronize refs, even on public repositories. Additionally, synchronization must be <i>enabled</i> and <i>available</i> for the specified repository.
     * Manual synchronization
     */
    async synchronize(requestParameters: SynchronizeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRejectedRef | null | undefined > {
        const response = await this.synchronizeRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Test connectivity to a specific endpoint.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Test webhook
     */
    async testWebhook1Raw(requestParameters: TestWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling testWebhook1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling testWebhook1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['webhookId'] != null) {
            queryParameters['webhookId'] = requestParameters['webhookId'];
        }

        if (requestParameters['sslVerificationRequired'] != null) {
            queryParameters['sslVerificationRequired'] = requestParameters['sslVerificationRequired'];
        }

        if (requestParameters['url'] != null) {
            queryParameters['url'] = requestParameters['url'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/test`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restWebhookCredentials'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Test connectivity to a specific endpoint.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Test webhook
     */
    async testWebhook1(requestParameters: TestWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.testWebhook1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove an emoticon reaction from a comment
     * Remove a reaction from comment
     */
    async unReactRaw(requestParameters: UnReactRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unReact().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling unReact().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling unReact().'
            );
        }

        if (requestParameters['emoticon'] == null) {
            throw new runtime.RequiredError(
                'emoticon',
                'Required parameter "emoticon" was null or undefined when calling unReact().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling unReact().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/comment-likes/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}/reactions/{emoticon}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"emoticon"}}`, encodeURIComponent(String(requestParameters['emoticon']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an emoticon reaction from a comment
     * Remove a reaction from comment
     */
    async unReact(requestParameters: UnReactRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unReactRaw(requestParameters, initOverrides);
    }

    /**
     * Remove the authenticated user as a watcher for the specified commit.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository containing the commit to call this resource.
     * Stop watching commit
     */
    async unwatchRaw(requestParameters: UnwatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unwatch().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling unwatch().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling unwatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the authenticated user as a watcher for the specified commit.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository containing the commit to call this resource.
     * Stop watching commit
     */
    async unwatch(requestParameters: UnwatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unwatchRaw(requestParameters, initOverrides);
    }

    /**
     * Remove the authenticated user as a watcher for the specified repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository to call this resource.
     * Stop watching repository
     */
    async unwatch2Raw(requestParameters: Unwatch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unwatch2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling unwatch2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/watch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the authenticated user as a watcher for the specified repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository to call this resource.
     * Stop watching repository
     */
    async unwatch2(requestParameters: Unwatch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unwatch2Raw(requestParameters, initOverrides);
    }

    /**
     * Update a comment, with the following restrictions:  - only the author of the comment may update the <i>text</i> of the comment - only the author of the comment or repository admins and above may update the other   fields of a comment   <strong>Note:</strong> the supplied supplied JSON object must contain a <code>version</code> that must match the server\'s version of the comment or the update will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the update. Look for the \'version\' attribute in the returned JSON structure.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.
     * Update a commit comment
     */
    async updateCommentRaw(requestParameters: UpdateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComment>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateComment().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling updateComment().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling updateComment().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters['commentId']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restComment'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update a comment, with the following restrictions:  - only the author of the comment may update the <i>text</i> of the comment - only the author of the comment or repository admins and above may update the other   fields of a comment   <strong>Note:</strong> the supplied supplied JSON object must contain a <code>version</code> that must match the server\'s version of the comment or the update will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the update. Look for the \'version\' attribute in the returned JSON structure.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the commit is in to call this resource.
     * Update a commit comment
     */
    async updateComment(requestParameters: UpdateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComment> {
        const response = await this.updateCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the pull request settings for the context repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the context repository to call this resource.   This resource will call all RestFragments that are registered with the key <strong>bitbucket.repository.settings.pullRequests</strong>. If any fragment fails validations by returning a non-empty Map of errors, then no fragments will execute.   Only the settings that should be updated need to be included in the request.   The property keys for the settings that are bundled with the application are   - mergeConfig - the merge strategy configuration for pull requests - requiredApprovers - (Deprecated, please use com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook instead) the number of approvals required on a pull request for it to be mergeable, or 0 to disable the merge check - com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook - a json map containing the keys \'enabled\' (a boolean to enable or disable this merge check) and \'count\' (an integer to set the number of required approvals) - requiredAllApprovers - whether or not all approvers must approve a pull request for it to be mergeable - requiredAllTasksComplete - whether or not all tasks on a pull request need to be completed for it to be mergeable - requiredSuccessfulBuilds - (Deprecated, please use com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck instead) the number of successful builds on a pull request for it to be mergeable, or 0 to disable the merge check - com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck - a json map containing the keys \'enabled\' (a boolean to enable or disable this merge check) and \'count\' (an integer to set the number of required builds)   <strong>Merge strategy configuration deletion:</strong>  An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty \"mergeConfig\" attribute. i.e:    ```{      \"mergeConfig\": {      }  }  ```  Upon completion of this request, the effective configuration will be:   - The configuration set for this repository\'s SCM type as set at the project level, if present, otherwise - the configuration set for this repository\'s SCM type as set at the instance level, if present, otherwise - the default configuration for this repository\'s SCM type   
     * Update pull request settings
     */
    async updatePullRequestSettings1Raw(requestParameters: UpdatePullRequestSettings1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryPullRequestSettings>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePullRequestSettings1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updatePullRequestSettings1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/settings/pull-requests`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepositoryPullRequestSettings'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the pull request settings for the context repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the context repository to call this resource.   This resource will call all RestFragments that are registered with the key <strong>bitbucket.repository.settings.pullRequests</strong>. If any fragment fails validations by returning a non-empty Map of errors, then no fragments will execute.   Only the settings that should be updated need to be included in the request.   The property keys for the settings that are bundled with the application are   - mergeConfig - the merge strategy configuration for pull requests - requiredApprovers - (Deprecated, please use com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook instead) the number of approvals required on a pull request for it to be mergeable, or 0 to disable the merge check - com.atlassian.bitbucket.server.bundled-hooks.requiredApproversMergeHook - a json map containing the keys \'enabled\' (a boolean to enable or disable this merge check) and \'count\' (an integer to set the number of required approvals) - requiredAllApprovers - whether or not all approvers must approve a pull request for it to be mergeable - requiredAllTasksComplete - whether or not all tasks on a pull request need to be completed for it to be mergeable - requiredSuccessfulBuilds - (Deprecated, please use com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck instead) the number of successful builds on a pull request for it to be mergeable, or 0 to disable the merge check - com.atlassian.bitbucket.server.bitbucket-build.requiredBuildsMergeCheck - a json map containing the keys \'enabled\' (a boolean to enable or disable this merge check) and \'count\' (an integer to set the number of required builds)   <strong>Merge strategy configuration deletion:</strong>  An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty \"mergeConfig\" attribute. i.e:    ```{      \"mergeConfig\": {      }  }  ```  Upon completion of this request, the effective configuration will be:   - The configuration set for this repository\'s SCM type as set at the project level, if present, otherwise - the configuration set for this repository\'s SCM type as set at the instance level, if present, otherwise - the default configuration for this repository\'s SCM type   
     * Update pull request settings
     */
    async updatePullRequestSettings1(requestParameters: UpdatePullRequestSettings1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryPullRequestSettings> {
        const response = await this.updatePullRequestSettings1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing webhook.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     */
    async updateWebhook1Raw(requestParameters: UpdateWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestWebhook>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateWebhook1().'
            );
        }

        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling updateWebhook1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateWebhook1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/webhooks/{webhookId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restWebhook'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update an existing webhook.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     */
    async updateWebhook1(requestParameters: UpdateWebhook1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestWebhook> {
        const response = await this.updateWebhook1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add the authenticated user as a watcher for the specified commit.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository containing the commit to call this resource.
     * Watch commit
     */
    async watchRaw(requestParameters: WatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling watch().'
            );
        }

        if (requestParameters['commitId'] == null) {
            throw new runtime.RequiredError(
                'commitId',
                'Required parameter "commitId" was null or undefined when calling watch().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling watch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"commitId"}}`, encodeURIComponent(String(requestParameters['commitId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add the authenticated user as a watcher for the specified commit.  The authenticated user must have <strong>REPO_READ</strong> permission for the repository containing the commit to call this resource.
     * Watch commit
     */
    async watch(requestParameters: WatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.watchRaw(requestParameters, initOverrides);
    }

    /**
     * Add the authenticated user as a watcher for the specified repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository to call this resource.
     * Watch repository
     */
    async watch2Raw(requestParameters: Watch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling watch2().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling watch2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/watch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepository'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add the authenticated user as a watcher for the specified repository.   The authenticated user must have <strong>REPO_READ</strong> permission for the repository to call this resource.
     * Watch repository
     */
    async watch2(requestParameters: Watch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.watch2Raw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const GetBranchesOrderByEnum = {
    Alphabetical: 'ALPHABETICAL',
    Modification: 'MODIFICATION'
} as const;
export type GetBranchesOrderByEnum = typeof GetBranchesOrderByEnum[keyof typeof GetBranchesOrderByEnum];
/**
 * @export
 */
export const GetRepositories1VisibilityEnum = {
    Public: 'public',
    Private: 'private'
} as const;
export type GetRepositories1VisibilityEnum = typeof GetRepositories1VisibilityEnum[keyof typeof GetRepositories1VisibilityEnum];
/**
 * @export
 */
export const GetRepositories1PermissionEnum = {
    Read: 'REPO_READ',
    Write: 'REPO_WRITE',
    Admin: 'REPO_ADMIN'
} as const;
export type GetRepositories1PermissionEnum = typeof GetRepositories1PermissionEnum[keyof typeof GetRepositories1PermissionEnum];
/**
 * @export
 */
export const GetRepositories1StateEnum = {
    Available: 'AVAILABLE',
    Initialising: 'INITIALISING',
    InitialisationFailed: 'INITIALISATION_FAILED'
} as const;
export type GetRepositories1StateEnum = typeof GetRepositories1StateEnum[keyof typeof GetRepositories1StateEnum];
/**
 * @export
 */
export const GetRepositoryHooks1TypeEnum = {
    PreReceive: 'PRE_RECEIVE',
    PostReceive: 'POST_RECEIVE'
} as const;
export type GetRepositoryHooks1TypeEnum = typeof GetRepositoryHooks1TypeEnum[keyof typeof GetRepositoryHooks1TypeEnum];
/**
 * @export
 */
export const GetRestrictions1MatcherTypeEnum = {
    Branch: 'BRANCH',
    Pattern: 'PATTERN',
    ModelCategory: 'MODEL_CATEGORY',
    ModelBranch: 'MODEL_BRANCH'
} as const;
export type GetRestrictions1MatcherTypeEnum = typeof GetRestrictions1MatcherTypeEnum[keyof typeof GetRestrictions1MatcherTypeEnum];
/**
 * @export
 */
export const GetRestrictions1TypeEnum = {
    ReadOnly: 'read-only',
    NoDeletes: 'no-deletes',
    FastForwardOnly: 'fast-forward-only',
    PullRequestOnly: 'pull-request-only'
} as const;
export type GetRestrictions1TypeEnum = typeof GetRestrictions1TypeEnum[keyof typeof GetRestrictions1TypeEnum];
