/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ExamplePreviewMigration,
  ExamplePutMultipartFormData,
  ExampleSettingsMap,
  GetAllAccessTokens401Response,
  GetAllMeshMigrationSummaries200Response,
  GetAllRateLimitSettings200Response,
  GetExportJobMessages200Response,
  GetHistory200Response,
  GetLabelables200Response,
  GetLabels200Response,
  RestAnnouncementBanner,
  RestApplicationProperties,
  RestApplicationUser,
  RestBitbucketLicense,
  RestBulkUserRateLimitSettingsUpdateRequest,
  RestClusterInformation,
  RestErrors,
  RestExportRequest,
  RestHookScript,
  RestImportRequest,
  RestJob,
  RestLabel,
  RestLogLevel,
  RestLoggingSettings,
  RestMailConfiguration,
  RestMeshConnectivityReport,
  RestMeshMigrationRequest,
  RestMeshMigrationSummary,
  RestMeshNode,
  RestNamedLink,
  RestRateLimitSettings,
  RestRepositoryPolicy,
  RestScopesExample,
  RestSshKeySettings,
  RestUserRateLimitSettings,
  RestUserRateLimitSettingsUpdateRequest,
  SearchMeshMigrationRepos200Response,
  SetBannerRequest,
  SetDefaultBranchRequest,
  SetMailConfigRequest,
  SetSettings2Request,
  StartMeshMigrationRequest,
  UserPasswordUpdate,
  UserUpdateWithCredentials,
} from '../models/index';

interface CancelExportJobRequest {
    jobId: string;
}

interface CancelImportJobRequest {
    jobId: string;
}

interface CancelMeshMigrationJobRequest {
    jobId: string;
}

interface CreateHookScriptRequest {
    content?: string;
    description?: string;
    name?: string;
    type?: string;
}

interface Delete2Request {
    id: number;
    force?: boolean;
}

interface Delete8Request {
    userSlug: string;
}

interface DeleteAvatarRequest {
    userSlug: string;
}

interface DeleteHookScriptRequest {
    scriptId: string;
}

interface Get6Request {
    userSlug: string;
}

interface GetAllMeshMigrationSummariesRequest {
    start?: number;
    limit?: number;
}

interface GetAllRateLimitSettingsRequest {
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetExportJobRequest {
    jobId: string;
}

interface GetExportJobMessagesRequest {
    jobId: string;
    severity?: string;
    subject?: string;
    start?: number;
    limit?: number;
}

interface GetHistoryRequest {
    order?: GetHistoryOrderEnum;
    start?: number;
    limit?: number;
}

interface GetHookScriptRequest {
    scriptId: string;
}

interface GetImportJobRequest {
    jobId: string;
}

interface GetImportJobMessagesRequest {
    jobId: string;
    severity?: string;
    subject?: string;
    start?: number;
    limit?: number;
}

interface GetLabelRequest {
    labelName: string;
}

interface GetLabelablesRequest {
    labelName: string;
    type?: string;
    start?: number;
    limit?: number;
}

interface GetLabelsRequest {
    prefix?: string;
    start?: number;
    limit?: number;
}

interface GetLevelRequest {
    loggerName: string;
}

interface GetMeshMigrationJobRequest {
    jobId: string;
}

interface GetMeshMigrationJobMessagesRequest {
    jobId: string;
    severity?: string;
    subject?: string;
    start?: number;
    limit?: number;
}

interface GetMeshMigrationJobSummaryRequest {
    jobId: string;
}

interface GetRegisteredMeshNodeByIdRequest {
    id: string;
}

interface GetSupportZipRequest {
    id: string;
}

interface GetUserRequest {
    userSlug: string;
}

interface GetUserSettingsRequest {
    userSlug: string;
}

interface GetUsers2Request {
    filter?: string;
    permissionN?: string;
    permission?: string;
    group?: string;
}

interface PreviewExportRequest {
    restExportRequest?: RestExportRequest;
}

interface PreviewMeshMigrationRequest {
    restMeshMigrationRequest?: RestMeshMigrationRequest;
}

interface ReadRequest {
    scriptId: string;
}

interface RegisterNewMeshNodeRequest {
    restMeshNode?: RestMeshNode;
}

interface SearchMeshMigrationReposRequest {
    migrationId?: string;
    projectKey?: string;
    name?: string;
    state?: string;
    remote?: string;
    start?: number;
    limit?: number;
}

interface Set2Request {
    restBulkUserRateLimitSettingsUpdateRequest?: RestBulkUserRateLimitSettingsUpdateRequest;
}

interface Set3Request {
    userSlug: string;
    restUserRateLimitSettingsUpdateRequest?: RestUserRateLimitSettingsUpdateRequest;
}

interface SetBannerOperationRequest {
    setBannerRequest?: SetBannerRequest;
}

interface SetDefaultBranchOperationRequest {
    setDefaultBranchRequest?: SetDefaultBranchRequest;
}

interface SetLevelRequest {
    levelName: string;
    loggerName: string;
}

interface SetMailConfigOperationRequest {
    setMailConfigRequest?: SetMailConfigRequest;
}

interface SetRepositoryArchivePolicyRequest {
    restRepositoryPolicy?: RestRepositoryPolicy;
}

interface SetRepositoryDeletePolicyRequest {
    restRepositoryPolicy?: RestRepositoryPolicy;
}

interface SetRootLevelRequest {
    levelName: string;
}

interface SetSenderAddressRequest {
    body?: string;
}

interface SetSettings2OperationRequest {
    setSettings2Request?: SetSettings2Request;
}

interface SetSettings3Request {
    restRateLimitSettings?: RestRateLimitSettings;
}

interface StartExportRequest {
    restExportRequest?: RestExportRequest;
}

interface StartImportRequest {
    restImportRequest?: RestImportRequest;
}

interface StartMeshMigrationOperationRequest {
    startMeshMigrationRequest?: StartMeshMigrationRequest;
}

interface UpdateGlobalSettingsRequest {
    restSshKeySettings?: RestSshKeySettings;
}

interface UpdateHookScriptRequest {
    scriptId: string;
    examplePutMultipartFormData?: ExamplePutMultipartFormData;
}

interface UpdateLicenseRequest {
    restBitbucketLicense?: Omit<RestBitbucketLicense, 'creationDate'|'daysBeforeExpiry'|'expiryDate'|'gracePeriodEndDate'|'maintenanceExpiryDate'|'maximumNumberOfUsers'|'numberOfDaysBeforeExpiry'|'numberOfDaysBeforeGracePeriodExpiry'|'numberOfDaysBeforeMaintenanceExpiry'|'purchaseDate'|'serverId'|'supportEntitlementNumber'|'unlimitedNumberOfUsers'>;
}

interface UpdateMeshNodeRequest {
    id: string;
    restMeshNode?: RestMeshNode;
}

interface UpdateSettingsRequest {
    userSlug: string;
    exampleSettingsMap?: ExampleSettingsMap;
}

interface UpdateUserDetails1Request {
    userUpdateWithCredentials?: UserUpdateWithCredentials;
}

interface UpdateUserPassword1Request {
    userPasswordUpdate?: UserPasswordUpdate;
}

interface UploadAvatar1Request {
    userSlug: string;
    xAtlassianToken?: string;
    avatar?: Blob;
}

/**
 * 
 */
export class SystemMaintenanceApi extends runtime.BaseAPI {

    /**
     * Requests the cancellation of an export job.  The request to cancel a job will be processed successfully if the job is actually still running. If it has already finished (successfully or with errors) or if it has already been canceled before, then an error will be returned.  There might be a small delay between accepting the request and actually cancelling the job. In most cases, the delay will be close to instantaneously. In the unlikely case of communication issues across a cluster, it can however take a few seconds to cancel a job.  A client should always actively query the job status to confirm that a job has been successfully canceled.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Cancel export job
     */
    async cancelExportJobRaw(requestParameters: CancelExportJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling cancelExportJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/exports/{jobId}/cancel`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Requests the cancellation of an export job.  The request to cancel a job will be processed successfully if the job is actually still running. If it has already finished (successfully or with errors) or if it has already been canceled before, then an error will be returned.  There might be a small delay between accepting the request and actually cancelling the job. In most cases, the delay will be close to instantaneously. In the unlikely case of communication issues across a cluster, it can however take a few seconds to cancel a job.  A client should always actively query the job status to confirm that a job has been successfully canceled.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Cancel export job
     */
    async cancelExportJob(requestParameters: CancelExportJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cancelExportJobRaw(requestParameters, initOverrides);
    }

    /**
     * Requests the cancellation of an import job.  The request to cancel a job will be processed successfully if the job is actually still running. If it has already finished (successfully or with errors) or if it has already been canceled before, then an error will be returned.  Note that import jobs are not canceled as instantaneously as export jobs. Rather, once the request has been accepted, there are a number of checkpoints at which the job will actually apply it and stop. This is to keep the system in a reasonably consistent state:  - After the current fork hierarchy has been imported and verified. - Before the next repository is imported. - Before the next pull request is imported.  A client should always actively query the job status to confirm that a job has been successfully canceled.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Cancel import job
     */
    async cancelImportJobRaw(requestParameters: CancelImportJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling cancelImportJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/imports/{jobId}/cancel`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Requests the cancellation of an import job.  The request to cancel a job will be processed successfully if the job is actually still running. If it has already finished (successfully or with errors) or if it has already been canceled before, then an error will be returned.  Note that import jobs are not canceled as instantaneously as export jobs. Rather, once the request has been accepted, there are a number of checkpoints at which the job will actually apply it and stop. This is to keep the system in a reasonably consistent state:  - After the current fork hierarchy has been imported and verified. - Before the next repository is imported. - Before the next pull request is imported.  A client should always actively query the job status to confirm that a job has been successfully canceled.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Cancel import job
     */
    async cancelImportJob(requestParameters: CancelImportJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cancelImportJobRaw(requestParameters, initOverrides);
    }

    /**
     * Requests the cancellation of a migration job.   The request to cancel a job will be processed successfully if the job is actually still running. If it has already finished (successfully or with errors) or if it has already been canceled before, then an error will be returned.   There might be a small delay between accepting the request and actually cancelling the job. In most cases, the delay will be close to instantaneously. In the unlikely case of communication issues across a cluster, it can however take a few seconds to cancel a job.  A client should always actively query the job status to confirm that a job has been successfully canceled.  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Cancel Mesh migration job
     */
    async cancelMeshMigrationJobRaw(requestParameters: CancelMeshMigrationJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling cancelMeshMigrationJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/mesh/{jobId}/cancel`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Requests the cancellation of a migration job.   The request to cancel a job will be processed successfully if the job is actually still running. If it has already finished (successfully or with errors) or if it has already been canceled before, then an error will be returned.   There might be a small delay between accepting the request and actually cancelling the job. In most cases, the delay will be close to instantaneously. In the unlikely case of communication issues across a cluster, it can however take a few seconds to cancel a job.  A client should always actively query the job status to confirm that a job has been successfully canceled.  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Cancel Mesh migration job
     */
    async cancelMeshMigrationJob(requestParameters: CancelMeshMigrationJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cancelMeshMigrationJobRaw(requestParameters, initOverrides);
    }

    /**
     * Clears the global default branch, which is used when creating new repositories if an explicit default branch is not specified, if one has been configured.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Clear default branch
     */
    async clearDefaultBranchRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/default-branch`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Clears the global default branch, which is used when creating new repositories if an explicit default branch is not specified, if one has been configured.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Clear default branch
     */
    async clearDefaultBranch(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.clearDefaultBranchRaw(initOverrides);
    }

    /**
     * Clears the server email address.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Update mail configuration
     */
    async clearSenderAddressRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/mail-server/sender-address`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Clears the server email address.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Update mail configuration
     */
    async clearSenderAddress(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.clearSenderAddressRaw(initOverrides);
    }

    /**
     * Generates a connectivity report between the Bitbucket node(s) and the Mesh node(s).  The authenticated user must have **SYS_ADMIN** permission.
     * Generate Mesh connectivity report
     */
    async connectivityRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMeshConnectivityReport>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/diagnostics/connectivity`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Generates a connectivity report between the Bitbucket node(s) and the Mesh node(s).  The authenticated user must have **SYS_ADMIN** permission.
     * Generate Mesh connectivity report
     */
    async connectivity(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMeshConnectivityReport> {
        const response = await this.connectivityRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create a new hook script.  This endpoint requires **SYS_ADMIN** permission.
     * Create a new hook script
     */
    async createHookScriptRaw(requestParameters: CreateHookScriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestHookScript>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['content'] != null) {
            formParams.append('content', requestParameters['content'] as any);
        }

        if (requestParameters['description'] != null) {
            formParams.append('description', requestParameters['description'] as any);
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['type'] != null) {
            formParams.append('type', requestParameters['type'] as any);
        }

        const response = await this.request({
            path: `/api/latest/hook-scripts`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new hook script.  This endpoint requires **SYS_ADMIN** permission.
     * Create a new hook script
     */
    async createHookScript(requestParameters: CreateHookScriptRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestHookScript> {
        const response = await this.createHookScriptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a Mesh node  The authenticated user must have **SYS_ADMIN** permission.
     * Delete Mesh node
     */
    async delete2Raw(requestParameters: Delete2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling delete2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/nodes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Mesh node  The authenticated user must have **SYS_ADMIN** permission.
     * Delete Mesh node
     */
    async delete2(requestParameters: Delete2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete2Raw(requestParameters, initOverrides);
    }

    /**
     * Deletes the user-specific rate limit settings for the given user.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Delete user specific rate limit settings
     */
    async delete8Raw(requestParameters: Delete8Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling delete8().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/rate-limit/settings/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the user-specific rate limit settings for the given user.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Delete user specific rate limit settings
     */
    async delete8(requestParameters: Delete8Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.delete8Raw(requestParameters, initOverrides);
    }

    /**
     * Delete the avatar associated to a user.   Users are always allowed to delete their own avatar. To delete someone else\'s avatar the authenticated user must have global <strong>ADMIN</strong> permission, or global <strong>SYS_ADMIN</strong> permission to update a <strong>SYS_ADMIN</strong> user\'s avatar.
     * Delete user avatar
     */
    async deleteAvatarRaw(requestParameters: DeleteAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNamedLink>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling deleteAvatar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/users/{userSlug}/avatar.png`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Delete the avatar associated to a user.   Users are always allowed to delete their own avatar. To delete someone else\'s avatar the authenticated user must have global <strong>ADMIN</strong> permission, or global <strong>SYS_ADMIN</strong> permission to update a <strong>SYS_ADMIN</strong> user\'s avatar.
     * Delete user avatar
     */
    async deleteAvatar(requestParameters: DeleteAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNamedLink> {
        const response = await this.deleteAvatarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a banner, if one is present in the database.
     * Delete announcement banner
     */
    async deleteBannerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/banner`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a banner, if one is present in the database.
     * Delete announcement banner
     */
    async deleteBanner(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteBannerRaw(initOverrides);
    }

    /**
     * Deletes a registered hook script.  This endpoint requires **SYS_ADMIN** permission.
     * Delete a hook script.
     */
    async deleteHookScriptRaw(requestParameters: DeleteHookScriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['scriptId'] == null) {
            throw new runtime.RequiredError(
                'scriptId',
                'Required parameter "scriptId" was null or undefined when calling deleteHookScript().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/hook-scripts/{scriptId}`.replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters['scriptId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a registered hook script.  This endpoint requires **SYS_ADMIN** permission.
     * Delete a hook script.
     */
    async deleteHookScript(requestParameters: DeleteHookScriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteHookScriptRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes the current mail configuration.  The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     * Delete mail configuration
     */
    async deleteMailConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/mail-server`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the current mail configuration.  The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     * Delete mail configuration
     */
    async deleteMailConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMailConfigRaw(initOverrides);
    }

    /**
     * Dismisses the retention config review notification displayed by the audit plugin for the user that\'s currently logged in.
     * Dismiss retention config notification
     */
    async dismissRetentionConfigReviewNotificationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/audit/latest/notification-settings/retention-config-review`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Dismisses the retention config review notification displayed by the audit plugin for the user that\'s currently logged in.
     * Dismiss retention config notification
     */
    async dismissRetentionConfigReviewNotification(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dismissRetentionConfigReviewNotificationRaw(initOverrides);
    }

    /**
     * Retrieves details about the current license, as well as the current status of the system with regards to the installed license. The status includes the current number of users applied toward the license limit, as well as any status messages about the license (warnings about expiry or user counts exceeding license limits).   The authenticated user must have <b>ADMIN</b> permission. Unauthenticated users, and non-administrators, are not permitted to access license details.
     * Get license details
     */
    async get2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBitbucketLicense>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/license`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves details about the current license, as well as the current status of the system with regards to the installed license. The status includes the current number of users applied toward the license limit, as well as any status messages about the license (warnings about expiry or user counts exceeding license limits).   The authenticated user must have <b>ADMIN</b> permission. Unauthenticated users, and non-administrators, are not permitted to access license details.
     * Get license details
     */
    async get2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBitbucketLicense> {
        const response = await this.get2Raw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the user-specific rate limit settings for the given user.  To call this resource, the user must be authenticated and either have <strong>ADMIN</strong> permission or be the same user as the one whose settings are requested. A user with <strong>ADMIN</strong> permission cannot get the settings of a user with <strong>SYS_ADMIN</strong> permission.
     * Get user specific rate limit settings
     */
    async get6Raw(requestParameters: Get6Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserRateLimitSettings>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling get6().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/rate-limit/settings/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the user-specific rate limit settings for the given user.  To call this resource, the user must be authenticated and either have <strong>ADMIN</strong> permission or be the same user as the one whose settings are requested. A user with <strong>ADMIN</strong> permission cannot get the settings of a user with <strong>SYS_ADMIN</strong> permission.
     * Get user specific rate limit settings
     */
    async get6(requestParameters: Get6Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserRateLimitSettings> {
        const response = await this.get6Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the summary, including the queue status and progress, of the currently active Mesh migration job.  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get summary for Mesh migration job
     */
    async getActiveMeshMigrationSummaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMeshMigrationSummary>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/mesh/summary`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the summary, including the queue status and progress, of the currently active Mesh migration job.  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get summary for Mesh migration job
     */
    async getActiveMeshMigrationSummary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMeshMigrationSummary> {
        const response = await this.getActiveMeshMigrationSummaryRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of Mesh migration job summaries. Jobs are ordered by when they were started, newest first.   The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get all Mesh migration job summaries
     */
    async getAllMeshMigrationSummariesRaw(requestParameters: GetAllMeshMigrationSummariesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllMeshMigrationSummaries200Response>> {
        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/mesh/summaries`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of Mesh migration job summaries. Jobs are ordered by when they were started, newest first.   The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get all Mesh migration job summaries
     */
    async getAllMeshMigrationSummaries(requestParameters: GetAllMeshMigrationSummariesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllMeshMigrationSummaries200Response> {
        const response = await this.getAllMeshMigrationSummariesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the user-specific rate limit settings for the given user.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Get rate limit settings for user
     */
    async getAllRateLimitSettingsRaw(requestParameters: GetAllRateLimitSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllRateLimitSettings200Response>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/rate-limit/settings/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the user-specific rate limit settings for the given user.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Get rate limit settings for user
     */
    async getAllRateLimitSettings(requestParameters: GetAllRateLimitSettingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllRateLimitSettings200Response> {
        const response = await this.getAllRateLimitSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all the registered Mesh nodes.  The authenticated user must have **SYS_ADMIN** permission.
     * Get all registered Mesh nodes
     */
    async getAllRegisteredMeshNodesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMeshNode>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all the registered Mesh nodes.  The authenticated user must have **SYS_ADMIN** permission.
     * Get all registered Mesh nodes
     */
    async getAllRegisteredMeshNodes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMeshNode> {
        const response = await this.getAllRegisteredMeshNodesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve version information and other application properties.  No authentication is required to call this resource.
     * Get application properties
     */
    async getApplicationPropertiesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestApplicationProperties>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/application-properties`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve version information and other application properties.  No authentication is required to call this resource.
     * Get application properties
     */
    async getApplicationProperties(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestApplicationProperties> {
        const response = await this.getApplicationPropertiesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the announcement banner, if one exists and is available to the user
     * Get announcement banner
     */
    async getBannerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAnnouncementBanner>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/banner`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the announcement banner, if one exists and is available to the user
     * Get announcement banner
     */
    async getBanner(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAnnouncementBanner | null | undefined > {
        const response = await this.getBannerRaw(initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Obtain the control plane PEM.  The authenticated user must have **SYS_ADMIN** permission.
     * Get the control plane PEM
     */
    async getControlPlanePublicKeyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/config/control-plane.pem`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Obtain the control plane PEM.  The authenticated user must have **SYS_ADMIN** permission.
     * Get the control plane PEM
     */
    async getControlPlanePublicKey(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getControlPlanePublicKeyRaw(initOverrides);
    }

    /**
     * Retrieves the configured global default branch, which is used when creating new repositories if an explicit default branch is not specified.  The user must be authenticated to call this resource.
     * Get the default branch
     */
    async getDefaultBranchRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/default-branch`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the configured global default branch, which is used when creating new repositories if an explicit default branch is not specified.  The user must be authenticated to call this resource.
     * Get the default branch
     */
    async getDefaultBranch(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getDefaultBranchRaw(initOverrides);
    }

    /**
     * Gets the details, including the current status and progress, of the export job identified by the given ID.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Get export job details
     */
    async getExportJobRaw(requestParameters: GetExportJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestJob>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getExportJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/exports/{jobId}`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the details, including the current status and progress, of the export job identified by the given ID.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Get export job details
     */
    async getExportJob(requestParameters: GetExportJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestJob> {
        const response = await this.getExportJobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the messages generated by the job.  Without any filter, all messages will be returned, but the response can optionally be filtered for the following severities. The severity parameter can be repeated to include multiple severities in one response.  - INFO - WARN - ERROR  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Get job messages
     */
    async getExportJobMessagesRaw(requestParameters: GetExportJobMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExportJobMessages200Response>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getExportJobMessages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['severity'] != null) {
            queryParameters['severity'] = requestParameters['severity'];
        }

        if (requestParameters['subject'] != null) {
            queryParameters['subject'] = requestParameters['subject'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/exports/{jobId}/messages`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the messages generated by the job.  Without any filter, all messages will be returned, but the response can optionally be filtered for the following severities. The severity parameter can be repeated to include multiple severities in one response.  - INFO - WARN - ERROR  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Get job messages
     */
    async getExportJobMessages(requestParameters: GetExportJobMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExportJobMessages200Response> {
        const response = await this.getExportJobMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the global settings that enforce the maximum expiry of SSH keys and restrictions on SSH key types.
     * Get global SSH key settings
     */
    async getGlobalSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshKeySettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the global settings that enforce the maximum expiry of SSH keys and restrictions on SSH key types.
     * Get global SSH key settings
     */
    async getGlobalSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshKeySettings> {
        const response = await this.getGlobalSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the recent rate limit history for the instance.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Get rate limit history
     */
    async getHistoryRaw(requestParameters: GetHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetHistory200Response>> {
        const queryParameters: any = {};

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/rate-limit/history`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the recent rate limit history for the instance.  The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Get rate limit history
     */
    async getHistory(requestParameters: GetHistoryRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetHistory200Response> {
        const response = await this.getHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a hook script by ID.
     * Get a hook script
     */
    async getHookScriptRaw(requestParameters: GetHookScriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestHookScript>> {
        if (requestParameters['scriptId'] == null) {
            throw new runtime.RequiredError(
                'scriptId',
                'Required parameter "scriptId" was null or undefined when calling getHookScript().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/hook-scripts/{scriptId}`.replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters['scriptId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a hook script by ID.
     * Get a hook script
     */
    async getHookScript(requestParameters: GetHookScriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestHookScript> {
        const response = await this.getHookScriptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the details, including the current status and progress, of the import job identified by the given ID.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Get import job status
     */
    async getImportJobRaw(requestParameters: GetImportJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestJob>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getImportJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/imports/{jobId}`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the details, including the current status and progress, of the import job identified by the given ID.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Get import job status
     */
    async getImportJob(requestParameters: GetImportJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestJob> {
        const response = await this.getImportJobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the messages generated by the job.  Without any filter, all messages will be returned, but the response can optionally be filtered for the following severities. The severity parameter can be repeated to include multiple severities in one response.  - INFO - WARN - ERROR  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Get import job messages
     */
    async getImportJobMessagesRaw(requestParameters: GetImportJobMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExportJobMessages200Response>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getImportJobMessages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['severity'] != null) {
            queryParameters['severity'] = requestParameters['severity'];
        }

        if (requestParameters['subject'] != null) {
            queryParameters['subject'] = requestParameters['subject'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/imports/{jobId}/messages`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the messages generated by the job.  Without any filter, all messages will be returned, but the response can optionally be filtered for the following severities. The severity parameter can be repeated to include multiple severities in one response.  - INFO - WARN - ERROR  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Get import job messages
     */
    async getImportJobMessages(requestParameters: GetImportJobMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExportJobMessages200Response> {
        const response = await this.getImportJobMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets information about the nodes that currently make up the stash cluster.  The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     * Get cluster node information
     */
    async getInformationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestClusterInformation>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/cluster`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets information about the nodes that currently make up the stash cluster.  The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     * Get cluster node information
     */
    async getInformation(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestClusterInformation> {
        const response = await this.getInformationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns a label.  The user needs to be authenticated to use this resource.
     * Get label
     */
    async getLabelRaw(requestParameters: GetLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestLabel>> {
        if (requestParameters['labelName'] == null) {
            throw new runtime.RequiredError(
                'labelName',
                'Required parameter "labelName" was null or undefined when calling getLabel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/labels/{labelName}`.replace(`{${"labelName"}}`, encodeURIComponent(String(requestParameters['labelName']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a label.  The user needs to be authenticated to use this resource.
     * Get label
     */
    async getLabel(requestParameters: GetLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestLabel> {
        const response = await this.getLabelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a page of labelables for a given label.  Only labelables that the authenticated user has view access to will be returned.
     * Get labelables for label
     */
    async getLabelablesRaw(requestParameters: GetLabelablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLabelables200Response>> {
        if (requestParameters['labelName'] == null) {
            throw new runtime.RequiredError(
                'labelName',
                'Required parameter "labelName" was null or undefined when calling getLabelables().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/labels/{labelName}/labeled`.replace(`{${"labelName"}}`, encodeURIComponent(String(requestParameters['labelName']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a page of labelables for a given label.  Only labelables that the authenticated user has view access to will be returned.
     * Get labelables for label
     */
    async getLabelables(requestParameters: GetLabelablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLabelables200Response> {
        const response = await this.getLabelablesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a paged response of all the labels in the system.  The user needs to be authenticated to use this resource.
     * Get all labels
     */
    async getLabelsRaw(requestParameters: GetLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLabels200Response>> {
        const queryParameters: any = {};

        if (requestParameters['prefix'] != null) {
            queryParameters['prefix'] = requestParameters['prefix'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/labels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a paged response of all the labels in the system.  The user needs to be authenticated to use this resource.
     * Get all labels
     */
    async getLabels(requestParameters: GetLabelsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLabels200Response> {
        const response = await this.getLabelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the current log level for a given logger.  The authenticated user must have <strong>SYS_ADMIN</strong> permission or higher to call this resource.
     * Get current log level
     */
    async getLevelRaw(requestParameters: GetLevelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestLogLevel>> {
        if (requestParameters['loggerName'] == null) {
            throw new runtime.RequiredError(
                'loggerName',
                'Required parameter "loggerName" was null or undefined when calling getLevel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/logs/logger/{loggerName}`.replace(`{${"loggerName"}}`, encodeURIComponent(String(requestParameters['loggerName']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the current log level for a given logger.  The authenticated user must have <strong>SYS_ADMIN</strong> permission or higher to call this resource.
     * Get current log level
     */
    async getLevel(requestParameters: GetLevelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestLogLevel> {
        const response = await this.getLevelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the current mail configuration.   The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     * Get mail configuration
     */
    async getMailConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMailConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/mail-server`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the current mail configuration.   The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     * Get mail configuration
     */
    async getMailConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMailConfiguration> {
        const response = await this.getMailConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the details, including the current status and progress, of the job identified by the given ID.  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get Mesh migration job details
     */
    async getMeshMigrationJobRaw(requestParameters: GetMeshMigrationJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getMeshMigrationJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/mesh/{jobId}`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Gets the details, including the current status and progress, of the job identified by the given ID.  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get Mesh migration job details
     */
    async getMeshMigrationJob(requestParameters: GetMeshMigrationJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getMeshMigrationJobRaw(requestParameters, initOverrides);
    }

    /**
     * Gets the messages generated by the job.   Without any filter, all messages will be returned, but the response can optionally be filtered for the following severities. The severity parameter can be repeated to include multiple severities in one response.        - INFO      - WARN      - ERROR   The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get Mesh migration job messages
     */
    async getMeshMigrationJobMessagesRaw(requestParameters: GetMeshMigrationJobMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExportJobMessages200Response>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getMeshMigrationJobMessages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['severity'] != null) {
            queryParameters['severity'] = requestParameters['severity'];
        }

        if (requestParameters['subject'] != null) {
            queryParameters['subject'] = requestParameters['subject'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/mesh/{jobId}/messages`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the messages generated by the job.   Without any filter, all messages will be returned, but the response can optionally be filtered for the following severities. The severity parameter can be repeated to include multiple severities in one response.        - INFO      - WARN      - ERROR   The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get Mesh migration job messages
     */
    async getMeshMigrationJobMessages(requestParameters: GetMeshMigrationJobMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExportJobMessages200Response> {
        const response = await this.getMeshMigrationJobMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the summary, including the queue status and progress, of a Mesh migration job.   The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get Mesh migration job summary
     */
    async getMeshMigrationJobSummaryRaw(requestParameters: GetMeshMigrationJobSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMeshMigrationSummary>> {
        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getMeshMigrationJobSummary().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/mesh/{jobId}/summary`.replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the summary, including the queue status and progress, of a Mesh migration job.   The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Get Mesh migration job summary
     */
    async getMeshMigrationJobSummary(requestParameters: GetMeshMigrationJobSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMeshMigrationSummary> {
        const response = await this.getMeshMigrationJobSummaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the registered Mesh node that matches the supplied ID.  The authenticated user must have **SYS_ADMIN** permission.
     * Get Mesh node
     */
    async getRegisteredMeshNodeByIdRaw(requestParameters: GetRegisteredMeshNodeByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMeshNode>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRegisteredMeshNodeById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/nodes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the registered Mesh node that matches the supplied ID.  The authenticated user must have **SYS_ADMIN** permission.
     * Get Mesh node
     */
    async getRegisteredMeshNodeById(requestParameters: GetRegisteredMeshNodeByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMeshNode> {
        const response = await this.getRegisteredMeshNodeByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the repository archive policy for the instance.  The user must be authenticated to access this resource.
     * Get repository archive policy
     */
    async getRepositoryArchivePolicyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryPolicy>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/policies/latest/admin/repos/archive`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the repository archive policy for the instance.  The user must be authenticated to access this resource.
     * Get repository archive policy
     */
    async getRepositoryArchivePolicy(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryPolicy> {
        const response = await this.getRepositoryArchivePolicyRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the repository delete policy for the instance.  The user must be authenticated to access this resource.
     * Get repository delete policy
     */
    async getRepositoryDeletePolicyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryPolicy>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/policies/latest/admin/repos/delete`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the repository delete policy for the instance.  The user must be authenticated to access this resource.
     * Get repository delete policy
     */
    async getRepositoryDeletePolicy(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryPolicy> {
        const response = await this.getRepositoryDeletePolicyRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the current log level for the root logger.  The authenticated user must have <strong>SYS_ADMIN</strong> permission or higher to call this resource.
     * Get root log level
     */
    async getRootLevelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestLogLevel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/logs/rootLogger`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the current log level for the root logger.  The authenticated user must have <strong>SYS_ADMIN</strong> permission or higher to call this resource.
     * Get root log level
     */
    async getRootLevel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestLogLevel> {
        const response = await this.getRootLevelRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the server email address
     * Get server mail address
     */
    async getSenderAddressRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/mail-server/sender-address`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the server email address
     * Get server mail address
     */
    async getSenderAddress(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getSenderAddressRaw(initOverrides);
    }

    /**
     * Returns whether debug logging and profiling are enabled.  The authenticated user must have <strong>SYS_ADMIN</strong> permission to call this resource.
     * Get debug logging and profiling
     */
    async getSettings2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestLoggingSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/logs/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns whether debug logging and profiling are enabled.  The authenticated user must have <strong>SYS_ADMIN</strong> permission to call this resource.
     * Get debug logging and profiling
     */
    async getSettings2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestLoggingSettings> {
        const response = await this.getSettings2Raw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the rate limit settings for the instance.  The user must be authenticated to call this resource.
     * Get rate limit settings
     */
    async getSettings3Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRateLimitSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/rate-limit/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the rate limit settings for the instance.  The user must be authenticated to call this resource.
     * Get rate limit settings
     */
    async getSettings3(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRateLimitSettings> {
        const response = await this.getSettings3Raw(initOverrides);
        return await response.value();
    }

    /**
     * Get the support zip for the Mesh node that matches the specified ID.  The authenticated user must have **SYS_ADMIN** permission.
     * Get support zip for node
     */
    async getSupportZipRaw(requestParameters: GetSupportZipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getSupportZip().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/support-zips/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get the support zip for the Mesh node that matches the specified ID.  The authenticated user must have **SYS_ADMIN** permission.
     * Get support zip for node
     */
    async getSupportZip(requestParameters: GetSupportZipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getSupportZipRaw(requestParameters, initOverrides);
    }

    /**
     * Get the support zips for all the Mesh nodes.  The authenticated user must have **SYS_ADMIN** permission.
     * Get support zips for all Mesh nodes
     */
    async getSupportZipsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/support-zips`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get the support zips for all the Mesh nodes.  The authenticated user must have **SYS_ADMIN** permission.
     * Get support zips for all Mesh nodes
     */
    async getSupportZips(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getSupportZipsRaw(initOverrides);
    }

    /**
     * Retrieves a list of all supported SSH key algorithms and lengths.
     * Get supported SSH key algorithms and lengths
     */
    async getSupportedKeyTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/supported-key-types`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves a list of all supported SSH key algorithms and lengths.
     * Get supported SSH key algorithms and lengths
     */
    async getSupportedKeyTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getSupportedKeyTypesRaw(initOverrides);
    }

    /**
     * Retrieve the user matching the supplied <strong>userSlug</strong>.
     * Get user
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestApplicationUser>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling getUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the user matching the supplied <strong>userSlug</strong>.
     * Get user
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestApplicationUser> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a map of user setting key values for a specific user identified by the user slug.
     * Get user settings
     */
    async getUserSettingsRaw(requestParameters: GetUserSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleSettingsMap>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling getUserSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/users/{userSlug}/settings`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a map of user setting key values for a specific user identified by the user slug.
     * Get user settings
     */
    async getUserSettings(requestParameters: GetUserSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleSettingsMap> {
        const response = await this.getUserSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of users, optionally run through provided filters.   Only authenticated users may call this resource. ### Permission Filters   The following three sub-sections list parameters supported for permission filters (where <code>[root]</code> is the root permission filter name, e.g. <code>permission</code>, <code>permission.1</code> etc.) depending on the permission resource. The system determines which filter to apply (Global, Project or Repository permission) based on the `[root]` permission value. E.g. <code>ADMIN</code> is a global permission, <code>PROJECT_ADMIN</code> is a project permission and <code>REPO_ADMIN</code> is a repository permission. Note that the parameters for a given resource will be looked up in the order as they are listed below, that is e.g. for a project resource, if both <code>projectId</code> and <code>projectKey</code> are provided, the system will use <code>projectId</code> for the lookup. <h4>Global permissions</h4>   The permission value under <code>[root]</code> is the only required and recognized parameter, as global permissions do not apply to a specific resource.   Example valid filter: <code>permission=ADMIN</code>. <h4>Project permissions</h4>   - <code>[root]</code>- specifies the project permission - <code>[root].projectId</code> - specifies the project ID to lookup the project by - <code>[root].projectKey</code> - specifies the project key to lookup the project by   Example valid filter: <code>permission.1=PROJECT_ADMIN&amp;permission.1.projectKey=TEST_PROJECT</code>. #### Repository permissions   - <code>[root]</code>- specifies the repository permission - <code>[root].projectId</code> - specifies the repository ID to lookup the repository by - <code>[root].projectKey</code> and <code>[root].repositorySlug</code>- specifies the project key and     repository slug to lookup the repository by; both values <i>need to</i> be provided for this look up to be     triggered   Example valid filter: <code>permission.2=REPO_ADMIN&amp;permission.2.projectKey=TEST_PROJECT&amp;permission.2.repositorySlug=test_repo</code>.
     * Get all users
     */
    async getUsers2Raw(requestParameters: GetUsers2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestApplicationUser>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['permissionN'] != null) {
            queryParameters['permission.N'] = requestParameters['permissionN'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['group'] != null) {
            queryParameters['group'] = requestParameters['group'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of users, optionally run through provided filters.   Only authenticated users may call this resource. ### Permission Filters   The following three sub-sections list parameters supported for permission filters (where <code>[root]</code> is the root permission filter name, e.g. <code>permission</code>, <code>permission.1</code> etc.) depending on the permission resource. The system determines which filter to apply (Global, Project or Repository permission) based on the `[root]` permission value. E.g. <code>ADMIN</code> is a global permission, <code>PROJECT_ADMIN</code> is a project permission and <code>REPO_ADMIN</code> is a repository permission. Note that the parameters for a given resource will be looked up in the order as they are listed below, that is e.g. for a project resource, if both <code>projectId</code> and <code>projectKey</code> are provided, the system will use <code>projectId</code> for the lookup. <h4>Global permissions</h4>   The permission value under <code>[root]</code> is the only required and recognized parameter, as global permissions do not apply to a specific resource.   Example valid filter: <code>permission=ADMIN</code>. <h4>Project permissions</h4>   - <code>[root]</code>- specifies the project permission - <code>[root].projectId</code> - specifies the project ID to lookup the project by - <code>[root].projectKey</code> - specifies the project key to lookup the project by   Example valid filter: <code>permission.1=PROJECT_ADMIN&amp;permission.1.projectKey=TEST_PROJECT</code>. #### Repository permissions   - <code>[root]</code>- specifies the repository permission - <code>[root].projectId</code> - specifies the repository ID to lookup the repository by - <code>[root].projectKey</code> and <code>[root].repositorySlug</code>- specifies the project key and     repository slug to lookup the repository by; both values <i>need to</i> be provided for this look up to be     triggered   Example valid filter: <code>permission.2=REPO_ADMIN&amp;permission.2.projectKey=TEST_PROJECT&amp;permission.2.repositorySlug=test_repo</code>.
     * Get all users
     */
    async getUsers2(requestParameters: GetUsers2Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestApplicationUser> {
        const response = await this.getUsers2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enumerates the projects and repositories that would be exported for a given export request.  All affected repositories will be enumerated explicitly, and while projects are listed as individual items in responses from this endpoint, their presence does not imply that all their repositories are included.  While this endpoint can be used to verify that all selectors in the request apply as intended, it should be noted that a subsequent, actual export might contain a different set of repositories, as they might have been added or deleted in the meantime.  Note that the overall response from this endpoint can become very large when a lot of repositories end up in the selection. This is why the server is streaming the response while it is being generated (as opposed to creating it in memory and then sending it all at once) and it can be consumed in a streaming way, too.  Also, due to the potential size of the response, projects and repositories are listed with fewer details than in other REST responses.  For a more detailed description of selectors, see the endpoint documentation for starting an export.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Preview export
     */
    async previewExportRaw(requestParameters: PreviewExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestScopesExample>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/migration/exports/preview`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restExportRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enumerates the projects and repositories that would be exported for a given export request.  All affected repositories will be enumerated explicitly, and while projects are listed as individual items in responses from this endpoint, their presence does not imply that all their repositories are included.  While this endpoint can be used to verify that all selectors in the request apply as intended, it should be noted that a subsequent, actual export might contain a different set of repositories, as they might have been added or deleted in the meantime.  Note that the overall response from this endpoint can become very large when a lot of repositories end up in the selection. This is why the server is streaming the response while it is being generated (as opposed to creating it in memory and then sending it all at once) and it can be consumed in a streaming way, too.  Also, due to the potential size of the response, projects and repositories are listed with fewer details than in other REST responses.  For a more detailed description of selectors, see the endpoint documentation for starting an export.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Preview export
     */
    async previewExport(requestParameters: PreviewExportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestScopesExample> {
        const response = await this.previewExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enumerates the projects and repositories that would be migrated for a given request.  All affected repositories will be enumerated explicitly, and while projects are listed as individual items in responses from this endpoint, their presence does not imply that all their repositories are included.  While this endpoint can be used to verify that all selectors in the request apply as intended, it should be noted that a subsequent, actual export might contain a different set of repositories, as they might have been added or deleted in the meantime.  Note that the overall response from this endpoint can become very large when a lot of repositories end up in the selection. This is why the server is streaming the response while it is being generated (as opposed to creating it in memory and then sending it all at once) and it can be consumed in a streaming way, too.  Also, due to the potential size of the response, projects and repositories are listed with fewer details than in other REST responses.  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Preview Mesh migration
     */
    async previewMeshMigrationRaw(requestParameters: PreviewMeshMigrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExamplePreviewMigration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/migration/mesh/preview`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restMeshMigrationRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enumerates the projects and repositories that would be migrated for a given request.  All affected repositories will be enumerated explicitly, and while projects are listed as individual items in responses from this endpoint, their presence does not imply that all their repositories are included.  While this endpoint can be used to verify that all selectors in the request apply as intended, it should be noted that a subsequent, actual export might contain a different set of repositories, as they might have been added or deleted in the meantime.  Note that the overall response from this endpoint can become very large when a lot of repositories end up in the selection. This is why the server is streaming the response while it is being generated (as opposed to creating it in memory and then sending it all at once) and it can be consumed in a streaming way, too.  Also, due to the potential size of the response, projects and repositories are listed with fewer details than in other REST responses.  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Preview Mesh migration
     */
    async previewMeshMigration(requestParameters: PreviewMeshMigrationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExamplePreviewMigration> {
        const response = await this.previewMeshMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the hook script content.  This endpoint requires **SYS_ADMIN** permission.
     * Get hook script content
     */
    async readRaw(requestParameters: ReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['scriptId'] == null) {
            throw new runtime.RequiredError(
                'scriptId',
                'Required parameter "scriptId" was null or undefined when calling read().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/hook-scripts/{scriptId}/content`.replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters['scriptId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the hook script content.  This endpoint requires **SYS_ADMIN** permission.
     * Get hook script content
     */
    async read(requestParameters: ReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.readRaw(requestParameters, initOverrides);
    }

    /**
     * Register a new Mesh node.  The authenticated user must have **SYS_ADMIN** permission.
     * Register new Mesh node
     */
    async registerNewMeshNodeRaw(requestParameters: RegisterNewMeshNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMeshNode>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/nodes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restMeshNode'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Register a new Mesh node.  The authenticated user must have **SYS_ADMIN** permission.
     * Register new Mesh node
     */
    async registerNewMeshNode(requestParameters: RegisterNewMeshNodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMeshNode> {
        const response = await this.registerNewMeshNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Searches for repositories in the system matching the specified criteria and enriches their MeshMigrationQueueState migration state if a migration is currently in progress.   The currently active migration can optionally be specified by passing a migrationId, if known. If this isn\'t passed, an attempt is made to locate the active migration and its ID is used.   If a migration is currently active, only repositories that are a part of the migration are filtered and returned. Otherwise, all repositories in the systems are filtered and returned.   Filtering by state is ignored when no migration is currently in progress. In such a case, results are not enriched with their MeshMigrationQueueState migration state.   The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Find repositories by Mesh migration state
     */
    async searchMeshMigrationReposRaw(requestParameters: SearchMeshMigrationReposRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchMeshMigrationRepos200Response>> {
        const queryParameters: any = {};

        if (requestParameters['migrationId'] != null) {
            queryParameters['migrationId'] = requestParameters['migrationId'];
        }

        if (requestParameters['projectKey'] != null) {
            queryParameters['projectKey'] = requestParameters['projectKey'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['remote'] != null) {
            queryParameters['remote'] = requestParameters['remote'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/migration/mesh/repos`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Searches for repositories in the system matching the specified criteria and enriches their MeshMigrationQueueState migration state if a migration is currently in progress.   The currently active migration can optionally be specified by passing a migrationId, if known. If this isn\'t passed, an attempt is made to locate the active migration and its ID is used.   If a migration is currently active, only repositories that are a part of the migration are filtered and returned. Otherwise, all repositories in the systems are filtered and returned.   Filtering by state is ignored when no migration is currently in progress. In such a case, results are not enriched with their MeshMigrationQueueState migration state.   The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Find repositories by Mesh migration state
     */
    async searchMeshMigrationRepos(requestParameters: SearchMeshMigrationReposRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchMeshMigrationRepos200Response> {
        const response = await this.searchMeshMigrationReposRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the given rate limit settings for the given users.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Set rate limit settings for users
     */
    async set2Raw(requestParameters: Set2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserRateLimitSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/rate-limit/settings/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restBulkUserRateLimitSettingsUpdateRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the given rate limit settings for the given users.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Set rate limit settings for users
     */
    async set2(requestParameters: Set2Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserRateLimitSettings> {
        const response = await this.set2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the given rate limit settings for the given user.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Set rate limit settings for user
     */
    async set3Raw(requestParameters: Set3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserRateLimitSettings>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling set3().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/rate-limit/settings/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restUserRateLimitSettingsUpdateRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the given rate limit settings for the given user.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Set rate limit settings for user
     */
    async set3(requestParameters: Set3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserRateLimitSettings> {
        const response = await this.set3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the announcement banner with the provided JSON. Only users authenticated as Admins may call this resource
     * Update/Set announcement banner
     */
    async setBannerRaw(requestParameters: SetBannerOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/banner`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['setBannerRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Sets the announcement banner with the provided JSON. Only users authenticated as Admins may call this resource
     * Update/Set announcement banner
     */
    async setBanner(requestParameters: SetBannerOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setBannerRaw(requestParameters, initOverrides);
    }

    /**
     * Configures the global default branch, which is used when creating new repositories if an explicit default branch is not specified.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Update/Set default branch
     */
    async setDefaultBranchRaw(requestParameters: SetDefaultBranchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/default-branch`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['setDefaultBranchRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Configures the global default branch, which is used when creating new repositories if an explicit default branch is not specified.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Update/Set default branch
     */
    async setDefaultBranch(requestParameters: SetDefaultBranchOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setDefaultBranchRaw(requestParameters, initOverrides);
    }

    /**
     * Set the current log level for a given logger.  The authenticated user must have <strong>SYS_ADMIN</strong> permission or higher to call this resource.
     * Set log level
     */
    async setLevelRaw(requestParameters: SetLevelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['levelName'] == null) {
            throw new runtime.RequiredError(
                'levelName',
                'Required parameter "levelName" was null or undefined when calling setLevel().'
            );
        }

        if (requestParameters['loggerName'] == null) {
            throw new runtime.RequiredError(
                'loggerName',
                'Required parameter "loggerName" was null or undefined when calling setLevel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/logs/logger/{loggerName}/{levelName}`.replace(`{${"levelName"}}`, encodeURIComponent(String(requestParameters['levelName']))).replace(`{${"loggerName"}}`, encodeURIComponent(String(requestParameters['loggerName']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set the current log level for a given logger.  The authenticated user must have <strong>SYS_ADMIN</strong> permission or higher to call this resource.
     * Set log level
     */
    async setLevel(requestParameters: SetLevelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setLevelRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the mail configuration.   The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     * Update mail configuration
     */
    async setMailConfigRaw(requestParameters: SetMailConfigOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMailConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/mail-server`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['setMailConfigRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the mail configuration.   The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     * Update mail configuration
     */
    async setMailConfig(requestParameters: SetMailConfigOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMailConfiguration> {
        const response = await this.setMailConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the repository archive policy for the instance.  The authenticated user must have <b>SYS_ADMIN</b> permission.
     * Update repository archive policy
     */
    async setRepositoryArchivePolicyRaw(requestParameters: SetRepositoryArchivePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryPolicy>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/policies/latest/admin/repos/archive`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepositoryPolicy'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the repository archive policy for the instance.  The authenticated user must have <b>SYS_ADMIN</b> permission.
     * Update repository archive policy
     */
    async setRepositoryArchivePolicy(requestParameters: SetRepositoryArchivePolicyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryPolicy> {
        const response = await this.setRepositoryArchivePolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the repository delete policy for the instance.  The authenticated user must have <b>SYS_ADMIN</b> permission.
     * Update the repository delete policy
     */
    async setRepositoryDeletePolicyRaw(requestParameters: SetRepositoryDeletePolicyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryPolicy>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/policies/latest/admin/repos/delete`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRepositoryPolicy'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the repository delete policy for the instance.  The authenticated user must have <b>SYS_ADMIN</b> permission.
     * Update the repository delete policy
     */
    async setRepositoryDeletePolicy(requestParameters: SetRepositoryDeletePolicyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryPolicy> {
        const response = await this.setRepositoryDeletePolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set the current log level for the root logger.  The authenticated user must have <strong>SYS_ADMIN</strong> permission or higher to call this resource.
     * Set root log level
     */
    async setRootLevelRaw(requestParameters: SetRootLevelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['levelName'] == null) {
            throw new runtime.RequiredError(
                'levelName',
                'Required parameter "levelName" was null or undefined when calling setRootLevel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/logs/rootLogger/{levelName}`.replace(`{${"levelName"}}`, encodeURIComponent(String(requestParameters['levelName']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set the current log level for the root logger.  The authenticated user must have <strong>SYS_ADMIN</strong> permission or higher to call this resource.
     * Set root log level
     */
    async setRootLevel(requestParameters: SetRootLevelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setRootLevelRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the server email address   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Update server mail address
     */
    async setSenderAddressRaw(requestParameters: SetSenderAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/mail-server/sender-address`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the server email address   The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * Update server mail address
     */
    async setSenderAddress(requestParameters: SetSenderAddressRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setSenderAddressRaw(requestParameters, initOverrides);
    }

    /**
     * Set whether debug logging and profiling should be enabled. This setting persists on restarts.  The authenticated user must have <strong>SYS_ADMIN</strong> permission to call this resource.
     * Set debug logging and profiling
     */
    async setSettings2Raw(requestParameters: SetSettings2OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestLoggingSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/logs/settings`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['setSettings2Request'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Set whether debug logging and profiling should be enabled. This setting persists on restarts.  The authenticated user must have <strong>SYS_ADMIN</strong> permission to call this resource.
     * Set debug logging and profiling
     */
    async setSettings2(requestParameters: SetSettings2OperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestLoggingSettings> {
        const response = await this.setSettings2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the rate limit settings for the instance.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Set rate limit
     */
    async setSettings3Raw(requestParameters: SetSettings3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRateLimitSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/rate-limit/settings`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restRateLimitSettings'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the rate limit settings for the instance.  The authenticated user must have <strong>ADMIN</strong> permission to call this resource.
     * Set rate limit
     */
    async setSettings3(requestParameters: SetSettings3Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRateLimitSettings> {
        const response = await this.setSettings3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts a background job that exports the selected repositories.  Only 2 concurrent exports are supported _per cluster node_. If a request ends up on a node that is already running that many export jobs, the request will be rejected and an error returned.  The response includes a description of the job that has been started, and its ID can be used to query these details again, including the current progress, warnings and errors that occurred while processing the job, and to interrupt and cancel the execution of this job.  The request to start an export is similar to the one for previewing an export. Additionally, it accepts an optional parameter, `exportLocation`, which can be used to specify a _relative_ path within `data/migration/export` in the shared home directory. No locations outside of that directory will be accepted for exports.  There are essentially three ways to select repositories for export. Regardless of which you use, a few general rules apply:  - You can supply a list of selectors. The selection will be additive. - Repositories that are selected more than once due to overlapping selectors will be de-duplicated and effectively exported only once. - For every selected repository, its full fork hierarchy will be considered selected, even if parts of that hierarchy would otherwise not be matched by the provided selectors. For example, when you explicitly select a single repository only, but that repository is a fork, then its origin will be exported (and eventually imported), too.  Now, a single repository can be selected like this:  ```    {       \"projectKey\": \"PRJ\",       \"slug\": \"my-repo\" }  ```  Second, all repositories in a specific project can be selected like this:  ```    {       \"projectKey\": \"PRJ\",       \"slug\": *\" }  ```  And third, all projects and repositories in the system would be selected like this:  ```    {       \"projectKey\": \"*\",       \"slug\": *\" }  ```  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Start export job
     */
    async startExportRaw(requestParameters: StartExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestJob>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/migration/exports`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restExportRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts a background job that exports the selected repositories.  Only 2 concurrent exports are supported _per cluster node_. If a request ends up on a node that is already running that many export jobs, the request will be rejected and an error returned.  The response includes a description of the job that has been started, and its ID can be used to query these details again, including the current progress, warnings and errors that occurred while processing the job, and to interrupt and cancel the execution of this job.  The request to start an export is similar to the one for previewing an export. Additionally, it accepts an optional parameter, `exportLocation`, which can be used to specify a _relative_ path within `data/migration/export` in the shared home directory. No locations outside of that directory will be accepted for exports.  There are essentially three ways to select repositories for export. Regardless of which you use, a few general rules apply:  - You can supply a list of selectors. The selection will be additive. - Repositories that are selected more than once due to overlapping selectors will be de-duplicated and effectively exported only once. - For every selected repository, its full fork hierarchy will be considered selected, even if parts of that hierarchy would otherwise not be matched by the provided selectors. For example, when you explicitly select a single repository only, but that repository is a fork, then its origin will be exported (and eventually imported), too.  Now, a single repository can be selected like this:  ```    {       \"projectKey\": \"PRJ\",       \"slug\": \"my-repo\" }  ```  Second, all repositories in a specific project can be selected like this:  ```    {       \"projectKey\": \"PRJ\",       \"slug\": *\" }  ```  And third, all projects and repositories in the system would be selected like this:  ```    {       \"projectKey\": \"*\",       \"slug\": *\" }  ```  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Start export job
     */
    async startExport(requestParameters: StartExportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestJob> {
        const response = await this.startExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts a background job that imports the specified archive.  Only 1 import at a time is supported _per cluster_. If another request is made while an import is already running, the request will be rejected and an error returned.  The path in the request must point to a valid archive file. The file must be located within the `data/migration/import` directory in the shared home directory.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Start import job
     */
    async startImportRaw(requestParameters: StartImportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestJob>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/migration/imports`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restImportRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts a background job that imports the specified archive.  Only 1 import at a time is supported _per cluster_. If another request is made while an import is already running, the request will be rejected and an error returned.  The path in the request must point to a valid archive file. The file must be located within the `data/migration/import` directory in the shared home directory.  The authenticated user must have **ADMIN** permission or higher to call this resource.
     * Start import job
     */
    async startImport(requestParameters: StartImportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestJob> {
        const response = await this.startImportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starts a background job that migrates selected projects/repositories to Mesh.   Only 1 job is supported _per cluster_.  The response includes a description of the job that has been started, and its ID can be used to query these details again, including the current progress, and to interrupt and cancel the execution of this job.   The request to start a migration is similar to the one for previewing a migration.   There are essentially three ways to select repositories for migration. Regardless of which you use, a few general rules apply:       - You can supply a list of repository IDs and project IDs. The selection will be additive. All repositories     in the system are migrated if both lists are empty.     - Repositories that are selected more than once due to overlapping IDs will be de-duplicated and     effectively migrated only once.     - For every selected repository, its full fork hierarchy will be considered selected, even if parts of that     hierarchy would otherwise not be matched by the provided IDs. For example, when you explicitly     select a single repository only, but that repository is a fork, then its origin will be migrated too.   Now, a single repository can be selected like this:   ```       {      \"repositoryIds\": [1]      } ```  Multiple repositories can be selected like this:    ```       {      \"repositoryIds\": [1, 2]      } ```  Second, all repositories in a specific project can be selected like this:    ```       {      \"projectIds\": [1]      } ```  And third, all projects and repositories in the system would be selected like this:    ```       {      \"projectIds\": [],      \"repositoryIds\": []      } ```  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Start Mesh migration job
     */
    async startMeshMigrationRaw(requestParameters: StartMeshMigrationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestJob>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/migration/mesh`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['startMeshMigrationRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Starts a background job that migrates selected projects/repositories to Mesh.   Only 1 job is supported _per cluster_.  The response includes a description of the job that has been started, and its ID can be used to query these details again, including the current progress, and to interrupt and cancel the execution of this job.   The request to start a migration is similar to the one for previewing a migration.   There are essentially three ways to select repositories for migration. Regardless of which you use, a few general rules apply:       - You can supply a list of repository IDs and project IDs. The selection will be additive. All repositories     in the system are migrated if both lists are empty.     - Repositories that are selected more than once due to overlapping IDs will be de-duplicated and     effectively migrated only once.     - For every selected repository, its full fork hierarchy will be considered selected, even if parts of that     hierarchy would otherwise not be matched by the provided IDs. For example, when you explicitly     select a single repository only, but that repository is a fork, then its origin will be migrated too.   Now, a single repository can be selected like this:   ```       {      \"repositoryIds\": [1]      } ```  Multiple repositories can be selected like this:    ```       {      \"repositoryIds\": [1, 2]      } ```  Second, all repositories in a specific project can be selected like this:    ```       {      \"projectIds\": [1]      } ```  And third, all projects and repositories in the system would be selected like this:    ```       {      \"projectIds\": [],      \"repositoryIds\": []      } ```  The authenticated user must have **SYS_ADMIN** permission to call this resource.
     * Start Mesh migration job
     */
    async startMeshMigration(requestParameters: StartMeshMigrationOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestJob> {
        const response = await this.startMeshMigrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the global settings that enforces the maximum expiry of SSH keys and restrictions on SSH key types.
     * Update global SSH key settings
     */
    async updateGlobalSettingsRaw(requestParameters: UpdateGlobalSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSshKeySettings'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the global settings that enforces the maximum expiry of SSH keys and restrictions on SSH key types.
     * Update global SSH key settings
     */
    async updateGlobalSettings(requestParameters: UpdateGlobalSettingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateGlobalSettingsRaw(requestParameters, initOverrides);
    }

    /**
     * Updates a hook script.  This endpoint requires **SYS_ADMIN** permission.
     * Update a hook script
     */
    async updateHookScriptRaw(requestParameters: UpdateHookScriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestHookScript>> {
        if (requestParameters['scriptId'] == null) {
            throw new runtime.RequiredError(
                'scriptId',
                'Required parameter "scriptId" was null or undefined when calling updateHookScript().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/hook-scripts/{scriptId}`.replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters['scriptId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['examplePutMultipartFormData'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates a hook script.  This endpoint requires **SYS_ADMIN** permission.
     * Update a hook script
     */
    async updateHookScript(requestParameters: UpdateHookScriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestHookScript> {
        const response = await this.updateHookScriptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Decodes the provided encoded license and sets it as the active license. If no license was provided, a 400 is returned. If the license cannot be decoded, or cannot be applied, a 409 is returned. Some possible reasons a license may not be applied include:   - It is for a different product - It is already expired   Otherwise, if the license is updated successfully, details for the new license are returned with a 200 response.  <b>Warning</b>: It is possible to downgrade the license during update, applying a license with a lower number of permitted users. If the number of currently-licensed users exceeds the limits of the new license, pushing will be disabled until the licensed user count is brought into compliance with the new license.  The authenticated user must have <b>SYS_ADMIN</b> permission. <b>ADMIN</b> users may <i>view</i> the current license details, but they may not <i>update</i> the license.
     * Update license
     */
    async updateLicenseRaw(requestParameters: UpdateLicenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBitbucketLicense>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/license`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restBitbucketLicense'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Decodes the provided encoded license and sets it as the active license. If no license was provided, a 400 is returned. If the license cannot be decoded, or cannot be applied, a 409 is returned. Some possible reasons a license may not be applied include:   - It is for a different product - It is already expired   Otherwise, if the license is updated successfully, details for the new license are returned with a 200 response.  <b>Warning</b>: It is possible to downgrade the license during update, applying a license with a lower number of permitted users. If the number of currently-licensed users exceeds the limits of the new license, pushing will be disabled until the licensed user count is brought into compliance with the new license.  The authenticated user must have <b>SYS_ADMIN</b> permission. <b>ADMIN</b> users may <i>view</i> the current license details, but they may not <i>update</i> the license.
     * Update license
     */
    async updateLicense(requestParameters: UpdateLicenseRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBitbucketLicense> {
        const response = await this.updateLicenseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a Mesh node.  The authenticated user must have **SYS_ADMIN** permission.
     * Update Mesh node
     */
    async updateMeshNodeRaw(requestParameters: UpdateMeshNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMeshNode>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateMeshNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/admin/git/mesh/nodes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restMeshNode'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update a Mesh node.  The authenticated user must have **SYS_ADMIN** permission.
     * Update Mesh node
     */
    async updateMeshNode(requestParameters: UpdateMeshNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMeshNode> {
        const response = await this.updateMeshNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the entries of a map of user setting key/values for a specific user identified by the user slug.
     * Update user settings
     */
    async updateSettingsRaw(requestParameters: UpdateSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling updateSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/users/{userSlug}/settings`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['exampleSettingsMap'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the entries of a map of user setting key/values for a specific user identified by the user slug.
     * Update user settings
     */
    async updateSettings(requestParameters: UpdateSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateSettingsRaw(requestParameters, initOverrides);
    }

    /**
     * Update the currently authenticated user\'s details. The update will always be applied to the currently authenticated user.
     * Update user details
     */
    async updateUserDetails1Raw(requestParameters: UpdateUserDetails1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestApplicationUser>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/users`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['userUpdateWithCredentials'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the currently authenticated user\'s details. The update will always be applied to the currently authenticated user.
     * Update user details
     */
    async updateUserDetails1(requestParameters: UpdateUserDetails1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestApplicationUser> {
        const response = await this.updateUserDetails1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the currently authenticated user\'s password.
     * Set password
     */
    async updateUserPassword1Raw(requestParameters: UpdateUserPassword1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/users/credentials`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['userPasswordUpdate'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the currently authenticated user\'s password.
     * Set password
     */
    async updateUserPassword1(requestParameters: UpdateUserPassword1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateUserPassword1Raw(requestParameters, initOverrides);
    }

    /**
     * Update the avatar for the user with the supplied <strong>slug</strong>.   This resource accepts POST multipart form data, containing a single image in a form-field named \'avatar\'.   There are configurable server limits on both the dimensions (1024x1024 pixels by default) and uploaded file size (1MB by default). Several different image formats are supported, but <strong>PNG</strong> and <strong>JPEG</strong> are preferred due to the file size limit.   This resource has Cross-Site Request Forgery (XSRF) protection. To allow the request to pass the XSRF check the caller needs to send an <code>X-Atlassian-Token</code> HTTP header with the value <code>no-check</code>.   An example <a href=\"http://curl.haxx.se/\">curl</a> request to upload an image name \'avatar.png\' would be: ``` curl -X POST -u username:password -H \"X-Atlassian-Token: no-check\" http://example.com/rest/api/latest/users/jdoe/avatar.png -F avatar=@avatar.png ```   Users are always allowed to update their own avatar. To update someone else\'s avatar the authenticated user must have global <strong>ADMIN</strong> permission, or global <strong>SYS_ADMIN</strong> permission to update a <strong>SYS_ADMIN</strong> user\'s avatar.
     * Update user avatar
     */
    async uploadAvatar1Raw(requestParameters: UploadAvatar1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling uploadAvatar1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAtlassianToken'] != null) {
            headerParameters['X-Atlassian-Token'] = String(requestParameters['xAtlassianToken']);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['avatar'] != null) {
            formParams.append('avatar', requestParameters['avatar'] as any);
        }

        const response = await this.request({
            path: `/api/latest/users/{userSlug}/avatar.png`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the avatar for the user with the supplied <strong>slug</strong>.   This resource accepts POST multipart form data, containing a single image in a form-field named \'avatar\'.   There are configurable server limits on both the dimensions (1024x1024 pixels by default) and uploaded file size (1MB by default). Several different image formats are supported, but <strong>PNG</strong> and <strong>JPEG</strong> are preferred due to the file size limit.   This resource has Cross-Site Request Forgery (XSRF) protection. To allow the request to pass the XSRF check the caller needs to send an <code>X-Atlassian-Token</code> HTTP header with the value <code>no-check</code>.   An example <a href=\"http://curl.haxx.se/\">curl</a> request to upload an image name \'avatar.png\' would be: ``` curl -X POST -u username:password -H \"X-Atlassian-Token: no-check\" http://example.com/rest/api/latest/users/jdoe/avatar.png -F avatar=@avatar.png ```   Users are always allowed to update their own avatar. To update someone else\'s avatar the authenticated user must have global <strong>ADMIN</strong> permission, or global <strong>SYS_ADMIN</strong> permission to update a <strong>SYS_ADMIN</strong> user\'s avatar.
     * Update user avatar
     */
    async uploadAvatar1(requestParameters: UploadAvatar1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uploadAvatar1Raw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const GetHistoryOrderEnum = {
    Newest: 'NEWEST',
    Frequency: 'FREQUENCY'
} as const;
export type GetHistoryOrderEnum = typeof GetHistoryOrderEnum[keyof typeof GetHistoryOrderEnum];
