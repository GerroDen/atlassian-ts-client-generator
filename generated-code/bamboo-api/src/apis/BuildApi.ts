/* tslint:disable */
/* eslint-disable */
/**
 * Bamboo
 * This is the reference document for the Atlassian Bamboo REST API. The REST API is for developers who want to:    - integrate Bamboo with other applications;   - create scripts that interact with Bamboo; or   - develop plugins that enhance the Bamboo UI, using REST to interact with the backend.    You can read more about developing Bamboo plugins in the [Bamboo Developer Documentation](https://developer.atlassian.com/bamboo/server/docs/latest/).
 *
 * The version of the OpenAPI document: 11.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DirectoryInformationResponse,
  RestArtifactDefinitions,
  RestBuildLabels,
  RestDockerPipelineConfiguration,
  RestErrorCollection,
  RestJiraIssue,
  RestPlan,
  RestPlanBranch,
  RestPlanLabel,
  RestPlans,
  RestVariable,
} from '../models/index';

export interface AddPlanLabelRequest {
    projectKey: string;
    buildKey: string;
    restPlanLabel: RestPlanLabel;
}

export interface AddPlanVariableRequest {
    projectKey: string;
    buildKey: string;
    restVariable: RestVariable;
}

export interface CreateNewBranchRequest {
    projectKey: string;
    buildKey: string;
    branchName: string;
    cleanupEnabled?: string;
    vcsBranch?: string;
    enabled?: string;
}

export interface DeletePlanRequest {
    projectKey: string;
    buildKey: string;
}

export interface DeletePlanVariableRequest {
    projectKey: string;
    variableName: string;
    buildKey: string;
}

export interface DisablePlanRequest {
    projectKey: string;
    buildKey: string;
}

export interface EditPlanVariableRequest {
    projectKey: string;
    variableName: string;
    buildKey: string;
    restVariable: RestVariable;
}

export interface EnablePlanRequest {
    projectKey: string;
    buildKey: string;
}

export interface EnableSpecsForBranchesRequest {
    projectKey: string;
    buildKey: string;
}

export interface ExportPlanSpecRequest {
    projectKey: string;
    buildKey: string;
    _package?: string;
    format?: ExportPlanSpecFormatEnum;
}

export interface GetAllPlanListRequest {
    expand?: string;
}

export interface GetDockerPipelineConfigurationRequest {
    jobKey: string;
}

export interface GetIssueDetailsRequest {
    projectKey: string;
    issueKey: string;
    buildKey: string;
}

export interface GetPlanRequest {
    projectKey: string;
    buildKey: string;
    expand?: string;
}

export interface GetPlanAliasRequest {
    projectKey: string;
    buildKey: string;
    expand?: string;
}

export interface GetPlanArtifactDefinitionRequest {
    projectKey: string;
    buildKey: string;
    maxResult?: number;
    startIndex?: number;
}

export interface GetPlanBranchRequest {
    projectKey: string;
    buildKey: string;
    branchName: string;
}

export interface GetPlanBranchesRequest {
    projectKey: string;
    buildKey: string;
    enabledOnly?: string;
    cloverEnabled?: string;
    my?: string;
    favourite?: string;
}

export interface GetPlanDirectoryRequest {
    planKey: string;
}

export interface GetPlanLabelsRequest {
    projectKey: string;
    buildKey: string;
}

export interface GetPlanVariableRequest {
    projectKey: string;
    variableName: string;
    buildKey: string;
}

export interface GetPlanVariablesRequest {
    projectKey: string;
    buildKey: string;
}

export interface GetVcsBranchesRequest {
    projectKey: string;
    buildKey: string;
    maxResult?: number;
    searchTerm?: string;
    startIndex?: number;
}

export interface MarkPlanFavouriteRequest {
    projectKey: string;
    buildKey: string;
}

export interface QuarantineTestRequest {
    projectKey: string;
    buildKey: string;
    testId: string;
}

export interface RemovePlanLabelRequest {
    projectKey: string;
    buildKey: string;
    labelName: string;
}

export interface SetDockerPipelineConfigurationRequest {
    jobKey: string;
    restDockerPipelineConfiguration: RestDockerPipelineConfiguration;
}

export interface UnleashTestRequest {
    projectKey: string;
    buildKey: string;
    testId: string;
}

export interface UnmarkPlanFavouriteRequest {
    projectKey: string;
    buildKey: string;
}

/**
 * 
 */
export class BuildApi extends runtime.BaseAPI {

    /**
     * Add new label to plan.
     */
    async addPlanLabelRaw(requestParameters: AddPlanLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addPlanLabel().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling addPlanLabel().'
            );
        }

        if (requestParameters['restPlanLabel'] == null) {
            throw new runtime.RequiredError(
                'restPlanLabel',
                'Required parameter "restPlanLabel" was null or undefined when calling addPlanLabel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/label`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restPlanLabel'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add new label to plan.
     */
    async addPlanLabel(requestParameters: AddPlanLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addPlanLabelRaw(requestParameters, initOverrides);
    }

    /**
     * Add a new plan variable.
     */
    async addPlanVariableRaw(requestParameters: AddPlanVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestVariable>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addPlanVariable().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling addPlanVariable().'
            );
        }

        if (requestParameters['restVariable'] == null) {
            throw new runtime.RequiredError(
                'restVariable',
                'Required parameter "restVariable" was null or undefined when calling addPlanVariable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/variables`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restVariable'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new plan variable.
     */
    async addPlanVariable(requestParameters: AddPlanVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestVariable> {
        const response = await this.addPlanVariableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create branch for a plan. You can use **vcsBranch** query param to define which vcsBranch should newly created branch use. If not specified it will not override vcsBranch from the plan.
     */
    async createNewBranchRaw(requestParameters: CreateNewBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPlanBranch>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createNewBranch().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling createNewBranch().'
            );
        }

        if (requestParameters['branchName'] == null) {
            throw new runtime.RequiredError(
                'branchName',
                'Required parameter "branchName" was null or undefined when calling createNewBranch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cleanupEnabled'] != null) {
            queryParameters['cleanupEnabled'] = requestParameters['cleanupEnabled'];
        }

        if (requestParameters['vcsBranch'] != null) {
            queryParameters['vcsBranch'] = requestParameters['vcsBranch'];
        }

        if (requestParameters['enabled'] != null) {
            queryParameters['enabled'] = requestParameters['enabled'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/branch/{branchName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))).replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters['branchName']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create branch for a plan. You can use **vcsBranch** query param to define which vcsBranch should newly created branch use. If not specified it will not override vcsBranch from the plan.
     */
    async createNewBranch(requestParameters: CreateNewBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPlanBranch> {
        const response = await this.createNewBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks plan for deletion. Plan will be deleted by a batch job.
     */
    async deletePlanRaw(requestParameters: DeletePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deletePlan().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling deletePlan().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Marks plan for deletion. Plan will be deleted by a batch job.
     */
    async deletePlan(requestParameters: DeletePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePlanRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the plan variable.
     */
    async deletePlanVariableRaw(requestParameters: DeletePlanVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deletePlanVariable().'
            );
        }

        if (requestParameters['variableName'] == null) {
            throw new runtime.RequiredError(
                'variableName',
                'Required parameter "variableName" was null or undefined when calling deletePlanVariable().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling deletePlanVariable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/variables/{variableName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"variableName"}}`, encodeURIComponent(String(requestParameters['variableName']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the plan variable.
     */
    async deletePlanVariable(requestParameters: DeletePlanVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePlanVariableRaw(requestParameters, initOverrides);
    }

    /**
     * Disable plan.
     */
    async disablePlanRaw(requestParameters: DisablePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling disablePlan().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling disablePlan().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/enable`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disable plan.
     */
    async disablePlan(requestParameters: DisablePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.disablePlanRaw(requestParameters, initOverrides);
    }

    /**
     * Update the plan variable.
     */
    async editPlanVariableRaw(requestParameters: EditPlanVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestVariable>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling editPlanVariable().'
            );
        }

        if (requestParameters['variableName'] == null) {
            throw new runtime.RequiredError(
                'variableName',
                'Required parameter "variableName" was null or undefined when calling editPlanVariable().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling editPlanVariable().'
            );
        }

        if (requestParameters['restVariable'] == null) {
            throw new runtime.RequiredError(
                'restVariable',
                'Required parameter "restVariable" was null or undefined when calling editPlanVariable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/variables/{variableName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"variableName"}}`, encodeURIComponent(String(requestParameters['variableName']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restVariable'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the plan variable.
     */
    async editPlanVariable(requestParameters: EditPlanVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestVariable> {
        const response = await this.editPlanVariableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable plan.
     */
    async enablePlanRaw(requestParameters: EnablePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling enablePlan().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling enablePlan().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/enable`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable plan.
     */
    async enablePlan(requestParameters: EnablePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enablePlanRaw(requestParameters, initOverrides);
    }

    /**
     * Enable specs scanning for all branches.
     */
    async enableSpecsForBranchesRaw(requestParameters: EnableSpecsForBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling enableSpecsForBranches().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling enableSpecsForBranches().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/branch/enableSpecsForBranches`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable specs scanning for all branches.
     */
    async enableSpecsForBranches(requestParameters: EnableSpecsForBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableSpecsForBranchesRaw(requestParameters, initOverrides);
    }

    /**
     * Export plan as Bamboo Specs code.
     */
    async exportPlanSpecRaw(requestParameters: ExportPlanSpecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling exportPlanSpec().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling exportPlanSpec().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['_package'] != null) {
            queryParameters['package'] = requestParameters['_package'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/specs`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Export plan as Bamboo Specs code.
     */
    async exportPlanSpec(requestParameters: ExportPlanSpecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.exportPlanSpecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all plans that user has READ permission for and allowed to see.  Possible expand parameters:  - <tt>plans</tt> - list of plans  - <tt>plans.plan</tt> - list of plans with plan details  - <tt>plans.plan.actions</tt> - list of plans with actions details
     */
    async getAllPlanListRaw(requestParameters: GetAllPlanListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPlans>> {
        const queryParameters: any = {};

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * List all plans that user has READ permission for and allowed to see.  Possible expand parameters:  - <tt>plans</tt> - list of plans  - <tt>plans.plan</tt> - list of plans with plan details  - <tt>plans.plan.actions</tt> - list of plans with actions details
     */
    async getAllPlanList(requestParameters: GetAllPlanListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPlans> {
        const response = await this.getAllPlanListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves Docker configuration for given job.
     */
    async getDockerPipelineConfigurationRaw(requestParameters: GetDockerPipelineConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDockerPipelineConfiguration>> {
        if (requestParameters['jobKey'] == null) {
            throw new runtime.RequiredError(
                'jobKey',
                'Required parameter "jobKey" was null or undefined when calling getDockerPipelineConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/job/{jobKey}/docker`.replace(`{${"jobKey"}}`, encodeURIComponent(String(requestParameters['jobKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves Docker configuration for given job.
     */
    async getDockerPipelineConfiguration(requestParameters: GetDockerPipelineConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDockerPipelineConfiguration> {
        const response = await this.getDockerPipelineConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch linked Jira issue details.
     */
    async getIssueDetailsRaw(requestParameters: GetIssueDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestJiraIssue>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getIssueDetails().'
            );
        }

        if (requestParameters['issueKey'] == null) {
            throw new runtime.RequiredError(
                'issueKey',
                'Required parameter "issueKey" was null or undefined when calling getIssueDetails().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getIssueDetails().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/issue/{issueKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"issueKey"}}`, encodeURIComponent(String(requestParameters['issueKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch linked Jira issue details.
     */
    async getIssueDetails(requestParameters: GetIssueDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestJiraIssue> {
        const response = await this.getIssueDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch plan details.
     */
    async getPlanRaw(requestParameters: GetPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPlan>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPlan().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getPlan().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch plan details.
     */
    async getPlan(requestParameters: GetPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPlan> {
        const response = await this.getPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch plan details.
     */
    async getPlanAliasRaw(requestParameters: GetPlanAliasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPlan>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPlanAlias().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getPlanAlias().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}/{buildKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch plan details.
     */
    async getPlanAlias(requestParameters: GetPlanAliasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPlan> {
        const response = await this.getPlanAliasRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch plan\'s shared artifact definitions.
     */
    async getPlanArtifactDefinitionRaw(requestParameters: GetPlanArtifactDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestArtifactDefinitions>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPlanArtifactDefinition().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getPlanArtifactDefinition().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['maxResult'] != null) {
            queryParameters['max-result'] = requestParameters['maxResult'];
        }

        if (requestParameters['startIndex'] != null) {
            queryParameters['start-index'] = requestParameters['startIndex'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/artifact`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch plan\'s shared artifact definitions.
     */
    async getPlanArtifactDefinition(requestParameters: GetPlanArtifactDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestArtifactDefinitions> {
        const response = await this.getPlanArtifactDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provide details for specified branch of a specified plan.
     */
    async getPlanBranchRaw(requestParameters: GetPlanBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPlanBranch>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPlanBranch().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getPlanBranch().'
            );
        }

        if (requestParameters['branchName'] == null) {
            throw new runtime.RequiredError(
                'branchName',
                'Required parameter "branchName" was null or undefined when calling getPlanBranch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/branch/{branchName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))).replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters['branchName']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide details for specified branch of a specified plan.
     */
    async getPlanBranch(requestParameters: GetPlanBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPlanBranch> {
        const response = await this.getPlanBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch list of branches for specified plan.
     */
    async getPlanBranchesRaw(requestParameters: GetPlanBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPlanBranches().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getPlanBranches().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['enabledOnly'] != null) {
            queryParameters['enabledOnly'] = requestParameters['enabledOnly'];
        }

        if (requestParameters['cloverEnabled'] != null) {
            queryParameters['cloverEnabled'] = requestParameters['cloverEnabled'];
        }

        if (requestParameters['my'] != null) {
            queryParameters['my'] = requestParameters['my'];
        }

        if (requestParameters['favourite'] != null) {
            queryParameters['favourite'] = requestParameters['favourite'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/branch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Fetch list of branches for specified plan.
     */
    async getPlanBranches(requestParameters: GetPlanBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getPlanBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides the directories where artifacts and build logs can be found for a given plan key. Disabled by default.  See https://confluence.atlassian.com/display/BAMBOO/Plan+directory+information+REST+API for more information.
     */
    async getPlanDirectoryRaw(requestParameters: GetPlanDirectoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DirectoryInformationResponse>> {
        if (requestParameters['planKey'] == null) {
            throw new runtime.RequiredError(
                'planKey',
                'Required parameter "planKey" was null or undefined when calling getPlanDirectory().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/planDirectoryInfo/{planKey}`.replace(`{${"planKey"}}`, encodeURIComponent(String(requestParameters['planKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provides the directories where artifacts and build logs can be found for a given plan key. Disabled by default.  See https://confluence.atlassian.com/display/BAMBOO/Plan+directory+information+REST+API for more information.
     */
    async getPlanDirectory(requestParameters: GetPlanDirectoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DirectoryInformationResponse> {
        const response = await this.getPlanDirectoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List of labels for plan.
     */
    async getPlanLabelsRaw(requestParameters: GetPlanLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBuildLabels>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPlanLabels().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getPlanLabels().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/label`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * List of labels for plan.
     */
    async getPlanLabels(requestParameters: GetPlanLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBuildLabels> {
        const response = await this.getPlanLabelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the plan variable by given name.
     */
    async getPlanVariableRaw(requestParameters: GetPlanVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestVariable>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPlanVariable().'
            );
        }

        if (requestParameters['variableName'] == null) {
            throw new runtime.RequiredError(
                'variableName',
                'Required parameter "variableName" was null or undefined when calling getPlanVariable().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getPlanVariable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/variables/{variableName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"variableName"}}`, encodeURIComponent(String(requestParameters['variableName']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the plan variable by given name.
     */
    async getPlanVariable(requestParameters: GetPlanVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestVariable> {
        const response = await this.getPlanVariableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the list of all variables for a plan.
     */
    async getPlanVariablesRaw(requestParameters: GetPlanVariablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getPlanVariables().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getPlanVariables().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/variables`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve the list of all variables for a plan.
     */
    async getPlanVariables(requestParameters: GetPlanVariablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getPlanVariablesRaw(requestParameters, initOverrides);
    }

    /**
     * List of vcs branch names for branches that exist on the default repository of this plan.
     */
    async getVcsBranchesRaw(requestParameters: GetVcsBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getVcsBranches().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling getVcsBranches().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['maxResult'] != null) {
            queryParameters['max-result'] = requestParameters['maxResult'];
        }

        if (requestParameters['searchTerm'] != null) {
            queryParameters['searchTerm'] = requestParameters['searchTerm'];
        }

        if (requestParameters['startIndex'] != null) {
            queryParameters['start-index'] = requestParameters['startIndex'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/vcsBranches`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * List of vcs branch names for branches that exist on the default repository of this plan.
     */
    async getVcsBranches(requestParameters: GetVcsBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getVcsBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add plan to favourite.
     */
    async markPlanFavouriteRaw(requestParameters: MarkPlanFavouriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling markPlanFavourite().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling markPlanFavourite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/favourite`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add plan to favourite.
     */
    async markPlanFavourite(requestParameters: MarkPlanFavouriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.markPlanFavouriteRaw(requestParameters, initOverrides);
    }

    /**
     * Quarantine plan\'s test.
     */
    async quarantineTestRaw(requestParameters: QuarantineTestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling quarantineTest().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling quarantineTest().'
            );
        }

        if (requestParameters['testId'] == null) {
            throw new runtime.RequiredError(
                'testId',
                'Required parameter "testId" was null or undefined when calling quarantineTest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/test/{testId}/quarantine`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))).replace(`{${"testId"}}`, encodeURIComponent(String(requestParameters['testId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Quarantine plan\'s test.
     */
    async quarantineTest(requestParameters: QuarantineTestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.quarantineTestRaw(requestParameters, initOverrides);
    }

    /**
     * Remove label from plan.
     */
    async removePlanLabelRaw(requestParameters: RemovePlanLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling removePlanLabel().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling removePlanLabel().'
            );
        }

        if (requestParameters['labelName'] == null) {
            throw new runtime.RequiredError(
                'labelName',
                'Required parameter "labelName" was null or undefined when calling removePlanLabel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/label/{labelName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))).replace(`{${"labelName"}}`, encodeURIComponent(String(requestParameters['labelName']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove label from plan.
     */
    async removePlanLabel(requestParameters: RemovePlanLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removePlanLabelRaw(requestParameters, initOverrides);
    }

    /**
     * Updates Docker configuration for given job.
     */
    async setDockerPipelineConfigurationRaw(requestParameters: SetDockerPipelineConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['jobKey'] == null) {
            throw new runtime.RequiredError(
                'jobKey',
                'Required parameter "jobKey" was null or undefined when calling setDockerPipelineConfiguration().'
            );
        }

        if (requestParameters['restDockerPipelineConfiguration'] == null) {
            throw new runtime.RequiredError(
                'restDockerPipelineConfiguration',
                'Required parameter "restDockerPipelineConfiguration" was null or undefined when calling setDockerPipelineConfiguration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/job/{jobKey}/docker`.replace(`{${"jobKey"}}`, encodeURIComponent(String(requestParameters['jobKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restDockerPipelineConfiguration'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates Docker configuration for given job.
     */
    async setDockerPipelineConfiguration(requestParameters: SetDockerPipelineConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setDockerPipelineConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     * Unleash plan\'s test from quarantine.
     */
    async unleashTestRaw(requestParameters: UnleashTestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unleashTest().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling unleashTest().'
            );
        }

        if (requestParameters['testId'] == null) {
            throw new runtime.RequiredError(
                'testId',
                'Required parameter "testId" was null or undefined when calling unleashTest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/test/{testId}/unleash`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))).replace(`{${"testId"}}`, encodeURIComponent(String(requestParameters['testId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unleash plan\'s test from quarantine.
     */
    async unleashTest(requestParameters: UnleashTestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unleashTestRaw(requestParameters, initOverrides);
    }

    /**
     * Remove plan from favorites.
     */
    async unmarkPlanFavouriteRaw(requestParameters: UnmarkPlanFavouriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling unmarkPlanFavourite().'
            );
        }

        if (requestParameters['buildKey'] == null) {
            throw new runtime.RequiredError(
                'buildKey',
                'Required parameter "buildKey" was null or undefined when calling unmarkPlanFavourite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/{projectKey}-{buildKey}/favourite`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters['buildKey']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove plan from favorites.
     */
    async unmarkPlanFavourite(requestParameters: UnmarkPlanFavouriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unmarkPlanFavouriteRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ExportPlanSpecFormatEnum = {
    Java: 'JAVA',
    Yaml: 'YAML'
} as const;
export type ExportPlanSpecFormatEnum = typeof ExportPlanSpecFormatEnum[keyof typeof ExportPlanSpecFormatEnum];
