/* tslint:disable */
/* eslint-disable */
/**
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DefaultWorkflow,
  IssueTypeWorkflowMapping,
  IssueTypesWorkflowMapping,
  PageBeanWorkflowScheme,
  TaskProgressBeanObject,
  WorkflowScheme,
  WorkflowSchemeReadRequest,
  WorkflowSchemeReadResponse,
  WorkflowSchemeUpdateRequest,
  WorkflowSchemeUpdateRequiredMappingsRequest,
  WorkflowSchemeUpdateRequiredMappingsResponse,
} from '../models';

export interface CreateWorkflowSchemeRequest {
    workflowScheme: WorkflowScheme;
}

export interface DeleteDefaultWorkflowRequest {
    id: number;
    updateDraftIfNeeded?: boolean;
}

export interface DeleteWorkflowMappingRequest {
    id: number;
    workflowName: string;
    updateDraftIfNeeded?: boolean;
}

export interface DeleteWorkflowSchemeRequest {
    id: number;
}

export interface DeleteWorkflowSchemeIssueTypeRequest {
    id: number;
    issueType: string;
    updateDraftIfNeeded?: boolean;
}

export interface GetAllWorkflowSchemesRequest {
    startAt?: number;
    maxResults?: number;
}

export interface GetDefaultWorkflowRequest {
    id: number;
    returnDraftIfExists?: boolean;
}

export interface GetWorkflowRequest {
    id: number;
    workflowName?: string;
    returnDraftIfExists?: boolean;
}

export interface GetWorkflowSchemeRequest {
    id: number;
    returnDraftIfExists?: boolean;
}

export interface GetWorkflowSchemeIssueTypeRequest {
    id: number;
    issueType: string;
    returnDraftIfExists?: boolean;
}

export interface ReadWorkflowSchemesRequest {
    workflowSchemeReadRequest: WorkflowSchemeReadRequest;
    expand?: string;
}

export interface SetWorkflowSchemeIssueTypeRequest {
    id: number;
    issueType: string;
    issueTypeWorkflowMapping: IssueTypeWorkflowMapping;
}

export interface UpdateDefaultWorkflowRequest {
    id: number;
    defaultWorkflow: DefaultWorkflow;
}

export interface UpdateSchemesRequest {
    requestBody: { [key: string]: any; };
}

export interface UpdateWorkflowMappingRequest {
    id: number;
    workflowName: string;
    issueTypesWorkflowMapping: IssueTypesWorkflowMapping;
}

export interface UpdateWorkflowSchemeRequest {
    id: number;
    workflowScheme: WorkflowScheme;
}

export interface UpdateWorkflowSchemeMappingsRequest {
    workflowSchemeUpdateRequiredMappingsRequest: WorkflowSchemeUpdateRequiredMappingsRequest;
}

/**
 * 
 */
export class WorkflowSchemesApi extends runtime.BaseAPI {

    /**
     * Creates a workflow scheme.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Create workflow scheme
     */
    async createWorkflowSchemeRaw(requestParameters: CreateWorkflowSchemeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowScheme>> {
        if (requestParameters.workflowScheme === null || requestParameters.workflowScheme === undefined) {
            throw new runtime.RequiredError('workflowScheme','Required parameter requestParameters.workflowScheme was null or undefined when calling createWorkflowScheme.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.workflowScheme,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a workflow scheme.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Create workflow scheme
     */
    async createWorkflowScheme(requestParameters: CreateWorkflowSchemeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowScheme> {
        const response = await this.createWorkflowSchemeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resets the default workflow for a workflow scheme. That is, the default workflow is set to Jira\'s system workflow (the *jira* workflow).  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme is created or updated with the default workflow reset. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Delete default workflow
     */
    async deleteDefaultWorkflowRaw(requestParameters: DeleteDefaultWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowScheme>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteDefaultWorkflow.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateDraftIfNeeded !== undefined) {
            queryParameters['updateDraftIfNeeded'] = requestParameters.updateDraftIfNeeded;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/default`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Resets the default workflow for a workflow scheme. That is, the default workflow is set to Jira\'s system workflow (the *jira* workflow).  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme is created or updated with the default workflow reset. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Delete default workflow
     */
    async deleteDefaultWorkflow(requestParameters: DeleteDefaultWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowScheme> {
        const response = await this.deleteDefaultWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the workflow-issue type mapping for a workflow in a workflow scheme.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme is created or updated with the workflow-issue type mapping deleted. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Delete issue types for workflow in workflow scheme
     */
    async deleteWorkflowMappingRaw(requestParameters: DeleteWorkflowMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteWorkflowMapping.');
        }

        if (requestParameters.workflowName === null || requestParameters.workflowName === undefined) {
            throw new runtime.RequiredError('workflowName','Required parameter requestParameters.workflowName was null or undefined when calling deleteWorkflowMapping.');
        }

        const queryParameters: any = {};

        if (requestParameters.workflowName !== undefined) {
            queryParameters['workflowName'] = requestParameters.workflowName;
        }

        if (requestParameters.updateDraftIfNeeded !== undefined) {
            queryParameters['updateDraftIfNeeded'] = requestParameters.updateDraftIfNeeded;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/workflow`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the workflow-issue type mapping for a workflow in a workflow scheme.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme is created or updated with the workflow-issue type mapping deleted. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Delete issue types for workflow in workflow scheme
     */
    async deleteWorkflowMapping(requestParameters: DeleteWorkflowMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWorkflowMappingRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a workflow scheme. Note that a workflow scheme cannot be deleted if it is active (that is, being used by at least one project).  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Delete workflow scheme
     */
    async deleteWorkflowSchemeRaw(requestParameters: DeleteWorkflowSchemeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteWorkflowScheme.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Deletes a workflow scheme. Note that a workflow scheme cannot be deleted if it is active (that is, being used by at least one project).  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Delete workflow scheme
     */
    async deleteWorkflowScheme(requestParameters: DeleteWorkflowSchemeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteWorkflowSchemeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the issue type-workflow mapping for an issue type in a workflow scheme.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme is created or updated with the issue type-workflow mapping deleted. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Delete workflow for issue type in workflow scheme
     */
    async deleteWorkflowSchemeIssueTypeRaw(requestParameters: DeleteWorkflowSchemeIssueTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowScheme>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteWorkflowSchemeIssueType.');
        }

        if (requestParameters.issueType === null || requestParameters.issueType === undefined) {
            throw new runtime.RequiredError('issueType','Required parameter requestParameters.issueType was null or undefined when calling deleteWorkflowSchemeIssueType.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateDraftIfNeeded !== undefined) {
            queryParameters['updateDraftIfNeeded'] = requestParameters.updateDraftIfNeeded;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/issuetype/{issueType}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"issueType"}}`, encodeURIComponent(String(requestParameters.issueType))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deletes the issue type-workflow mapping for an issue type in a workflow scheme.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme is created or updated with the issue type-workflow mapping deleted. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Delete workflow for issue type in workflow scheme
     */
    async deleteWorkflowSchemeIssueType(requestParameters: DeleteWorkflowSchemeIssueTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowScheme> {
        const response = await this.deleteWorkflowSchemeIssueTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a [paginated](#pagination) list of all workflow schemes, not including draft workflow schemes.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get all workflow schemes
     */
    async getAllWorkflowSchemesRaw(requestParameters: GetAllWorkflowSchemesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageBeanWorkflowScheme>> {
        const queryParameters: any = {};

        if (requestParameters.startAt !== undefined) {
            queryParameters['startAt'] = requestParameters.startAt;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['maxResults'] = requestParameters.maxResults;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a [paginated](#pagination) list of all workflow schemes, not including draft workflow schemes.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get all workflow schemes
     */
    async getAllWorkflowSchemes(requestParameters: GetAllWorkflowSchemesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageBeanWorkflowScheme> {
        const response = await this.getAllWorkflowSchemesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the default workflow for a workflow scheme. The default workflow is the workflow that is assigned any issue types that have not been mapped to any other workflow. The default workflow has *All Unassigned Issue Types* listed in its issue types for the workflow scheme in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get default workflow
     */
    async getDefaultWorkflowRaw(requestParameters: GetDefaultWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DefaultWorkflow>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getDefaultWorkflow.');
        }

        const queryParameters: any = {};

        if (requestParameters.returnDraftIfExists !== undefined) {
            queryParameters['returnDraftIfExists'] = requestParameters.returnDraftIfExists;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/default`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the default workflow for a workflow scheme. The default workflow is the workflow that is assigned any issue types that have not been mapped to any other workflow. The default workflow has *All Unassigned Issue Types* listed in its issue types for the workflow scheme in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get default workflow
     */
    async getDefaultWorkflow(requestParameters: GetDefaultWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DefaultWorkflow> {
        const response = await this.getDefaultWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the workflow-issue type mappings for a workflow scheme.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get issue types for workflows in workflow scheme
     */
    async getWorkflowRaw(requestParameters: GetWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssueTypesWorkflowMapping>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getWorkflow.');
        }

        const queryParameters: any = {};

        if (requestParameters.workflowName !== undefined) {
            queryParameters['workflowName'] = requestParameters.workflowName;
        }

        if (requestParameters.returnDraftIfExists !== undefined) {
            queryParameters['returnDraftIfExists'] = requestParameters.returnDraftIfExists;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/workflow`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the workflow-issue type mappings for a workflow scheme.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get issue types for workflows in workflow scheme
     */
    async getWorkflow(requestParameters: GetWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssueTypesWorkflowMapping> {
        const response = await this.getWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a workflow scheme.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get workflow scheme
     */
    async getWorkflowSchemeRaw(requestParameters: GetWorkflowSchemeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowScheme>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getWorkflowScheme.');
        }

        const queryParameters: any = {};

        if (requestParameters.returnDraftIfExists !== undefined) {
            queryParameters['returnDraftIfExists'] = requestParameters.returnDraftIfExists;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a workflow scheme.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get workflow scheme
     */
    async getWorkflowScheme(requestParameters: GetWorkflowSchemeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowScheme> {
        const response = await this.getWorkflowSchemeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the issue type-workflow mapping for an issue type in a workflow scheme.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get workflow for issue type in workflow scheme
     */
    async getWorkflowSchemeIssueTypeRaw(requestParameters: GetWorkflowSchemeIssueTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssueTypeWorkflowMapping>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getWorkflowSchemeIssueType.');
        }

        if (requestParameters.issueType === null || requestParameters.issueType === undefined) {
            throw new runtime.RequiredError('issueType','Required parameter requestParameters.issueType was null or undefined when calling getWorkflowSchemeIssueType.');
        }

        const queryParameters: any = {};

        if (requestParameters.returnDraftIfExists !== undefined) {
            queryParameters['returnDraftIfExists'] = requestParameters.returnDraftIfExists;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/issuetype/{issueType}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"issueType"}}`, encodeURIComponent(String(requestParameters.issueType))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the issue type-workflow mapping for an issue type in a workflow scheme.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Get workflow for issue type in workflow scheme
     */
    async getWorkflowSchemeIssueType(requestParameters: GetWorkflowSchemeIssueTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssueTypeWorkflowMapping> {
        const response = await this.getWorkflowSchemeIssueTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of workflow schemes by providing workflow scheme IDs or project IDs.  **[Permissions](#permissions) required:**   *  *Administer Jira* global permission to access all, including project-scoped, workflow schemes  *  *Administer projects* project permissions to access project-scoped workflow schemes
     * Bulk get workflow schemes
     */
    async readWorkflowSchemesRaw(requestParameters: ReadWorkflowSchemesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkflowSchemeReadResponse>>> {
        if (requestParameters.workflowSchemeReadRequest === null || requestParameters.workflowSchemeReadRequest === undefined) {
            throw new runtime.RequiredError('workflowSchemeReadRequest','Required parameter requestParameters.workflowSchemeReadRequest was null or undefined when calling readWorkflowSchemes.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/read`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.workflowSchemeReadRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a list of workflow schemes by providing workflow scheme IDs or project IDs.  **[Permissions](#permissions) required:**   *  *Administer Jira* global permission to access all, including project-scoped, workflow schemes  *  *Administer projects* project permissions to access project-scoped workflow schemes
     * Bulk get workflow schemes
     */
    async readWorkflowSchemes(requestParameters: ReadWorkflowSchemesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkflowSchemeReadResponse>> {
        const response = await this.readWorkflowSchemesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the workflow for an issue type in a workflow scheme.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` in the request body and a draft workflow scheme is created or updated with the new issue type-workflow mapping. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Set workflow for issue type in workflow scheme
     */
    async setWorkflowSchemeIssueTypeRaw(requestParameters: SetWorkflowSchemeIssueTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowScheme>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling setWorkflowSchemeIssueType.');
        }

        if (requestParameters.issueType === null || requestParameters.issueType === undefined) {
            throw new runtime.RequiredError('issueType','Required parameter requestParameters.issueType was null or undefined when calling setWorkflowSchemeIssueType.');
        }

        if (requestParameters.issueTypeWorkflowMapping === null || requestParameters.issueTypeWorkflowMapping === undefined) {
            throw new runtime.RequiredError('issueTypeWorkflowMapping','Required parameter requestParameters.issueTypeWorkflowMapping was null or undefined when calling setWorkflowSchemeIssueType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/issuetype/{issueType}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"issueType"}}`, encodeURIComponent(String(requestParameters.issueType))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.issueTypeWorkflowMapping,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the workflow for an issue type in a workflow scheme.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` in the request body and a draft workflow scheme is created or updated with the new issue type-workflow mapping. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Set workflow for issue type in workflow scheme
     */
    async setWorkflowSchemeIssueType(requestParameters: SetWorkflowSchemeIssueTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowScheme> {
        const response = await this.setWorkflowSchemeIssueTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the default workflow for a workflow scheme.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` in the request object and a draft workflow scheme is created or updated with the new default workflow. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Update default workflow
     */
    async updateDefaultWorkflowRaw(requestParameters: UpdateDefaultWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowScheme>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateDefaultWorkflow.');
        }

        if (requestParameters.defaultWorkflow === null || requestParameters.defaultWorkflow === undefined) {
            throw new runtime.RequiredError('defaultWorkflow','Required parameter requestParameters.defaultWorkflow was null or undefined when calling updateDefaultWorkflow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/default`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.defaultWorkflow,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the default workflow for a workflow scheme.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` in the request object and a draft workflow scheme is created or updated with the new default workflow. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Update default workflow
     */
    async updateDefaultWorkflow(requestParameters: UpdateDefaultWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowScheme> {
        const response = await this.updateDefaultWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates company-managed and team-managed project workflow schemes. This API doesn\'t have a concept of draft, so any changes made to a workflow scheme are immediately available. When changing the available statuses for issue types, an [asynchronous task](#async) migrates the issues as defined in the provided mappings.  **[Permissions](#permissions) required:**   *  *Administer Jira* project permission to update all, including global-scoped, workflow schemes.  *  *Administer projects* project permission to update project-scoped workflow schemes.
     * Update workflow scheme
     */
    async updateSchemesRaw(requestParameters: UpdateSchemesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling updateSchemes.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Updates company-managed and team-managed project workflow schemes. This API doesn\'t have a concept of draft, so any changes made to a workflow scheme are immediately available. When changing the available statuses for issue types, an [asynchronous task](#async) migrates the issues as defined in the provided mappings.  **[Permissions](#permissions) required:**   *  *Administer Jira* project permission to update all, including global-scoped, workflow schemes.  *  *Administer projects* project permission to update project-scoped workflow schemes.
     * Update workflow scheme
     */
    async updateSchemes(requestParameters: UpdateSchemesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateSchemesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the issue types for a workflow in a workflow scheme. The workflow can also be set as the default workflow for the workflow scheme. Unmapped issues types are mapped to the default workflow.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` in the request body and a draft workflow scheme is created or updated with the new workflow-issue types mappings. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Set issue types for workflow in workflow scheme
     */
    async updateWorkflowMappingRaw(requestParameters: UpdateWorkflowMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowScheme>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateWorkflowMapping.');
        }

        if (requestParameters.workflowName === null || requestParameters.workflowName === undefined) {
            throw new runtime.RequiredError('workflowName','Required parameter requestParameters.workflowName was null or undefined when calling updateWorkflowMapping.');
        }

        if (requestParameters.issueTypesWorkflowMapping === null || requestParameters.issueTypesWorkflowMapping === undefined) {
            throw new runtime.RequiredError('issueTypesWorkflowMapping','Required parameter requestParameters.issueTypesWorkflowMapping was null or undefined when calling updateWorkflowMapping.');
        }

        const queryParameters: any = {};

        if (requestParameters.workflowName !== undefined) {
            queryParameters['workflowName'] = requestParameters.workflowName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}/workflow`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.issueTypesWorkflowMapping,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the issue types for a workflow in a workflow scheme. The workflow can also be set as the default workflow for the workflow scheme. Unmapped issues types are mapped to the default workflow.  Note that active workflow schemes cannot be edited. If the workflow scheme is active, set `updateDraftIfNeeded` to `true` in the request body and a draft workflow scheme is created or updated with the new workflow-issue types mappings. The draft workflow scheme can be published in Jira.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Set issue types for workflow in workflow scheme
     */
    async updateWorkflowMapping(requestParameters: UpdateWorkflowMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowScheme> {
        const response = await this.updateWorkflowMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a company-manged project workflow scheme, including the name, default workflow, issue type to project mappings, and more. If the workflow scheme is active (that is, being used by at least one project), then a draft workflow scheme is created or updated instead, provided that `updateDraftIfNeeded` is set to `true`.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Classic update workflow scheme
     */
    async updateWorkflowSchemeRaw(requestParameters: UpdateWorkflowSchemeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowScheme>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateWorkflowScheme.');
        }

        if (requestParameters.workflowScheme === null || requestParameters.workflowScheme === undefined) {
            throw new runtime.RequiredError('workflowScheme','Required parameter requestParameters.workflowScheme was null or undefined when calling updateWorkflowScheme.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.workflowScheme,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates a company-manged project workflow scheme, including the name, default workflow, issue type to project mappings, and more. If the workflow scheme is active (that is, being used by at least one project), then a draft workflow scheme is created or updated instead, provided that `updateDraftIfNeeded` is set to `true`.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Classic update workflow scheme
     */
    async updateWorkflowScheme(requestParameters: UpdateWorkflowSchemeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowScheme> {
        const response = await this.updateWorkflowSchemeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the required status mappings for the desired changes to a workflow scheme. The results are provided per issue type and workflow. When updating a workflow scheme, status mappings can be provided per issue type, per workflow, or both.  **[Permissions](#permissions) required:**   *  *Administer Jira* permission to update all, including global-scoped, workflow schemes.  *  *Administer projects* project permission to update project-scoped workflow schemes.
     * Get required status mappings for workflow scheme update
     */
    async updateWorkflowSchemeMappingsRaw(requestParameters: UpdateWorkflowSchemeMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowSchemeUpdateRequiredMappingsResponse>> {
        if (requestParameters.workflowSchemeUpdateRequiredMappingsRequest === null || requestParameters.workflowSchemeUpdateRequiredMappingsRequest === undefined) {
            throw new runtime.RequiredError('workflowSchemeUpdateRequiredMappingsRequest','Required parameter requestParameters.workflowSchemeUpdateRequiredMappingsRequest was null or undefined when calling updateWorkflowSchemeMappings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/workflowscheme/update/mappings`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.workflowSchemeUpdateRequiredMappingsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the required status mappings for the desired changes to a workflow scheme. The results are provided per issue type and workflow. When updating a workflow scheme, status mappings can be provided per issue type, per workflow, or both.  **[Permissions](#permissions) required:**   *  *Administer Jira* permission to update all, including global-scoped, workflow schemes.  *  *Administer projects* project permission to update project-scoped workflow schemes.
     * Get required status mappings for workflow scheme update
     */
    async updateWorkflowSchemeMappings(requestParameters: UpdateWorkflowSchemeMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowSchemeUpdateRequiredMappingsResponse> {
        const response = await this.updateWorkflowSchemeMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
