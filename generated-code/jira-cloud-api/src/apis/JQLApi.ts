/* tslint:disable */
/* eslint-disable */
/**
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT-006326f44f7f2ca50c1f9c8c88f70b27eb18a140
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AutoCompleteSuggestions,
  ConvertedJQLQueries,
  ErrorCollection,
  JQLPersonalDataMigrationRequest,
  JQLReferenceData,
  JqlQueriesToParse,
  JqlQueriesToSanitize,
  ParsedJqlQueries,
  SanitizedJqlQueries,
  SearchAutoCompleteFilter,
} from '../models/index';

export interface GetAutoCompletePostRequest {
    searchAutoCompleteFilter: SearchAutoCompleteFilter;
}

export interface GetFieldAutoCompleteForQueryStringRequest {
    fieldName?: string;
    fieldValue?: string;
    predicateName?: string;
    predicateValue?: string;
}

export interface MigrateQueriesRequest {
    jQLPersonalDataMigrationRequest: JQLPersonalDataMigrationRequest;
}

export interface ParseJqlQueriesRequest {
    validation: ParseJqlQueriesValidationEnum;
    jqlQueriesToParse: JqlQueriesToParse;
}

export interface SanitiseJqlQueriesRequest {
    jqlQueriesToSanitize: JqlQueriesToSanitize;
}

/**
 * 
 */
export class JQLApi extends runtime.BaseAPI {

    /**
     * Returns reference data for JQL searches. This is a downloadable version of the documentation provided in [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ) and [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ), along with a list of JQL-reserved words. Use this information to assist with the programmatic creation of JQL queries or the validation of queries built in a custom query builder.  To filter visible field details by project or collapse non-unique fields by field type then [Get field reference data (POST)](#api-rest-api-3-jql-autocompletedata-post) can be used.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** None.
     * Get field reference data (GET)
     */
    async getAutoCompleteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JQLReferenceData>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-work"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/jql/autocompletedata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns reference data for JQL searches. This is a downloadable version of the documentation provided in [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ) and [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ), along with a list of JQL-reserved words. Use this information to assist with the programmatic creation of JQL queries or the validation of queries built in a custom query builder.  To filter visible field details by project or collapse non-unique fields by field type then [Get field reference data (POST)](#api-rest-api-3-jql-autocompletedata-post) can be used.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** None.
     * Get field reference data (GET)
     */
    async getAutoComplete(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JQLReferenceData> {
        const response = await this.getAutoCompleteRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns reference data for JQL searches. This is a downloadable version of the documentation provided in [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ) and [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ), along with a list of JQL-reserved words. Use this information to assist with the programmatic creation of JQL queries or the validation of queries built in a custom query builder.  This operation can filter the custom fields returned by project. Invalid project IDs in `projectIds` are ignored. System fields are always returned.  It can also return the collapsed field for custom fields. Collapsed fields enable searches to be performed across all fields with the same name and of the same field type. For example, the collapsed field `Component - Component[Dropdown]` enables dropdown fields `Component - cf[10061]` and `Component - cf[10062]` to be searched simultaneously.  **[Permissions](#permissions) required:** None.
     * Get field reference data (POST)
     */
    async getAutoCompletePostRaw(requestParameters: GetAutoCompletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JQLReferenceData>> {
        if (requestParameters['searchAutoCompleteFilter'] == null) {
            throw new runtime.RequiredError(
                'searchAutoCompleteFilter',
                'Required parameter "searchAutoCompleteFilter" was null or undefined when calling getAutoCompletePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-work"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/jql/autocompletedata`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['searchAutoCompleteFilter'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns reference data for JQL searches. This is a downloadable version of the documentation provided in [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ) and [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ), along with a list of JQL-reserved words. Use this information to assist with the programmatic creation of JQL queries or the validation of queries built in a custom query builder.  This operation can filter the custom fields returned by project. Invalid project IDs in `projectIds` are ignored. System fields are always returned.  It can also return the collapsed field for custom fields. Collapsed fields enable searches to be performed across all fields with the same name and of the same field type. For example, the collapsed field `Component - Component[Dropdown]` enables dropdown fields `Component - cf[10061]` and `Component - cf[10062]` to be searched simultaneously.  **[Permissions](#permissions) required:** None.
     * Get field reference data (POST)
     */
    async getAutoCompletePost(requestParameters: GetAutoCompletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JQLReferenceData> {
        const response = await this.getAutoCompletePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the JQL search auto complete suggestions for a field.  Suggestions can be obtained by providing:   *  `fieldName` to get a list of all values for the field.  *  `fieldName` and `fieldValue` to get a list of values containing the text in `fieldValue`.  *  `fieldName` and `predicateName` to get a list of all predicate values for the field.  *  `fieldName`, `predicateName`, and `predicateValue` to get a list of predicate values containing the text in `predicateValue`.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** None.
     * Get field auto complete suggestions
     */
    async getFieldAutoCompleteForQueryStringRaw(requestParameters: GetFieldAutoCompleteForQueryStringRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteSuggestions>> {
        const queryParameters: any = {};

        if (requestParameters['fieldName'] != null) {
            queryParameters['fieldName'] = requestParameters['fieldName'];
        }

        if (requestParameters['fieldValue'] != null) {
            queryParameters['fieldValue'] = requestParameters['fieldValue'];
        }

        if (requestParameters['predicateName'] != null) {
            queryParameters['predicateName'] = requestParameters['predicateName'];
        }

        if (requestParameters['predicateValue'] != null) {
            queryParameters['predicateValue'] = requestParameters['predicateValue'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-work"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/jql/autocompletedata/suggestions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the JQL search auto complete suggestions for a field.  Suggestions can be obtained by providing:   *  `fieldName` to get a list of all values for the field.  *  `fieldName` and `fieldValue` to get a list of values containing the text in `fieldValue`.  *  `fieldName` and `predicateName` to get a list of all predicate values for the field.  *  `fieldName`, `predicateName`, and `predicateValue` to get a list of predicate values containing the text in `predicateValue`.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** None.
     * Get field auto complete suggestions
     */
    async getFieldAutoCompleteForQueryString(requestParameters: GetFieldAutoCompleteForQueryStringRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteSuggestions> {
        const response = await this.getFieldAutoCompleteForQueryStringRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Converts one or more JQL queries with user identifiers (username or user key) to equivalent JQL queries with account IDs.  You may wish to use this operation if your system stores JQL queries and you want to make them GDPR-compliant. For more information about GDPR-related changes, see the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/).  **[Permissions](#permissions) required:** Permission to access Jira.
     * Convert user identifiers to account IDs in JQL queries
     */
    async migrateQueriesRaw(requestParameters: MigrateQueriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConvertedJQLQueries>> {
        if (requestParameters['jQLPersonalDataMigrationRequest'] == null) {
            throw new runtime.RequiredError(
                'jQLPersonalDataMigrationRequest',
                'Required parameter "jQLPersonalDataMigrationRequest" was null or undefined when calling migrateQueries().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-user"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/jql/pdcleaner`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['jQLPersonalDataMigrationRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Converts one or more JQL queries with user identifiers (username or user key) to equivalent JQL queries with account IDs.  You may wish to use this operation if your system stores JQL queries and you want to make them GDPR-compliant. For more information about GDPR-related changes, see the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/).  **[Permissions](#permissions) required:** Permission to access Jira.
     * Convert user identifiers to account IDs in JQL queries
     */
    async migrateQueries(requestParameters: MigrateQueriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConvertedJQLQueries> {
        const response = await this.migrateQueriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Parses and validates JQL queries.  Validation is performed in context of the current user.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** None.
     * Parse JQL query
     */
    async parseJqlQueriesRaw(requestParameters: ParseJqlQueriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ParsedJqlQueries>> {
        if (requestParameters['validation'] == null) {
            throw new runtime.RequiredError(
                'validation',
                'Required parameter "validation" was null or undefined when calling parseJqlQueries().'
            );
        }

        if (requestParameters['jqlQueriesToParse'] == null) {
            throw new runtime.RequiredError(
                'jqlQueriesToParse',
                'Required parameter "jqlQueriesToParse" was null or undefined when calling parseJqlQueries().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['validation'] != null) {
            queryParameters['validation'] = requestParameters['validation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-work"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/jql/parse`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['jqlQueriesToParse'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Parses and validates JQL queries.  Validation is performed in context of the current user.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** None.
     * Parse JQL query
     */
    async parseJqlQueries(requestParameters: ParseJqlQueriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ParsedJqlQueries> {
        const response = await this.parseJqlQueriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sanitizes one or more JQL queries by converting readable details into IDs where a user doesn\'t have permission to view the entity.  For example, if the query contains the clause *project = \'Secret project\'*, and a user does not have browse permission for the project \"Secret project\", the sanitized query replaces the clause with *project = 12345\"* (where 12345 is the ID of the project). If a user has the required permission, the clause is not sanitized. If the account ID is null, sanitizing is performed for an anonymous user.  Note that sanitization doesn\'t make the queries GDPR-compliant, because it doesn\'t remove user identifiers (username or user key). If you need to make queries GDPR-compliant, use [Convert user identifiers to account IDs in JQL queries](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-jql/#api-rest-api-3-jql-sanitize-post).  Before sanitization each JQL query is parsed. The queries are returned in the same order that they were passed.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Sanitize JQL queries
     */
    async sanitiseJqlQueriesRaw(requestParameters: SanitiseJqlQueriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SanitizedJqlQueries>> {
        if (requestParameters['jqlQueriesToSanitize'] == null) {
            throw new runtime.RequiredError(
                'jqlQueriesToSanitize',
                'Required parameter "jqlQueriesToSanitize" was null or undefined when calling sanitiseJqlQueries().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["manage:jira-configuration"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/jql/sanitize`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['jqlQueriesToSanitize'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sanitizes one or more JQL queries by converting readable details into IDs where a user doesn\'t have permission to view the entity.  For example, if the query contains the clause *project = \'Secret project\'*, and a user does not have browse permission for the project \"Secret project\", the sanitized query replaces the clause with *project = 12345\"* (where 12345 is the ID of the project). If a user has the required permission, the clause is not sanitized. If the account ID is null, sanitizing is performed for an anonymous user.  Note that sanitization doesn\'t make the queries GDPR-compliant, because it doesn\'t remove user identifiers (username or user key). If you need to make queries GDPR-compliant, use [Convert user identifiers to account IDs in JQL queries](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-jql/#api-rest-api-3-jql-sanitize-post).  Before sanitization each JQL query is parsed. The queries are returned in the same order that they were passed.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * Sanitize JQL queries
     */
    async sanitiseJqlQueries(requestParameters: SanitiseJqlQueriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SanitizedJqlQueries> {
        const response = await this.sanitiseJqlQueriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ParseJqlQueriesValidationEnum = {
    Strict: 'strict',
    Warn: 'warn',
    None: 'none'
} as const;
export type ParseJqlQueriesValidationEnum = typeof ParseJqlQueriesValidationEnum[keyof typeof ParseJqlQueriesValidationEnum];
